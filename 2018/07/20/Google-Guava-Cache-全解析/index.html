<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Google Guava Cache 全解析 | Bameirilyo&#39;s Blog | 纵有疾风起，人生不言弃</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="Google Guava Cache是一种非常优秀本地缓存解决方案，提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用LRU算法，基于引用回收很好的利用了Java虚拟机的垃圾回收机制。其中的缓存构造器CacheBuilder采用构建者模式提供了设置好各种参数的缓存对象，缓存核心类LocalCache里面的内部类Segment与jdk1.7及以前的ConcurrentHashMa">
<meta property="og:type" content="article">
<meta property="og:title" content="Google Guava Cache 全解析">
<meta property="og:url" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/index.html">
<meta property="og:site_name" content="Bameirilyo&#39;s Blog">
<meta property="og:description" content="Google Guava Cache是一种非常优秀本地缓存解决方案，提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用LRU算法，基于引用回收很好的利用了Java虚拟机的垃圾回收机制。其中的缓存构造器CacheBuilder采用构建者模式提供了设置好各种参数的缓存对象，缓存核心类LocalCache里面的内部类Segment与jdk1.7及以前的ConcurrentHashMa">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/Demo1结果.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/LRU缓存回收算法.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/Guava%20Cache体系类图.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/LocalCache数据结构.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/put.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/preWriteCleanup.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/evictEntries.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/getIfPresent.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/get.png">
<meta property="og:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/remove.png">
<meta property="og:updated_time" content="2018-07-20T03:07:04.495Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Google Guava Cache 全解析">
<meta name="twitter:description" content="Google Guava Cache是一种非常优秀本地缓存解决方案，提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用LRU算法，基于引用回收很好的利用了Java虚拟机的垃圾回收机制。其中的缓存构造器CacheBuilder采用构建者模式提供了设置好各种参数的缓存对象，缓存核心类LocalCache里面的内部类Segment与jdk1.7及以前的ConcurrentHashMa">
<meta name="twitter:image" content="https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/Demo1结果.png">
    
        <link rel="alternate" type="application/atom+xml" title="Bameirilyo&#39;s Blog" href="/BameirilyoBlog/atom.xml">
    
    <link rel="shortcut icon" href="/BameirilyoBlog/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/BameirilyoBlog/img/brand.jpg)">
      <div class="brand">
        <a href="/BameirilyoBlog/" class="avatar waves-effect waves-circle waves-light">
          <img src="/BameirilyoBlog/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">豆腐小铭</h5>
          <a href="mailto:1172277547@qq.com" title="1172277547@qq.com" class="mail">1172277547@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/BameirilyoBlog/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/BameirilyoBlog/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                目录
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/BameirilyoBlog/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/BameirilyoBlog/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Bameirilyo" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/3287259165/profile?topnav=1&wvr=6" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Google Guava Cache 全解析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Google Guava Cache 全解析</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-07-20T02:48:51.000Z" itemprop="datePublished" class="page-time">
  2018年07月20日
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#为什么要用本地缓存"><span class="post-toc-text">为什么要用本地缓存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#什么时候用"><span class="post-toc-text">什么时候用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#怎么用"><span class="post-toc-text">怎么用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#加载"><span class="post-toc-text">加载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#CacheLoader"><span class="post-toc-text">CacheLoader</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Callable"><span class="post-toc-text">Callable</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Cache-put"><span class="post-toc-text">Cache.put</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存回收"><span class="post-toc-text">缓存回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-基于容量回收"><span class="post-toc-text">1. 基于容量回收</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-定时回收"><span class="post-toc-text">2.  定时回收</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-基于引用回收（Reference-based-Eviction）"><span class="post-toc-text">3. 基于引用回收（Reference-based Eviction）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#显式清除"><span class="post-toc-text">显式清除</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#移除监听器"><span class="post-toc-text">移除监听器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#统计"><span class="post-toc-text">统计</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LRU缓存回收算法"><span class="post-toc-text">LRU缓存回收算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Guava-Cache体系类图"><span class="post-toc-text">Guava Cache体系类图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#CacheBuilder"><span class="post-toc-text">CacheBuilder</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LocalManualCache"><span class="post-toc-text">LocalManualCache</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LocalLoadingCache"><span class="post-toc-text">LocalLoadingCache</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LocalCache"><span class="post-toc-text">LocalCache</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LocalCache数据结构"><span class="post-toc-text">LocalCache数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Segment-lt-K-V-gt-segments"><span class="post-toc-text">Segment&lt;K, V&gt;[] segments;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#AtomicReferenceArray-lt-ReferenceEntry-lt-K-V-gt-gt-table"><span class="post-toc-text">AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ReferenceEntry-lt-K-V-gt-referenceEntry"><span class="post-toc-text">ReferenceEntry&lt;K, V&gt; referenceEntry;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ReferenceQueue-keyReferenceQueue"><span class="post-toc-text">ReferenceQueue keyReferenceQueue;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ReferenceQueue-valueReferenceQueue"><span class="post-toc-text">ReferenceQueue valueReferenceQueue;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Queue-lt-ReferenceEntry-lt-K-V-gt-gt-recencyQueue"><span class="post-toc-text">Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; recencyQueue;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Queue-lt-ReferenceEntry-lt-K-V-gt-gt-writeQueue"><span class="post-toc-text">Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Queue-lt-ReferenceEntry-lt-K-V-gt-gt-accessQueue"><span class="post-toc-text">Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#put"><span class="post-toc-text">put</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#preWriteCleanup"><span class="post-toc-text">preWriteCleanup</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#evictEntries"><span class="post-toc-text">evictEntries</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#getIfPresent"><span class="post-toc-text">getIfPresent</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#get"><span class="post-toc-text">get</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#remove"><span class="post-toc-text">remove</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Google-Guava-Cache-全解析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Google Guava Cache 全解析</h1>
        <div class="post-meta">
            <time class="post-time" title="2018年07月20日 10:48:51" datetime="2018-07-20T02:48:51.000Z"  itemprop="datePublished">2018年07月20日</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>Google Guava Cache是一种非常优秀本地缓存解决方案，提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用LRU算法，基于引用回收很好的利用了Java虚拟机的垃圾回收机制。其中的缓存构造器CacheBuilder采用构建者模式提供了设置好各种参数的缓存对象，缓存核心类LocalCache里面的内部类Segment与jdk1.7及以前的ConcurrentHashMap非常相似，都继承于ReetrantLock，还有六个队列，以实现丰富的本地缓存方案。<br> 本文先介绍了Guava Cache囊括的基本使用方法，然后结合体系类图和LocalCache的数据结构对典型的几个方法源码进行流程分析。</p>
</blockquote>
<h2 id="为什么要用本地缓存"><a href="#为什么要用本地缓存" class="headerlink" title="为什么要用本地缓存"></a>为什么要用本地缓存</h2><blockquote>
<p><strong>相对于IO操作</strong><br> 速度快，效率高<br> <strong>相对于Redis</strong><br> Redis是一种优秀的分布式缓存实现，受限于网卡等原因，远水救不了近火。</p>
</blockquote>
<p>DB + Redis + LocalCache = 高效存储，高效访问</p>
<h2 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h2><ul>
<li>愿意消耗一些内存空间来提升速度</li>
<li>预料到某些键会被多次查询</li>
<li>缓存中存放的数据总量不会超出内存容量</li>
</ul>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ol>
<li>设置缓存容量</li>
<li>设置超时时间</li>
<li>提供移除监听器</li>
<li>提供缓存加载器</li>
<li>构建缓存</li>
</ol>
<p>Demo1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CacheLoader&lt;String, String&gt; loader = <span class="keyword">new</span> CacheLoader&lt;String,</span><br><span class="line">        String&gt; () &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"key"</span>.equals(key)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                System.out.println(key + <span class="string">" is loaded from a</span></span><br><span class="line"><span class="string">                                   cacheLoader!"</span>);</span><br><span class="line">                <span class="keyword">return</span> key + <span class="string">"'s value"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    RemovalListener&lt;String, String&gt; removalListener = <span class="keyword">new</span> RemovalListener&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; removal)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"["</span> + removal.getKey() + <span class="string">":"</span> + removal.getValue() + <span class="string">"] is evicted!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        LoadingCache&lt;String, String&gt; testCache = CacheBuilder.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">7</span>)</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .removalListener(removalListener)</span><br><span class="line">                .build(loader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            String key = <span class="string">"key"</span> + i;</span><br><span class="line">            String value = <span class="string">"value"</span> + i;</span><br><span class="line">            testCache.put(key,value);</span><br><span class="line">            System.out.println(<span class="string">"["</span> + key + <span class="string">":"</span> + value + <span class="string">"] is put into cache!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(testCache.getIfPresent(<span class="string">"key6"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(testCache.get(<span class="string">"key"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/Demo1结果.png" alt="img"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h5 id="CacheLoader"><a href="#CacheLoader" class="headerlink" title="CacheLoader"></a>CacheLoader</h5><p>如果有合理的默认方法来加载或计算与键关联的值。</p>
<p>LoadingCache是附带CacheLoader构建而成的缓存实现。创建自己的CacheLoader通常只需要简单地实现V load(K key) throws Exception方法。</p>
<p>从LoadingCache查询的正规方式是使用get(K)方法。这个方法要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值。由于CacheLoader可能抛出异常，LoadingCache.get(K)也声明为抛出ExecutionException异常。</p>
<h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>如果没有合理的默认方法来加载或计算与键关联的值，或者想要覆盖默认的加载运算，同时保留“获取缓存-如果没有-则计算”[get-if-absent-compute]的原子语义。<br> 所有类型的Guava Cache，不管有没有自动加载功能，都支持get(K, Callable<v>)方法。这个方法返回缓存中相应的值，或者用给定的Callable运算并把结果加入到缓存中。在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便地实现了模式”如果有缓存则返回；否则运算、缓存、然后返回”。</v></p>
<p>Demo2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Cache&lt;String, String&gt; testCache = CacheBuilder.newBuilder()</span><br><span class="line">            .maximumSize(<span class="number">3</span>)</span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        testCache.put(<span class="string">"1234"</span>,<span class="string">"45"</span>);</span><br><span class="line">        System.out.println(testCache.getIfPresent(<span class="string">"key6"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(testCache.get(<span class="string">"123"</span>, <span class="keyword">new</span> Callable&lt;String() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"134"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">            System.out.println(testCache.get(<span class="string">"1234"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"134"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<h5 id="Cache-put"><a href="#Cache-put" class="headerlink" title="Cache.put"></a>Cache.put</h5><p>但自动加载是首选的，因为它可以更容易地推断所有缓存内容的一致性。<br> 使用cache.put(key, value)方法可以直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值。使用Cache.asMap()视图提供的任何方法也能修改缓存。但请注意，asMap视图的任何方法都不能保证缓存项被原子地加载到缓存中。进一步说，asMap视图的原子运算在Guava Cache的原子加载范畴之外，所以相比于Cache.asMap().putIfAbsent(K,V)，Cache.get(K, Callable<v>) 应该总是优先使用。</v></p>
<h2 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h2><p>Guava Cache提供了三种基本的缓存回收方式:</p>
<h3 id="1-基于容量回收"><a href="#1-基于容量回收" class="headerlink" title="1. 基于容量回收"></a>1. 基于容量回收</h3><p>maximumSize(long)：当缓存中的元素数量超过指定值时。</p>
<h3 id="2-定时回收"><a href="#2-定时回收" class="headerlink" title="2.  定时回收"></a>2.  定时回收</h3><p>expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。<br> expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。<br> 如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。</p>
<h3 id="3-基于引用回收（Reference-based-Eviction）"><a href="#3-基于引用回收（Reference-based-Eviction）" class="headerlink" title="3. 基于引用回收（Reference-based Eviction）"></a>3. 基于引用回收（Reference-based Eviction）</h3><p>CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。<br> CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。<br> CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。</p>
<h2 id="显式清除"><a href="#显式清除" class="headerlink" title="显式清除"></a>显式清除</h2><p>任何时候，你都可以显式地清除缓存项，而不是等到它被回收：<br> 个别清除：Cache.invalidate(key)<br> 批量清除：Cache.invalidateAll(keys)<br> 清除所有缓存项：Cache.invalidateAll()</p>
<h2 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h2><p>通过CacheBuilder.removalListener(RemovalListener)，你可以声明一个监听器，以便缓存项被移除时做一些额外操作。缓存项被移除时，RemovalListener会获取移除通知[RemovalNotification]，其中包含移除原因[RemovalCause]、键和值。</p>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>CacheBuilder.recordStats()：用来开启Guava Cache的统计功能。统计打开后，Cache.stats()方法会返回CacheS tats 对象以提供如下统计信息：</p>
<p>hitRate()：缓存命中率；<br> averageLoadPenalty()：加载新值的平均时间，单位为纳秒；<br> evictionCount()：缓存项被回收的总数，不包括显式清除。<br> 此外，还有其他很多统计信息。这些统计信息对于调整缓存设置是至关重要的，在性能要求高的应用中我们建议密切关注这些数据。</p>
<p>Demo3:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Cache&lt;String, Object&gt; testCache = CacheBuilder.newBuilder()</span><br><span class="line">            .weakValues()</span><br><span class="line">            .recordStats()</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        testCache.put(<span class="string">"1234"</span>,obj1);</span><br><span class="line">        obj1 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(testCache.getIfPresent(<span class="string">"1234"</span>));</span><br><span class="line">        System.out.println(testCache.stats());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">CacheStats&#123;hitCount=<span class="number">0</span>, missCount=<span class="number">1</span>,</span><br><span class="line">	loadSuccessCount=<span class="number">0</span>,loadExceptionCount=<span class="number">0</span>,</span><br><span class="line">	totalLoadTime=<span class="number">0</span>,evictionCount=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LRU缓存回收算法"><a href="#LRU缓存回收算法" class="headerlink" title="LRU缓存回收算法"></a>LRU缓存回收算法</h2><blockquote>
<p>LRU（Least?recently?used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/LRU缓存回收算法.png" alt="img"></p>
<ol>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<p>Guava Cache中借助读写队列来实现LRU算法。</p>
<h2 id="Guava-Cache体系类图"><a href="#Guava-Cache体系类图" class="headerlink" title="Guava Cache体系类图"></a>Guava Cache体系类图</h2><p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/Guava Cache体系类图.png" alt="img"></p>
<h5 id="CacheBuilder"><a href="#CacheBuilder" class="headerlink" title="CacheBuilder"></a>CacheBuilder</h5><p>缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。<br> 主要采用builder的模式，CacheBuilder的每一个方法都返回这个CacheBuilder知道build方法的调用。<br> 注意build方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。</p>
<h5 id="LocalManualCache"><a href="#LocalManualCache" class="headerlink" title="LocalManualCache"></a>LocalManualCache</h5><p>作为LocalCache的一个内部类，在构造方法里面会把LocalCache类型的变量传入，并且调用方法时都直接或者间接调用LocalCache里面的方法。</p>
<h5 id="LocalLoadingCache"><a href="#LocalLoadingCache" class="headerlink" title="LocalLoadingCache"></a>LocalLoadingCache</h5><p>可以看到该类继承了LocalManualCache并实现接口LoadingCache。<br> 覆盖了get，getUnchecked等方法。</p>
<h5 id="LocalCache"><a href="#LocalCache" class="headerlink" title="LocalCache"></a>LocalCache</h5><p>Guava  Cache中的核心类，重点了解。</p>
<h2 id="LocalCache数据结构"><a href="#LocalCache数据结构" class="headerlink" title="LocalCache数据结构"></a>LocalCache数据结构</h2><blockquote>
<p>根据上面的分析可知，LocalCache为Guava Cache的核心类，先看一个该类的数据结构： �         LocalCache的数据结构与ConcurrentHashMap很相似，都由多个segment组成，且各segment相对独立，互不影响，所以能支持并行操作。每个segment由一个table和若干队列组成。缓存数据存储在table中，其类型为AtomicReferenceArray。</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/LocalCache数据结构.png" alt="img"></p>
<h5 id="Segment-lt-K-V-gt-segments"><a href="#Segment-lt-K-V-gt-segments" class="headerlink" title="Segment&lt;K, V&gt;[] segments;"></a>Segment&lt;K, V&gt;[] segments;</h5><p>Segment继承于ReetrantLock，减小锁粒度，提高并发效率。</p>
<h5 id="AtomicReferenceArray-lt-ReferenceEntry-lt-K-V-gt-gt-table"><a href="#AtomicReferenceArray-lt-ReferenceEntry-lt-K-V-gt-gt-table" class="headerlink" title="AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table;"></a>AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table;</h5><p>类似于HasmMap中的table一样，相当于entry的容器。</p>
<h5 id="ReferenceEntry-lt-K-V-gt-referenceEntry"><a href="#ReferenceEntry-lt-K-V-gt-referenceEntry" class="headerlink" title="ReferenceEntry&lt;K, V&gt; referenceEntry;"></a>ReferenceEntry&lt;K, V&gt; referenceEntry;</h5><p>基于引用的Entry,其实现类有弱引用Entry,强引用Entry等</p>
<h5 id="ReferenceQueue-keyReferenceQueue"><a href="#ReferenceQueue-keyReferenceQueue" class="headerlink" title="ReferenceQueue keyReferenceQueue;"></a>ReferenceQueue<k> keyReferenceQueue;</k></h5><p>已经被GC，需要内部清理的键引用队列。</p>
<h5 id="ReferenceQueue-valueReferenceQueue"><a href="#ReferenceQueue-valueReferenceQueue" class="headerlink" title="ReferenceQueue valueReferenceQueue;"></a>ReferenceQueue<v> valueReferenceQueue;</v></h5><p>已经被GC，需要内部清理的值引用队列。</p>
<h5 id="Queue-lt-ReferenceEntry-lt-K-V-gt-gt-recencyQueue"><a href="#Queue-lt-ReferenceEntry-lt-K-V-gt-gt-recencyQueue" class="headerlink" title="Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; recencyQueue;"></a>Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; recencyQueue;</h5><p>记录升级可访问列表清单时的entries,当segment上达到临界值或发生写操作时该队列会被清空。</p>
<h5 id="Queue-lt-ReferenceEntry-lt-K-V-gt-gt-writeQueue"><a href="#Queue-lt-ReferenceEntry-lt-K-V-gt-gt-writeQueue" class="headerlink" title="Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;"></a>Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;</h5><p>按照写入时间进行排序的元素队列，写入一个元素时会把它加入到队列尾部。</p>
<h5 id="Queue-lt-ReferenceEntry-lt-K-V-gt-gt-accessQueue"><a href="#Queue-lt-ReferenceEntry-lt-K-V-gt-gt-accessQueue" class="headerlink" title="Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;"></a>Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;</h5><p>按照访问时间进行排序的元素队列，访问(包括写入)一个元素时会把它加入到队列尾部。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><blockquote>
<p>public V put(K key, V value); //onlyIfAbsent为false<br> public V putIfAbsent(K key, V value); //onlyIfAbsent为true<br> 该方法显式往本地缓存里面插入值。从下面的流程图中可以看出，在执行每次put前都会进行preWriteCleanUP，在put返回前如果更新了entry则要进行evictEntries操作。</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/put.png" alt="img"></p>
<h3 id="preWriteCleanup"><a href="#preWriteCleanup" class="headerlink" title="preWriteCleanup"></a>preWriteCleanup</h3><blockquote>
<p>void preWriteCleanup(long now)；<br> 传人参数只有当前时间。<br> 键值引用队列中都是存储已经被GC，等待清除的entry信息，所以首先去处理这个里面的entry.<br> 读写队列里面是按照读写时间排序的，取出队列中的首元素，如果当前时间与该元素的时间相差值大于设定值，则进行回收。</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/preWriteCleanup.png" alt="img"></p>
<h2 id="evictEntries"><a href="#evictEntries" class="headerlink" title="evictEntries"></a>evictEntries</h2><p>void evictEntries(ReferenceEntry&lt;K, V&gt; newest)；<br> 传入的参数为最新的Entry，可能是刚插入的，也可能是刚更新过的。<br> 该方法只有在设置了在构建缓存的时候指定了maximumSize才会往下执行。首先清除recencyQueue，判断该元素自身的权重是否超过上限，如果超过则移除当前元素。然后判断总的权重是否大于上限，如果超过则去accessQueue里找到队首(即最不常访问的元素)进行移除，直到小于上限。</p>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/evictEntries.png" alt="img"></p>
<h2 id="getIfPresent"><a href="#getIfPresent" class="headerlink" title="getIfPresent"></a>getIfPresent</h2><blockquote>
<p>public V getIfPresent(Object key)；<br> 该方法从本地缓存中找值，如果找不到返回null，找到就返回相应的值。</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/getIfPresent.png" alt="img"></p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><blockquote>
<p>首先会在缓存中找，缓存中找不到再通过load加载。</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/get.png" alt="img"></p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><blockquote>
<p>public V remove(@Nullable Object key)；<br> 调用LocalManualCache的invalidate(Object key)方法即可调用remove.</p>
</blockquote>
<p><img src="/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/remove.png" alt="img"></p>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="https://bameirilyo.github.io/BameirilyoBlog">
            <img src="/BameirilyoBlog/img/avatar.jpg" alt="豆腐小铭">
            豆腐小铭
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/&title=《Google Guava Cache 全解析》 — Bameirilyo's Blog&pic=https://bameirilyo.github.io/BameirilyoBlog/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/&title=《Google Guava Cache 全解析》 — Bameirilyo's Blog&source=个人博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
<!--      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Google Guava Cache 全解析》 — Bameirilyo's Blog&url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/&via=https://bameirilyo.github.io/BameirilyoBlog" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>     -->
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/BameirilyoBlog/2018/07/18/数据库索引优化/" id="post-next" class="post-nav-link">
        <div class="tips">下一篇 <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">数据库索引优化</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


  
    </div>
    <div class="bottom">
	<!--  config.author  -->
        <p><span>个人专属 &copy; 2016 - 2018</span>
            <span>
                
                Power by —— Bameirilyo
			<!-- <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a> -->
            </span>
        </p>
		<p>
          
                <span><a href=" " target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
           
            <span>博客 —— 豆腐小铭</span>   
        </p> 
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/&title=《Google Guava Cache 全解析》 — Bameirilyo's Blog&pic=https://bameirilyo.github.io/BameirilyoBlog/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/&title=《Google Guava Cache 全解析》 — Bameirilyo's Blog&source=个人博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
<!--      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Google Guava Cache 全解析》 — Bameirilyo's Blog&url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/&via=https://bameirilyo.github.io/BameirilyoBlog" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://bameirilyo.github.io/BameirilyoBlog/2018/07/20/Google-Guava-Cache-全解析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>     -->
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuklEQVR42u3aQW4jMQwEQP//08llDws4Vpqk6PUCNSfDzmimdJCYph6P+Pp6uv7+/vlzMtr5rvOzLl94eHh441d/NfSrb55/fXVX9bnnSYnuxcPDw1vjTZbvV3/Tm4LJJoSHh4f3+bxknGQpzzcPPDw8vP+Rl8cH56fkhftbNwY8PDy8mJeEEflyX41iz1PzpqwFDw8Pr1a7NltW/+rzSn8PDw8Pb9xVnyy4hZL3GDr03vPPCHh4eHgLvGpEO29fncepsqP3xMPDw7vKm0QJ+ef8qNbde/Hw8PC2ebeOEeTFdw67EEbg4eHhXeXN44PJsYPqVlSYFDw8PLw1Xh7a9qKH3iGDfJN4uWHg4eHhrfFuHRrotfl7YUQyuXh4eHh7vGok0ds2zoBq2V3o7OHh4eGt8c5DJ837/G+S7aGKbzbA8PDw8Fq8HDMKVYsRQy8yxsPDw3sPLyH1mljVjaQa7I7OlOHh4eENeNWwNe8xVZF5OR4FKHh4eHhrvDwImLSsbh3SyiNjPDw8vA1eNYboHaXqLevVTeIXJB4eHt5VXvLq1aHzA1jVycp/xcPDw9vjVcPZauSax7KLwQceHh7eVqZaXqyrB6GqJXv11yiexsPDwxvzvo7X+TG9AjoPI6oRcPRIPDw8vDFv0i3KS+rmwanivVFhjYeHhzfmVYOA6oaRY5IlPpnuwqvj4eHhDXiT4KB6aGBS1pdjXDw8PLw1Xu+bfKGvbht50FDIpPHw8PDGvLulcLLo58X6hSYZHh4e3gKv1zOaDDefyrxMx8PDw9vj9Q4EVEvhZLTkc/LEHxpgeHh4eAu8XtNr3iQrtLJ6YQoeHh7ex/B6U1At0yfxLh4eHt7n8KpLfFIW944pRJEEHh4e3hovuTk/QFCdjkmr7Jd78fDw8BZ4k3/45+2rSfH9uHXh4eHhpbxvmDm7YDAIOQEAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/BameirilyoBlog/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'Bameirilyo's Blog';
            clearTimeout(titleTime);
        } else {
            document.title = 'Bameirilyo's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
