<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bameirilyo&#39;s Blog</title>
  
  <subtitle>纵有疾风起，人生不言弃</subtitle>
  <link href="/BameirilyoBlog/atom.xml" rel="self"/>
  
  <link href="https://bameirilyo.github.io/BameirilyoBlog/"/>
  <updated>2018-04-25T12:51:34.954Z</updated>
  <id>https://bameirilyo.github.io/BameirilyoBlog/</id>
  
  <author>
    <name>豆腐小铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目积累</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/25/%E9%A1%B9%E7%9B%AE%E7%A7%AF%E7%B4%AF/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/25/项目积累/</id>
    <published>2018-04-25T12:50:45.000Z</published>
    <updated>2018-04-25T12:51:34.954Z</updated>
    
    <content type="html"><![CDATA[<p>1.生产环境下，应对高并发一般都是本地缓存和网络缓存相结合。GuavaCache是本地缓存，redis是网络缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.生产环境下，应对高并发一般都是本地缓存和网络缓存相结合。GuavaCache是本地缓存，redis是网络缓存。&lt;/p&gt;

      
    
    </summary>
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/25/%E7%BD%91%E7%BB%9C/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/25/网络/</id>
    <published>2018-04-25T12:14:59.000Z</published>
    <updated>2018-04-25T12:18:52.193Z</updated>
    
    <content type="html"><![CDATA[<p>1.</p><p>PPP协议有两种认证方式，PAP(口令鉴别协议)方式和CHAP（口令握手鉴别协议）方式。PAP只需进行一次认证，并且只在链路初始状态时执行。而且用户名与密码的传送方式是明文的。CHAP采用周期性的验证，并且认证内容经过MD5加密后再传送，安全性要比PAP高。</p><p>2.</p><p> IEEE 802.3标准采用CSMA/CD，并用二进制指数退避和1-坚持算法</p><p>CSMA/CD采用二进制指数退避算法，又称为二元指数<a href="https://baike.baidu.com/item/%E5%90%8E%E9%80%80%E7%AE%97%E6%B3%95/6714023" target="_blank" rel="noopener">后退算法</a>。退避算法是以冲突窗口大小为基准的，每个节点有一个冲突计数器C。退避的时间与冲突次数具有指数关系，冲突次数越多，退避的时间就可能越长，若达到限定的冲突次数，该节点就停止发送数据。</p><p>3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">互联网采用的路由选择协议是动态的 </span><br><span class="line">RIP是基于距离向量的路由选择协议，RIP选择一个到目的网络具有最少路由器的路由（最短路由）。</span><br><span class="line">OSPF最主要特征是使用分布式链路状态协议，所有的路由器最终都能建立一个链路状态数据库（全网的拓扑结构图）。</span><br><span class="line">BGP-4采用路径向量路由选择协议。BGP所交换的网络可达性信息是要到达某个网络所要经过的自治系统序列。</span><br></pre></td></tr></table></figure><p>4.<img src="/BameirilyoBlog/2018/04/25/网络/OSI作用.png" alt="preview"></p><p>5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具有5个10M端口的集线器的总带宽可以达到(10M)</span><br></pre></td></tr></table></figure><p>集线器不管有多少个端口，所有端口都共享一条带宽，在同一时刻只能有两个端口传送数据，其他端口只能等待；只能工作在半双工模式下。交换机每个端口都有一条独占的带宽，当两个端口工作时并不影响其他端口的工作，交换机可以工作在半双工模式下也可以工作在全双工模式下。</p><p>6.</p><p>  某主机的  IP  地址为  180.80.77.55  ，子网掩码为  255.255.252.0  。若该主机向其所在子网发送广播分组，则目的地址可以是    180.80.79.255。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.子网掩码的第 3 个字节为 11111100 ，可知前 22 位为子网号、后 10 位为主机号。 IP 地址的第 3 个字节为 010011 01 （下划线为子网号的一部分），将主机号（即后 10 位）全置为 1 ，可以得到广播地址为 180.80.79.255 。</span><br><span class="line">2.把IP地址跟子网掩码取与（&amp;）得到网络地址：广播地址是网络地址的主机位全1 </span><br><span class="line">3. 广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机</span><br></pre></td></tr></table></figure><p>7.从组的使用范围来分，可以分为三种：全局组、本地域组和通用组。</p><p>8.</p><p>IEEE 802.3 ：以太网介质访问控制协议 （CSMA/CD）及物理层技术规范。<br> IEEE 802.5 ：令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。<br> IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。<br> IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。</p><p>9.传输介质</p><p>10BASE-2 细缆           </p><p>10BASE-5 粗缆           </p><p>10BASE-T 非屏蔽双绞线 </p><p>10BASE-FL 光纤          </p><p>10.</p><p>几种常用的<a href="https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91" target="_blank" rel="noopener">广域网</a>：<a href="https://baike.baidu.com/item/%E5%85%AC%E7%94%A8%E7%94%B5%E8%AF%9D%E4%BA%A4%E6%8D%A2%E7%BD%91" target="_blank" rel="noopener">公用电话交换网</a>（ PSTN）、分组交换网（X . 25）、<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BD%91" target="_blank" rel="noopener">数字数据网</a>（DDN）、<a href="https://baike.baidu.com/item/%E5%B8%A7%E4%B8%AD%E7%BB%A7" target="_blank" rel="noopener">帧中继</a>（FR）、<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%8D%A2%E5%BC%8F%E5%A4%9A%E5%85%86%E4%BD%8D%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">交换式多兆位数据服务</a>（SMDS）和<a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">异步传输模式</a>（ATM）。</p><p>11.</p><p>  要想连上Internet，至少需要四个条件：1.IP地址；2.子网掩码；3.gateway(网关)；4.DNS（域名服务器） </p><p>  而此题说的是设备，则肯定选择路由器，因为只有路由器才能完成网关这个条件，而网关本身并不是一种设备 </p><ol><li><p>套接字由什么构成 (IP地址与端口号 )</p></li><li><p>物理层的接口有哪几个方面的特性？各包含些什么内容？ </p><p>（1）机械特性:说明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。<br>（2）电气特性:指明在接口电缆的各条线上出现的电压的范围。 </p><p>（3）功能特性:指明某条线上出现的某一电平的电压表示何意。 </p><p>（4）规程特性:说明对于不同功能的各种可能事件的出现顺序。</p></li><li><p>交换机根据下列哪个地址来决定转发？（目标MAC地址</p></li><li><p>Ethernet采用的媒体访问控制方式是 （CSMA/CD</p></li><li><p>虚电路方法在传输数据前（）必须预先建立一条逻辑连接</p></li><li><p>255.0.0.0；255.255.0.0；255.255.255.0分别为A,B,C类地址的缺省子网掩码</p></li><li><p>​    局域网中的MAC层与OSI 参考模型（数据链路层） 相对应</p></li><li><p>DNS：域名解析 </p><p>FTP：文件传输 </p><p>www：信息查询 </p><p>ADSL：非对称数字用户线路，数据传输</p></li><li><p>​</p></li><li><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;PPP协议有两种认证方式，PAP(口令鉴别协议)方式和CHAP（口令握手鉴别协议）方式。PAP只需进行一次认证，并且只在链路初始状态时执行。而且用户名与密码的传送方式是明文的。CHAP采用周期性的验证，并且认证内容经过MD5加密后再传送，安全性要比PAP
      
    
    </summary>
    
      <category term="网络" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三个整数</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/20/%E4%B8%89%E4%B8%AA%E6%95%B4%E6%95%B0/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/20/三个整数/</id>
    <published>2018-04-20T02:59:36.000Z</published>
    <updated>2018-04-20T04:36:42.634Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><p>输入三个数x,y,z，经过若干次操作使三个数变成一样大</p><p>操作一：选择其中两个数加1；</p><p>操作二：选择其中一个数加2；</p><p>输出最少的操作次数</p><p>思路：</p><p>贪心，首先对三个数进行排序。从小到大为xyz， </p><p>  ①如果xy之间差距为偶数，通过对x＋2就使得xy相等，然后，对xy分别+1，使得xyz相等。 </p><p>  ②如果 xy之间为奇数，那么就通过对xy分别+1，使得y=z。此时如果x和Z之间差距为偶数，那么就对x加2，使得XYZ相等；如果x和Z之间差距为奇数，那么就x加2，使得X比zy都大1，然后对yz分别加1，使xyz相等 。 </p><p>  假设为2 5 8，那么由②可以变为  5 8 8，然后根据③，变化为 9 8 8，然后变化为 9 9 9。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> x = arr[<span class="number">0</span>], y = arr[<span class="number">1</span>], z = arr[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> ((y - x) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println((y - x) / <span class="number">2</span> + z - y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> sum1 = z - y;</span><br><span class="line">            <span class="keyword">int</span> sum2 = z - x - sum1;</span><br><span class="line">            <span class="keyword">if</span> (sum2 % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(sum1 + sum2 / <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(sum1 + sum2 / <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;输入三个数x,y,z，经过若干次操作使三个数变成一样大&lt;/p&gt;
&lt;p&gt;操作一：选择其中两个数加1；&lt;/p&gt;
&lt;p&gt;操作二：选择其中一个数加2；&lt;/p&gt;
&lt;p&gt;输出最少的操作次数&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;贪心，首先对三个数进行排序。从小到大为
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从一个字符串中找出字典序最大子序列</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/19/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%BE%E5%87%BA%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/19/从一个字符串中找出字典序最大子序列/</id>
    <published>2018-04-19T14:15:47.000Z</published>
    <updated>2018-04-20T02:59:02.071Z</updated>
    
    <content type="html"><![CDATA[<p>说明：</p><p>字典序最大(不是递增)，例如 tt&gt;t、sa&gt;s、xe&gt;xba</p><p>例：</p><p>字符串test的字典序最大子序列为tt</p><p>字符串abcde的字典序最大子序列为e</p><p><strong>思路：</strong></p><p>从后向前找，最后一个字符肯定包含在内，前面的字符大于后面的字符才能保证字典序最大；所以，从后往前找时，遇到比最后一个大的字符，留下当作倒数第二个字符，继续找到比倒数第二个字符大的当作第三个字符。。。。。。时间复杂度O(n)</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> id = <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=ch.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ch[i] &gt;= max) &#123;</span><br><span class="line">                    chars[--id] = ch[i];</span><br><span class="line">                    max = ch[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=id;i&lt;<span class="number">50</span>;i++) &#123;</span><br><span class="line">                System.out.print(chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;字典序最大(不是递增)，例如 tt&amp;gt;t、sa&amp;gt;s、xe&amp;gt;xba&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;字符串test的字典序最大子序列为tt&lt;/p&gt;
&lt;p&gt;字符串abcde的字典序最大子序列为e&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/s
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Deepin下使用IDEA完成项目过程中报错com.intellij.javaee.oss.admin.jmx.JmxAdminException</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/19/Deepin%E4%B8%8B%E4%BD%BF%E7%94%A8IDEA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%A5%E9%94%99com-intellij-javaee-oss-admin-jmx-JmxAdminException/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/19/Deepin下使用IDEA完成项目过程中报错com-intellij-javaee-oss-admin-jmx-JmxAdminException/</id>
    <published>2018-04-18T16:08:57.000Z</published>
    <updated>2018-04-19T10:50:15.830Z</updated>
    
    <content type="html"><![CDATA[<p>详细报错信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Artifact unnamed: Artifact is being deployed, please wait...</span><br><span class="line">Artifact unnamed: Error during artifact deployment. See server log for details.</span><br><span class="line">Artifact unnamed: com.intellij.javaee.oss.admin.jmx.JmxAdminException: com.intellij.execution.ExecutionException: /home/bameirilyo/IdeaProjects/mmall/out/artifacts/unnamed/unnamed.war not found for the web module.</span><br></pre></td></tr></table></figure><p>解决方法为：</p><p>1.点击idea右上角Project Structur按钮</p><p><img src="https://img-blog.csdn.net/20180418230153979?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JhbWVpcmlseW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.选择Modules</p><p><img src="https://img-blog.csdn.net/20180418230311238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JhbWVpcmlseW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>3.鼠标右键 +Add ，选择Web</p><p><img src="https://img-blog.csdn.net/20180418230404623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JhbWVpcmlseW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>4.Artifacts模块中点击“+”号，“Web Application：Exploded”中出现From Modules选择即可。</p><p><img src="https://img-blog.csdn.net/20180418230547749?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JhbWVpcmlseW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>可参考本人CSDN博客：<a href="https://blog.csdn.net/bameirilyo/article/details/79998409" target="_blank" rel="noopener">https://blog.csdn.net/bameirilyo/article/details/79998409</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;详细报错信息为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"/>
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Idea内初始化git</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/19/Idea%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96git/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/19/Idea内初始化git/</id>
    <published>2018-04-18T16:07:10.000Z</published>
    <updated>2018-04-19T10:51:42.862Z</updated>
    
    <content type="html"><![CDATA[<p>利用模板创建完最原始的web项目后就可以在idea内初始化git了，并使用idea的控制台控制git</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化git</span></span><br><span class="line">$ git init</span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment">#查看分支</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment">#增加所有文件</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment">#提交到本地仓库，双引号内为注释</span></span><br><span class="line">$ git commit -am <span class="string">"first commit init project"</span></span><br><span class="line"><span class="comment">#设置github中项目仓库的ssh地址</span></span><br><span class="line">$ git remote <span class="built_in">set</span>-url origin git@github.com:xxxx/xxxx.git</span><br><span class="line"><span class="comment">#将远程仓库中的内容pull到本地</span></span><br><span class="line">$ git pull</span><br><span class="line"><span class="comment">#推送到远程仓库（此步报错，原因为本地仓库内容落后于远程仓库）</span></span><br><span class="line">$ git push -u origin master</span><br><span class="line"><span class="comment">#强制推送到远程仓库（-f）</span></span><br><span class="line">$ git push -u -f origin master</span><br><span class="line"><span class="comment">#以master为基础新建并切换到该分支</span></span><br><span class="line">$ git checkout -b xxx origin/master</span><br><span class="line"><span class="comment">#将此分支推送到远程仓库</span></span><br><span class="line">$ git push origin HEAD -u</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用模板创建完最原始的web项目后就可以在idea内初始化git了，并使用idea的控制台控制git&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"/>
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识小集</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/17/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/17/网络基础知识小集/</id>
    <published>2018-04-17T09:01:48.000Z</published>
    <updated>2018-04-20T13:33:05.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http和https的区别"><a href="#Http和https的区别" class="headerlink" title="Http和https的区别"></a>Http和https的区别</h1><ul><li>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 </li><li>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。 </li><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。 </li></ul><ul><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 </li><li>http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 </li><li>http的连接很简单,是无状态的。 </li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全 </li></ul><h1 id="OSI分层-（7层）"><a href="#OSI分层-（7层）" class="headerlink" title="OSI分层 （7层）"></a>OSI分层 （7层）</h1><p>  <strong>TCP/IP分层（4层）</strong>：网络接口层、 网际层、运输层、 应用层。 </p><p>  <strong>五层协议     （5层）</strong>：物理层、数据链路层、网络层、运输层、 应用层。 </p><h2 id="每一层的协议如下："><a href="#每一层的协议如下：" class="headerlink" title="每一层的协议如下："></a>每一层的协议如下：</h2><p>  物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关） </p><p>  数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） </p><p>  网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP （路由器） </p><p>  传输层：TCP、UDP、SPX </p><p>  会话层：NFS、SQL、NETBIOS、RPC </p><p>  表示层：JPEG、MPEG、ASII </p><p>  应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS </p><h2 id="每一层的作用如下："><a href="#每一层的作用如下：" class="headerlink" title="每一层的作用如下："></a>每一层的作用如下：</h2><p>​    <strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特Bit）  </p><p>​    <strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧Frame）  </p><p>​    <strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包PackeT）  </p><p>​    <strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段Segment）  </p><p>​    <strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元SPDU）  </p><p>​    <strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）  </p><p>​    <strong>应用层</strong>：允许访问OSI环境的手段（应用协议数据单元APDU）  </p><h1 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h1><p>   A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；  </p><p>   B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；  </p><p>   C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；  </p><p>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）                                                                                                                                                                                      </p><p>​    <strong>IP地址与子网掩码相与得到主机号</strong>  </p><h1 id="ARP是地址解析协议，简单语言解释一下工作原理"><a href="#ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="ARP是地址解析协议，简单语言解释一下工作原理"></a>ARP是地址解析协议，简单语言解释一下工作原理</h1><p>​    1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。                              </p><p>​    2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：<strong>源主机IP地址，源主机MAC地址，目的主机的IP地址</strong>。                              </p><p>​    3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。                                                                                                              </p><p>​    4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。                                                        </p><p>   广播发送ARP请求，单播发送ARP响应。      </p><h1 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h1><p><strong>ICMP协议：</strong> 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。      </p><p><strong>TFTP协议：</strong>  是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。  </p><p><strong>HTTP协议：</strong> 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。  </p><p><strong>DHCP协议：</strong> 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。  </p><p><strong>NAT协议</strong>：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，  </p><p><strong>DHCP协议：</strong>一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。  </p><h1 id="描述：RARP"><a href="#描述：RARP" class="headerlink" title="描述：RARP"></a>描述：RARP</h1><p>   RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。                                                                                                              </p><h1 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h1><h2 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h2><p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 </p><p> 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 </p><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 </p><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。 </p><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 </p><p><img src="http://images0.cnblogs.com/blog2015/621032/201508/092017231747399.jpg" alt="img"></p><h1 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h1><p>1、客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a> </p><p>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 </p><p>3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 </p><p>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 </p><h1 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h1><h2 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h2><p>  （1） <strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong>端口。 </p><p>  （2） <strong>Telnet</strong>：一种用于远程登陆的端口，使用<strong>23</strong>端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 </p><p>  （3） <strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是<strong>25</strong>号端口。 </p><p>  （4） <strong>POP3</strong>：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是<strong>110</strong>端口。 </p><p>  （5）<strong>HTTP</strong>：是从Web服务器传输超文本到本地浏览器的传送协议。 </p><h2 id="UDP对应的协议："><a href="#UDP对应的协议：" class="headerlink" title="UDP对应的协议："></a>UDP对应的协议：</h2><p>  （1） <strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是<strong>53</strong>号端口。 </p><p>  （2） <strong>SNMP</strong>：简单网络管理协议，使用<strong>161</strong>号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 </p><p>  （3） <strong>TFTP</strong>(Trival File Tran敏感词er  Protocal)，简单文件传输协议，该协议在熟知端口<strong>69</strong>上使用UDP服务。 </p><h1 id="DNS域名系统，简单描述其工作原理。"><a href="#DNS域名系统，简单描述其工作原理。" class="headerlink" title="DNS域名系统，简单描述其工作原理。"></a>DNS域名系统，简单描述其工作原理。</h1><p>  当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。                                                                        </p><h1 id="面向连接和非面向连接的服务的特点是什么？"><a href="#面向连接和非面向连接的服务的特点是什么？" class="headerlink" title="面向连接和非面向连接的服务的特点是什么？"></a>面向连接和非面向连接的服务的特点是什么？</h1><p>  面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。 </p><p>  非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p><h1 id="端口及对应的服务？"><a href="#端口及对应的服务？" class="headerlink" title="端口及对应的服务？"></a>端口及对应的服务？</h1><table><thead><tr><th>服务</th><th>端口号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>FTP</td><td>21</td><td>SSH</td><td>22</td></tr><tr><td>telnet</td><td>23</td><td>SMTP</td><td>25</td></tr><tr><td>Domain(域名服务器)</td><td>53</td><td>HTTP</td><td>80</td></tr><tr><td>POP3</td><td>110</td><td>NTP（网络时间协议）</td><td>123</td></tr><tr><td>MySQL数据库服务</td><td>3306</td><td>Shell或 cmd</td><td>514</td></tr><tr><td>POP-2</td><td>109</td><td>SQL Server</td><td>1433</td></tr></tbody></table><h1 id="IP数据包的格式"><a href="#IP数据包的格式" class="headerlink" title="IP数据包的格式"></a>IP数据包的格式</h1><p>  IP数据报由<strong>首部</strong> 和<strong>数据</strong>两部分组成。首部由<strong>固定部分和可选部分</strong>组成。<strong>首部的固定部分有</strong>   <strong>20</strong>  <strong>字节</strong>。可选部分的长度变化范围为1——40字节。固定部分的字段：                    </p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:center">位数（bit）</th><th style="text-align:center">字段名</th><th style="text-align:center">位数</th></tr></thead><tbody><tr><td style="text-align:center">版本</td><td style="text-align:center">4  Ipv4</td><td style="text-align:center">首部长度</td><td style="text-align:center">4（表示的最大数为15个单位，一个单位表示4字节）</td></tr><tr><td style="text-align:center">服务类型</td><td style="text-align:center">8  以前很少用</td><td style="text-align:center">总长度</td><td style="text-align:center">16 （首部和数据部分的总长度，因此数据报的最大长度为65535字节，即64KB，但是由于链路层的MAC都有一定的最大传输单元，因此IP数据报的长度一般都不会有理论上的那么大，如果超出了MAC的最大单元就会进行分片）</td></tr><tr><td style="text-align:center">标识</td><td style="text-align:center">16（相同的标识使得分片后的数据报片能正确的重装成原来的数据报）</td><td style="text-align:center">标志</td><td style="text-align:center">3 （最低位MF=1表示后面还有分片，MF=0表示这是若干个数据报片的最后一个中间位DF=0才允许分片）</td></tr><tr><td style="text-align:center">片偏移</td><td style="text-align:center">片偏移指出较长的分组在分片后，某片在原分组中的相对位置，都是8字节的偏移位置</td><td style="text-align:center">生存时间</td><td style="text-align:center">数据报在网络中的生存时间，指最多经过路由器的跳数</td></tr><tr><td style="text-align:center">协议</td><td style="text-align:center">8（指出该数据报携带的数据是何种协议，以使得目的主机的IP层知道应将数据部分上交给哪个处理程序）如ICMP=1 IGMP=2 TCP=6 EGP=8 IGP=9 UDP=17 Ipv6=41 OSPF=89</td><td style="text-align:center">首部校验和</td><td style="text-align:center">这个部分只校验首部，不包括数据部分，计算方法：将首部划分为多个16位的部分，然后每个16位部分取反，然后计算和，再将和取反放到首部校验和。接收方收到后按同样的方法划分，取反，求和，在取反，如果结果为零，则接收，否则就丢弃</td></tr><tr><td style="text-align:center">源地址</td><td style="text-align:center">32</td><td style="text-align:center">目的地址</td><td style="text-align:center">32</td></tr></tbody></table><h1 id="TCP数据报的格式？"><a href="#TCP数据报的格式？" class="headerlink" title="TCP数据报的格式？"></a>TCP数据报的格式？</h1><p> 一个TCP报文段分为首部和数据两部分。首部由固定部分和选项部分组成，固定部分是20字节。TCP首部的最大长度为60。首部固定部分字段：            </p><table><thead><tr><th>字段名</th><th>字节（Byte）</th><th>字段名</th><th>字节（Byte）</th></tr></thead><tbody><tr><td>源端口</td><td>2</td><td>目的端口</td><td>2</td></tr><tr><td>序号</td><td>4</td><td>确认号</td><td>4，是期望收到对方的下一个报文段的数据的第一个字节的序号</td></tr><tr><td>数据偏移</td><td>4bit 指出TCP报文段的数据起始处距离TCP报文段的起始有多远</td><td>保留</td><td>6bit</td></tr><tr><td>紧急比特URG</td><td></td><td>确认比特ACK</td><td>只有当ACK=1时，确认号字段才有效</td></tr><tr><td>推送比特PSH</td><td></td><td>复位比特RST</td><td></td></tr><tr><td>同步比特SYN</td><td></td><td>终止比特FIN</td><td></td></tr><tr><td>窗口</td><td>2</td><td>检验和</td><td>2 （包括首部和数据两部分，同时还要加12字节的伪首部进行校验和计算）</td></tr><tr><td>选项</td><td>长度可变（范围1——40）</td><td></td></tr></tbody></table><h1 id="TCP的12字节伪首部："><a href="#TCP的12字节伪首部：" class="headerlink" title="TCP的12字节伪首部："></a>TCP的12字节伪首部：</h1><table><thead><tr><th>源IP地址（4）</th><th>目的IP地址（4）</th><th>0 (1)</th><th>6(1) 代表这是TCP，IP协议中提到过</th><th>TCP长度（2）</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="UDP数据报的格式？"><a href="#UDP数据报的格式？" class="headerlink" title="UDP数据报的格式？"></a>UDP数据报的格式？</h1><p>  用户数据报UDP由首部和数据部分组成。首部只有8个字节，由4个字段组成，每个字段都是两个字节。      </p><table><thead><tr><th>字段名</th><th>字节</th><th>字段名</th><th>字节</th></tr></thead><tbody><tr><td>源端口</td><td>2</td><td>目的端口</td><td>2</td></tr><tr><td>长度</td><td>2</td><td>检验和</td><td>2 （检验首部和数据，加12字节的伪首部）</td></tr></tbody></table><h1 id="UDP的12字节伪首部："><a href="#UDP的12字节伪首部：" class="headerlink" title="UDP的12字节伪首部："></a>UDP的12字节伪首部：</h1><table><thead><tr><th>源IP地址（4）</th><th>目的IP地址（4）</th><th>0 (1)</th><th>17(1) 代表这是UDP</th><th>UDP长度（2）</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="以太网MAC帧格式？"><a href="#以太网MAC帧格式？" class="headerlink" title="以太网MAC帧格式？"></a>以太网MAC帧格式？</h1><table><thead><tr><th>前导码</th><th>前定界符</th><th>目的地址</th><th>源目的地址</th><th>长度字段</th><th>数据字段</th><th>校验字段</th></tr></thead><tbody><tr><td>7B</td><td>1B</td><td>6B</td><td>6B</td><td>2B</td><td>46-1500</td><td>4B</td></tr></tbody></table><h1 id="了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="了解交换机、路由器、网关的概念，并知道各自的用途"></a>了解交换机、路由器、网关的概念，并知道各自的用途</h1><h2 id="1）交换机"><a href="#1）交换机" class="headerlink" title="1）交换机"></a>1）交换机</h2><p>​    在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背    部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部    交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表    中。  </p><p>​    交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张    ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不    能划分网络层广播，即广播域。  </p><p>   交换机被广泛应用于二层网络交换，俗称“二层交换机”。  </p><p>​    交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。  </p><h2 id="2）路由器"><a href="#2）路由器" class="headerlink" title="2）路由器"></a>2）路由器</h2><p>​    <strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过    的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转    送。路由工作在OSI模型的第三层——即网络层，例如网际协议。  </p><p>​    <strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。  </p><h2 id="3）网关"><a href="#3）网关" class="headerlink" title="3）网关"></a>3）网关</h2><p>​    <strong>网关</strong>（Gateway），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP    的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家    庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。  </p><p>​    在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能    转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系    统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关    （gateway）与路由器（router）还没有区别。  </p><p>​    在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。  </p><p>​    <strong>网关</strong>是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过<strong>网关</strong>还原成模拟的电话信号，最后才能在电话机上听到。  </p><p>​    对于以太网中的<strong>网关</strong>只能转发三层以上数据包，这一点和路由是一样的。而不同的是<strong>网关</strong>中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p><h1 id="交换机与路由器有什么区别？"><a href="#交换机与路由器有什么区别？" class="headerlink" title="交换机与路由器有什么区别？"></a>交换机与路由器有什么区别？</h1><p>①工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层</p><p>②寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址</p><p>③转发速不同：交换机的转发速度快，路由器转发速度相对较慢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http和https的区别&quot;&gt;&lt;a href=&quot;#Http和https的区别&quot; class=&quot;headerlink&quot; title=&quot;Http和https的区别&quot;&gt;&lt;/a&gt;Http和https的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;http是HTTP协议运行在TCP之上。
      
    
    </summary>
    
      <category term="网络" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>输出比当前数大的最近的4的倍数</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/17/%E8%BE%93%E5%87%BA%E6%AF%94%E5%BD%93%E5%89%8D%E6%95%B0%E5%A4%A7%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%844%E7%9A%84%E5%80%8D%E6%95%B0/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/17/输出比当前数大的最近的4的倍数/</id>
    <published>2018-04-17T05:12:23.000Z</published>
    <updated>2018-04-17T05:15:07.744Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><p>输入1.2.3.4中任意数则输出4；输入5.6.7.8中任意数则输出8；不使用语法关键字</p><p>解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((x-<span class="number">1</span>)/<span class="number">4</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;输入1.2.3.4中任意数则输出4；输入5.6.7.8中任意数则输出8；不使用语法关键字&lt;/p&gt;
&lt;p&gt;解法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="数学题" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Deepin下vsftpd虚拟用户配置</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/16/Deepin%E4%B8%8Bvsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/16/Deepin下vsftpd虚拟用户配置/</id>
    <published>2018-04-16T15:17:02.000Z</published>
    <updated>2018-04-20T09:11:56.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装vsftpd和db-util"><a href="#安装vsftpd和db-util" class="headerlink" title="安装vsftpd和db-util"></a>安装vsftpd和db-util</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install vsftpd</span><br><span class="line">sudo apt-get install db-util</span><br></pre></td></tr></table></figure><p>查看下vsftpd都安装了那些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L vsftpd |tac</span><br></pre></td></tr></table></figure><h1 id="建立本地虚拟用户"><a href="#建立本地虚拟用户" class="headerlink" title="建立本地虚拟用户"></a>建立本地虚拟用户</h1>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -d /home/vsftpd vsftpd      <span class="comment">#指定目录为/home/vsftpd</span></span><br><span class="line">sudo cat /etc/passwd |grep vsftpd          <span class="comment">#查看家目录</span></span><br></pre></td></tr></table></figure><p>注意：创建的用户vsftpd现在是无法登录到系统的，因为没有给该用户设置密码。在此，我们也无需让vsftpd登录到系统，这样相对来说比较安全。</p><p>用户创建完毕后，我们来创建对应的目录并修改其所属用户，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R vsftpd:vsftpd  /home/vsftpd/</span><br></pre></td></tr></table></figure><h1 id="建立虚拟用户数据库"><a href="#建立虚拟用户数据库" class="headerlink" title="建立虚拟用户数据库"></a>建立虚拟用户数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/vsftpd</span><br><span class="line">sudo vim /etc/vsftpd/login.txt</span><br></pre></td></tr></table></figure><p>将下面的内容填到login.txt文件内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">norco1</span><br><span class="line">norcoarm1</span><br><span class="line">norco2</span><br><span class="line">norcoarm2</span><br><span class="line">norco3</span><br><span class="line">norcoarm3</span><br></pre></td></tr></table></figure><p>注：login.txt为登录vsftpd的用户与密码文件。奇数行为用户名，偶数行为密码。<br>   。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用db_load对loginx.txt进行加密</span></span><br><span class="line">sudo db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/login.txt /etc/vsftpd/login.db</span><br><span class="line"><span class="comment">#修改权限（此步可不做，未发现问题）</span></span><br><span class="line">chmod 600 /etc/vsftpd/vsftpd_login.db</span><br></pre></td></tr></table></figure><p>生成数据库文件之后建议删除 loginuser.txt</p><h1 id="PAM验证配置"><a href="#PAM验证配置" class="headerlink" title="PAM验证配置"></a>PAM验证配置</h1><p>vsftpd的PAM验证，在此没有使用vsftpd安装时所生成的/etc/pam.d/vsftpd文件。</p><p>因为经过多次的测试，发现如果使用该文件进行验证的话，无法验证通过。猜想有可能是vsftpd的一个BUG。</p><p>创建验证文件，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pam.d/vsftpd.virtual</span><br><span class="line">auth required pam_userdb.so db=/etc/vsftpd/login</span><br><span class="line">account required pam_userdb.so db=/etc/vsftpd/login</span><br></pre></td></tr></table></figure><p>其中/etc/vsftpd/login对应/etc/vsftpd/login.db文件</p><h1 id="vsftp权限配置"><a href="#vsftp权限配置" class="headerlink" title="vsftp权限配置"></a>vsftp权限配置</h1><p>现在正式配置vsftpd，vsftpd的几乎所有配置项都在/etc/vsftpd.conf文件中进行。</p><p>先备份。</p><p>根据业务要求vsftpd.conf配置内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">xferlog_file=/var/<span class="built_in">log</span>/vsftpd.log</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=NO</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line">guest_enable=YES</span><br><span class="line">pam_service_name=vsftpd.virtual</span><br><span class="line">user_config_dir=/etc/vsftpd/vu</span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=30000</span><br><span class="line">pasv_max_port=31000</span><br></pre></td></tr></table></figure><p>在以上配置文件中，有几点需要重点指出。</p><p>local_enable=YES</p><p>write_enable=YES</p><p>local_umask=022</p><p>这两项是启用系统用户的写权限。特别是write_enable=YES项一定要启用，否则vsftpd虚拟用户将无法登录vsftpd。</p><p>为什么会是这样？因为虚拟用户依赖与系统用户。</p><p>chroot_local_user=YES</p><p>chroot_list_enable=NO</p><p>allow_writeable_chroot=YES</p><p>这三项是配置vsftpd用户禁止切换上级目录的权限。</p><p>guest_enable=YES</p><p>pam_service_name=vsftpd.virtual</p><p>user_config_dir=/etc/vsftpd/vu</p><p>这三项是启用vsftpd虚拟用以及虚拟用户账号配置目录。</p><p>pasv_enable=YES</p><p>pasv_min_port=30000</p><p>pasv_max_port=31000</p><p>这三项是启用vsftpd被动模式及相关端口。</p><h1 id="虚拟用户相关配置"><a href="#虚拟用户相关配置" class="headerlink" title="虚拟用户相关配置"></a>虚拟用户相关配置</h1><p>vsftpd配置文件修改文件后，现在开始配置虚拟用户的相关权限。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/vsftpd/vu</span><br><span class="line">sudo vim /etc/vsftpd/vu/ailanni</span><br><span class="line">guest_username=ftpilanni</span><br><span class="line">local_root=/www/</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">anon_umask=133</span><br></pre></td></tr></table></figure><p>以上配置参数，其中guest_username=ftpilanni表示的是设置FTP对应的系统用户为ftpilanni</p><p>local_root=/www/表示使用本地用户登录到ftp时的默认目录。</p><p>virtual_use_local_privs=YES虚拟用户和本地用户有相同的权限。</p><p>anon_umask表示文件上传的默认掩码。计算方式是777减去anon_umask就是上传文件的权限。在此我们设置的是133，也就是说上传后文件的权限是644。即上传的文件对所属用户来说只有读写权限，没有执行权限。</p><p><strong>若需配置多个用户时如下设置用户权限 </strong></p><p>在该文件夹下依次建立与login.txt对应的帐号名称相同的文件<br>内容可以参考下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim norco1</span></span><br><span class="line"><span class="comment">#[norco1]只允许下载</span></span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">local_root=/opt/ftp/norco1</span><br><span class="line"></span><br><span class="line"><span class="comment">#vim norco2    </span></span><br><span class="line"><span class="comment">#[norco2]允许建立，修改，但是不允许删除</span></span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">local_root=/opt/ftp/norco2</span><br><span class="line"></span><br><span class="line"><span class="comment">#vim norco3</span></span><br><span class="line"><span class="comment">#[norco3]全部权限</span></span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">local_root=/opt/ftp/norco3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装vsftpd和db-util&quot;&gt;&lt;a href=&quot;#安装vsftpd和db-util&quot; class=&quot;headerlink&quot; title=&quot;安装vsftpd和db-util&quot;&gt;&lt;/a&gt;安装vsftpd和db-util&lt;/h1&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"/>
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/15/线程池/</id>
    <published>2018-04-15T15:50:48.000Z</published>
    <updated>2018-04-15T15:51:37.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h1><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 </p><h1 id="设计一个动态大小的线程池，如何设计，应该有哪些方法-？"><a href="#设计一个动态大小的线程池，如何设计，应该有哪些方法-？" class="headerlink" title="设计一个动态大小的线程池，如何设计，应该有哪些方法 ？"></a>设计一个动态大小的线程池，如何设计，应该有哪些方法 ？</h1><ul><li>一个线程池包括以下四个基本组成部分： </li></ul><p><strong>线程管理器(ThreadPool)：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务； </strong></p><p><strong>工作线程(PoolWorker)：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； </strong></p><p><strong>任务接口(Task)：每个任务必须实现的接口，以供工作线程调度任务的执行。它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； </strong></p><p><strong>任务队列(TaskQueue)：用于存放没有处理的任务。提供一种缓冲机制； </strong></p><ul><li>所包含的方法 </li></ul><p>1.privateThreadPool()  创建线程池 </p><p>2.public static ThreadPoolgetThreadPool()  获得一个默认线程个数的线程池  </p><p>3.public voidexecute(Runnable task)  执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 </p><p>4.public voidexecute(Runnable[] task)  批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 </p><p>5.public void destroy()  销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁 </p><p>6.public intgetWorkThreadNumber() 返回工作线程的个数  </p><p>7.public intgetFinishedTasknumber() 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成 </p><p>8.public voidaddThread() 在保证线程池中所有线程正在执行，并且要执行线程的个数大于某一值时。增加线程池中线程的个数 </p><p>9.public voidreduceThread() 在保证线程池中有很大一部分线程处于空闲状态，并且空闲状态的线程在小于某一值时，减少线程池中线程的个数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是线程池？&quot;&gt;&lt;a href=&quot;#什么是线程池？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池？&quot;&gt;&lt;/a&gt;什么是线程池？&lt;/h1&gt;&lt;p&gt;线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java实现多线程的方式及三种方式的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/15/Java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/15/Java实现多线程的方式及三种方式的区别 - 副本/</id>
    <published>2018-04-15T07:38:02.000Z</published>
    <updated>2018-04-15T15:40:04.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现多线程的方式"><a href="#实现多线程的方式" class="headerlink" title="实现多线程的方式"></a>实现多线程的方式</h1><ul><li>继承Thread类，重写run函数。</li><li>实现Runnable接口 </li><li>使用ExecutorService、Callable、Future实现有返回结果的多线程</li></ul><h1 id="三种方式的区别"><a href="#三种方式的区别" class="headerlink" title="三种方式的区别"></a>三种方式的区别</h1><ul><li>实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。 </li><li>继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。 </li><li>实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现多线程的方式&quot;&gt;&lt;a href=&quot;#实现多线程的方式&quot; class=&quot;headerlink&quot; title=&quot;实现多线程的方式&quot;&gt;&lt;/a&gt;实现多线程的方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继承Thread类，重写run函数。&lt;/li&gt;
&lt;li&gt;实现Runnable接口
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识小集</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/14/Java基础知识小集/</id>
    <published>2018-04-14T14:05:13.000Z</published>
    <updated>2018-04-20T13:55:13.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="局部变量能否和成员变量重名？"><a href="#局部变量能否和成员变量重名？" class="headerlink" title="局部变量能否和成员变量重名？"></a>局部变量能否和成员变量重名？</h1><p>局部变量可以和成员变量重名，不加“this”修饰时，优先使用最近的变量。 </p><p>java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。在实例方法中出现变量名相同时，可以使用this关键字来调用。如果成员变量用static修饰了呢，也能用this调用吗？不能了，这个时候可以通过类名来调用，因为静态成员是属于类的。</p><p>  <img src="https://uploadfiles.nowcoder.net/images/20171104/631730_1509805462010_05AB09F792804DEE45454E55F8DB7F08" alt="img"> </p><h1 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h1><p>  面向过程<br> 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br> 缺点：没有面向对象易维护、易复用、易扩展<br> 面向对象<br> 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护<br> 缺点：性能比面向过程低 </p><h1 id="2-Java的四个基本特性（抽象、封装、继承，多态）"><a href="#2-Java的四个基本特性（抽象、封装、继承，多态）" class="headerlink" title="2.Java的四个基本特性（抽象、封装、继承，多态）"></a>2.Java的四个基本特性（抽象、封装、继承，多态）</h1><p>  抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。<br> 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。<br> 继承：是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于抽取多类事物的共性。<br> 多态：允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。 </p><h1 id="3-重载和重写的区别"><a href="#3-重载和重写的区别" class="headerlink" title="3.重载和重写的区别"></a>3.重载和重写的区别</h1><p>  重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。<br> 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。 </p><h1 id="4-构造器Constructor是否可被override"><a href="#4-构造器Constructor是否可被override" class="headerlink" title="4.构造器Constructor是否可被override"></a>4.构造器Constructor是否可被override</h1><p>构造器不能被重写，不能用static修饰构造器，只能用public、private、protected这三个权限修饰符，且不能有返回语句。 </p><h1 id="7-String和StringBuffer、StringBuilder的区别"><a href="#7-String和StringBuffer、StringBuilder的区别" class="headerlink" title="7.String和StringBuffer、StringBuilder的区别"></a>7.String和StringBuffer、StringBuilder的区别</h1><p>  可变性<br> String类中使用字符数组保存字符串，private<br> final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]<br> value，这两种对象都是可变的。<br> 线程安全性<br> String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。<br> 性能<br> 每次对String 类型进行改变的时候，都会生成一个新的String 对象，然后将指针指向新的String 对象。StringBuffer每次都会对<br> StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<br> StirngBuilder 相比使用<br> StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p><h1 id="8-hashCode和equals方法的关系"><a href="#8-hashCode和equals方法的关系" class="headerlink" title="8.hashCode和equals方法的关系"></a>8.hashCode和equals方法的关系</h1><p>  equals相等，hashcode必相等；hashcode相等，equals可能不相等。 </p><h1 id="9-抽象类和接口的区别"><a href="#9-抽象类和接口的区别" class="headerlink" title="9.抽象类和接口的区别"></a>9.抽象类和接口的区别</h1><p>  语法层次<br> 抽象类和接口分别给出了不同的语法定义。<br> 设计层次<br> 抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。<br> 跨域不同<br> 抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a”<br> 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，”like-a”的关系。 </p><h1 id="10-自动装箱与拆箱"><a href="#10-自动装箱与拆箱" class="headerlink" title="10.自动装箱与拆箱"></a>10.自动装箱与拆箱</h1><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><p> Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。 </p><h1 id="11-什么是泛型、为什么要使用以及泛型擦除"><a href="#11-什么是泛型、为什么要使用以及泛型擦除" class="headerlink" title="11.什么是泛型、为什么要使用以及泛型擦除"></a>11.什么是泛型、为什么要使用以及泛型擦除</h1><p>  泛型，即“参数化类型”。<br> 创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。<br> Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。<br> 类型擦除的主要过程如下：<br> 1）.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。<br> 2）.移除所有的类型参数。 </p><h1 id="12-Java中的集合类及关系图"><a href="#12-Java中的集合类及关系图" class="headerlink" title="12.Java中的集合类及关系图"></a>12.Java中的集合类及关系图</h1><p>  List和Set继承自Collection接口。<br> Set无序不允许元素重复。HashSet和TreeSet是两个主要的实现类。<br> List有序且允许元素重复。ArrayList、LinkedList和Vector是三个主要的实现类。<br> Map也属于集合系统，但和Collection接口没关系。Map是key对value的映射集合，其中key列就是一个集合。key不能重复，但是value可以重复。HashMap、TreeMap和Hashtable是三个主要的实现类。<br> SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序。 </p><h1 id="16-ArrayList和vector区别"><a href="#16-ArrayList和vector区别" class="headerlink" title="16.ArrayList和vector区别"></a>16.ArrayList和vector区别</h1><p>  ArrayList和Vector都实现了List接口，都是通过数组实现的。<br> Vector是线程安全的，而ArrayList是非线程安全的。<br> List第一次创建的时候，会有一个初始大小，随着不断向List中增加元素，当List 认为容量不够的时候就会进行扩容。Vector缺省情况下自动增长原来一倍的数组长度，ArrayList增长原来的50%。 </p><h1 id="17-ArrayList和LinkedList区别及使用场景"><a href="#17-ArrayList和LinkedList区别及使用场景" class="headerlink" title="17.ArrayList和LinkedList区别及使用场景"></a>17.ArrayList和LinkedList区别及使用场景</h1><p>  区别<br> ArrayList底层是用数组实现的，可以认为ArrayList是一个可改变大小的数组。随着越来越多的元素被添加到ArrayList中，其规模是动态增加的。<br> LinkedList底层是通过双向链表实现的， LinkedList和ArrayList相比，增删的速度较快。但是查询和修改值的速度较慢。同时，LinkedList还实现了Queue接口，所以他还提供了offer(),<br> peek(), poll()等方法。<br> 使用场景<br> LinkedList更适合从中间插入或者删除（链表的特性）。<br> ArrayList更适合检索和在末尾插入或删除（数组的特性）。 </p><h1 id="18-Collection和Collections的区别"><a href="#18-Collection和Collections的区别" class="headerlink" title="18.Collection和Collections的区别"></a>18.Collection和Collections的区别</h1><p>  java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。<br> java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 </p><h1 id="19-Concurrenthashmap实现原理"><a href="#19-Concurrenthashmap实现原理" class="headerlink" title="19.Concurrenthashmap实现原理"></a>19.Concurrenthashmap实现原理</h1><p>  具体原理参考文章：<br> <a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3948786.html</a><br> <a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">http://ifeve.com/concurrenthashmap/</a> </p><h1 id="20-Error、Exception区别"><a href="#20-Error、Exception区别" class="headerlink" title="20.Error、Exception区别"></a>20.Error、Exception区别</h1><p>  Error类和Exception类的父类都是throwable类，他们的区别是：<br> Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br> Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 </p><h1 id="21-Unchecked"><a href="#21-Unchecked" class="headerlink" title="21.Unchecked"></a>21.Unchecked</h1><p>  Exception和Checked Exception，各列举几个#<br> Unchecked Exception:<br> a. 指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复。<br> b. 包括Error与RuntimeException及其子类，如：OutOfMemoryError,<br> UndeclaredThrowableException, IllegalArgumentException,<br> IllegalMonitorStateException, NullPointerException, IllegalStateException,<br> IndexOutOfBoundsException等。<br> c. 语法上不需要声明抛出异常。 </p><p>  Checked Exception:<br> a. 代表程序不能直接控制的无效外界情况（如用户输入，数据库问题，网络异常，文件丢失等）<br> b. 除了Error和RuntimeException及其子类之外，如：ClassNotFoundException,<br> NamingException, ServletException, SQLException, IOException等。<br> c. 需要try catch处理或throws声明抛出异常。 </p><h1 id="22-Java中如何实现代理机制-JDK、CGLIB"><a href="#22-Java中如何实现代理机制-JDK、CGLIB" class="headerlink" title="22.Java中如何实现代理机制(JDK、CGLIB)"></a>22.Java中如何实现代理机制(JDK、CGLIB)</h1><p>  JDK动态代理：代理类和目标类实现了共同的接口，用到InvocationHandler接口。<br> CGLIB动态代理：代理类是目标类的子类，用到MethodInterceptor接口。 </p><h1 id="24-线程的状态转换"><a href="#24-线程的状态转换" class="headerlink" title="24.线程的状态转换"></a>24.线程的状态转换</h1><p><img src="http://upload-images.jianshu.io/upload_images/2616609-fbd1a3867266edba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h1 id="25-如何停止一个线程"><a href="#25-如何停止一个线程" class="headerlink" title="25.如何停止一个线程"></a>25.如何停止一个线程</h1><p>  参考文章：<br> <a href="http://www.cnblogs.com/greta/p/5624839.html" target="_blank" rel="noopener">http://www.cnblogs.com/greta/p/5624839.html</a> </p><h1 id="26-什么是线程安全"><a href="#26-什么是线程安全" class="headerlink" title="26.什么是线程安全"></a>26.什么是线程安全</h1><p>  线程安全就是多线程访问同一代码，不会产生不确定的结果。 </p><h1 id="27-如何保证线程安全"><a href="#27-如何保证线程安全" class="headerlink" title="27.如何保证线程安全"></a>27.如何保证线程安全</h1><p>  对非安全的代码进行加锁控制；<br> 使用线程安全的类；<br> 多线程并发情况下，线程共享的变量改为方法级的局部变量。 </p><h1 id="28-synchronized如何使用"><a href="#28-synchronized如何使用" class="headerlink" title="28.synchronized如何使用"></a>28.synchronized如何使用</h1><p>  synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：<br> 1). 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；<br> 2). 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br> 3). 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br> 4). 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 </p><h1 id="29-synchronized和Lock的区别"><a href="#29-synchronized和Lock的区别" class="headerlink" title="29.synchronized和Lock的区别"></a>29.synchronized和Lock的区别</h1><p>  主要相同点：Lock能完成synchronized所实现的所有功能<br> 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而synchronized是在JVM层面上实现的，synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。Lock锁的范围有局限性，块范围，而synchronized可以锁住块、对象、类。 </p><h1 id="30-多线程如何进行信息交互"><a href="#30-多线程如何进行信息交互" class="headerlink" title="30.多线程如何进行信息交互"></a>30.多线程如何进行信息交互</h1><p>void notify() 唤醒在此对象监视器上等待的单个线程。</p><p>void notifyAll() 唤醒在此对象监视器上等待的所有线程。<br>void wait() 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法。<br>void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。<br>void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 </p><h1 id="31-sleep和wait的区别-考察的方向是是否会释放锁"><a href="#31-sleep和wait的区别-考察的方向是是否会释放锁" class="headerlink" title="31.sleep和wait的区别(考察的方向是是否会释放锁)"></a>31.sleep和wait的区别(考察的方向是是否会释放锁)</h1><p>sleep()方法是Thread类中方法，而wait()方法是Object类中的方法。<br>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。 </p><h1 id="32-多线程与死锁"><a href="#32-多线程与死锁" class="headerlink" title="32.多线程与死锁"></a>32.多线程与死锁</h1><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br> 产生死锁的原因：<br> 一.因为系统资源不足。<br> 二.进程运行推进的顺序不合适。<br> 三.资源分配不当。 </p><h1 id="33-如何才能产生死锁"><a href="#33-如何才能产生死锁" class="headerlink" title="33.如何才能产生死锁"></a>33.如何才能产生死锁</h1><p>  产生死锁的四个必要条件：<br> 一.互斥条件：所谓互斥就是进程在某一时间内独占资源。<br> 二.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br> 三.不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。<br> 四.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 </p><h1 id="34-死锁的预防"><a href="#34-死锁的预防" class="headerlink" title="34.死锁的预防"></a>34.死锁的预防</h1><p>  打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。<br> 一.打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。<br> 二.打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。<br> 三.打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。<br> 四.打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。 </p><h1 id="35-什么叫守护线程，用什么方法实现守护线程"><a href="#35-什么叫守护线程，用什么方法实现守护线程" class="headerlink" title="35.什么叫守护线程，用什么方法实现守护线程"></a>35.什么叫守护线程，用什么方法实现守护线程</h1><p>  守护线程是为其他线程的运行提供服务的线程。<br> setDaemon(boolean on)方法可以方便的设置线程的Daemon模式，true为守护模式，false为用户模式。 </p><h1 id="36-Java线程池技术及原理"><a href="#36-Java线程池技术及原理" class="headerlink" title="36.Java线程池技术及原理"></a>36.Java线程池技术及原理</h1><p>  参考文章：<br> <a href="http://www.importnew.com/19011.html" target="_blank" rel="noopener">http://www.importnew.com/19011.html</a><br> <a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932921.html</a> </p><h1 id="37-java并发包concurrent及常用的类"><a href="#37-java并发包concurrent及常用的类" class="headerlink" title="37.java并发包concurrent及常用的类"></a>37.java并发包concurrent及常用的类</h1><p>  这个内容有点多，参考文章：<br> 并发包诸类概览：<a href="http://www.raychase.net/1912" target="_blank" rel="noopener">http://www.raychase.net/1912</a><br> 线程池：<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932921.html</a><br> 锁：<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3923167.html</a><br> 集合：<a href="http://www.cnblogs.com/huangfox/archive/2012/08/16/2642666.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangfox/archive/2012/08/16/2642666.html</a> </p><h1 id="38-volatile关键字"><a href="#38-volatile关键字" class="headerlink" title="38.volatile关键字"></a>38.volatile关键字</h1><p>  用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。<br> Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。</p><p>锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的，如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。Volatile变量具有synchronized的可见性特性，但是不具备原子特性。这就是说线程能够自动发现volatile变量的最新值。<br> 要使volatile变量提供理想的线程安全，必须同时满足下面两个条件：对变量的写操作不依赖于当前值；该变量没有包含在具有其他变量的不变式中。<br> 第一个条件的限制使volatile变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作需要使x 的值在操作期间保持不变，而volatile变量无法实现这点。<br> 每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。 </p><p>  <img src="http://upload-images.jianshu.io/upload_images/2616609-6e5cab5847787c18.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt="img"></p><p> read and load 从主存复制变量到当前工作内存<br> use and assign 执行代码，改变共享变量值<br> store and write 用工作内存数据刷新主存相关内容<br> 其中use and assign 可以多次出现，但是这一些操作并不是原子性，也就是在read load之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。 </p><h1 id="39-Java中的NIO，BIO，AIO分别是什么"><a href="#39-Java中的NIO，BIO，AIO分别是什么" class="headerlink" title="39.Java中的NIO，BIO，AIO分别是什么"></a>39.Java中的NIO，BIO，AIO分别是什么</h1><p>  BIO:同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br> NIO:同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br> AIO:异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 </p><h1 id="40-IO和NIO区别"><a href="#40-IO和NIO区别" class="headerlink" title="40.IO和NIO区别"></a>40.IO和NIO区别</h1><p>一.IO是面向流的，NIO是面向缓冲区的。<br>二.IO的各种流是阻塞的，NIO是非阻塞模式。<br>三.Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 </p><h1 id="41-序列化与反序列化"><a href="#41-序列化与反序列化" class="headerlink" title="41.序列化与反序列化"></a>41.序列化与反序列化</h1><p>  把对象转换为字节序列的过程称为对象的序列化。<br> 把字节序列恢复为对象的过程称为对象的反序列化。<br> 对象的序列化主要有两种用途：<br> 一.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；<br> 二.在网络上传送对象的字节序列。<br> 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 </p><h1 id="42-常见的序列化协议有哪些"><a href="#42-常见的序列化协议有哪些" class="headerlink" title="42.常见的序列化协议有哪些"></a>42.常见的序列化协议有哪些</h1><p>  Protobuf, Thrift, Hessian, Kryo </p><h1 id="43-内存溢出和内存泄漏的区别"><a href="#43-内存溢出和内存泄漏的区别" class="headerlink" title="43.内存溢出和内存泄漏的区别"></a>43.内存溢出和内存泄漏的区别</h1><p> 内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。<br> 内存泄漏是指分配出去的内存不再使用，但是无法回收。 </p><h1 id="44-Java内存模型及各个区域的OOM，如何重现OOM"><a href="#44-Java内存模型及各个区域的OOM，如何重现OOM" class="headerlink" title="44.Java内存模型及各个区域的OOM，如何重现OOM"></a>44.Java内存模型及各个区域的OOM，如何重现OOM</h1><p>  这部分内容很重要，详细阅读《深入理解Java虚拟机》，也可以详细阅读这篇文章<a href="http://hllvm.group.iteye.com/group/wiki/2857-JVM" target="_blank" rel="noopener">http://hllvm.group.iteye.com/group/wiki/2857-JVM</a> </p><h1 id="45-出现OOM如何解决"><a href="#45-出现OOM如何解决" class="headerlink" title="45.出现OOM如何解决"></a>45.出现OOM如何解决</h1><p>  一. 可通过命令定期抓取heap dump或者启动参数OOM时自动抓取heap dump文件。<br> 二. 通过对比多个heap dump，以及heap dump的内容，分析代码找出内存占用最多的地方。<br> 三. 分析占用的内存对象，是否是因为错误导致的内存未及时释放，或者数据过多导致的内存溢出。 </p><h1 id="46-用什么工具可以查出内存泄漏"><a href="#46-用什么工具可以查出内存泄漏" class="headerlink" title="46.用什么工具可以查出内存泄漏"></a>46.用什么工具可以查出内存泄漏</h1><p>  一. Memory<br> Analyzer－是一款开源的JAVA内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于Eclipse<br> RCP(Rich Client Platform)，可以下载RCP的独立版本或者Eclipse的插件。<br> 二. JProbe－分析Java的内存泄漏。<br> 三.JProfiler－一个全功能的Java剖析工具，专用于分析J2SE和J2EE应用程序。它把CPU、执行绪和内存的剖析组合在一个强大的应用中，GUI可以找到效能瓶颈、抓出内存泄漏、并解决执行绪的问题。<br> 四. JRockit－用来诊断Java内存泄漏并指出根本原因，专门针对Intel平台并得到优化，能在Intel硬件上获得最高的性能。<br> 五. YourKit-.NET &amp; Java Profiling业界领先的Java和.NET程序性能分析工具。<br> 六.AutomatedQA －AutomatedQA的获奖产品performance profiling和memory debugging工具集的下一代替换产品，支持Microsoft,Borland, Intel, Compaq 和 GNU编译器。可以为.NET和Windows程序生成全面细致的报告，从而帮助您轻松隔离并排除代码中含有的性能问题和内存/资源泄露问题。支持.Net 1.0,1.1,2.0,3.0和Windows 32/64位应用程序。<br> 七.Compuware DevPartner Java Edition－包含Java内存检测,代码覆盖率测试,代码性能测试,线程死锁,分布式应用等几大功能模块 </p><h1 id="47-Java内存管理及回收算法"><a href="#47-Java内存管理及回收算法" class="headerlink" title="47.Java内存管理及回收算法"></a>47.Java内存管理及回收算法</h1><p>  阅读这篇文章：<a href="http://www.cnblogs.com/hnrainll/archive/2013/11/06/3410042.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnrainll/archive/2013/11/06/3410042.html</a> </p><h1 id="48-Java类加载器及如何加载类-双亲委派"><a href="#48-Java类加载器及如何加载类-双亲委派" class="headerlink" title="48.Java类加载器及如何加载类(双亲委派)"></a>48.Java类加载器及如何加载类(双亲委派)</h1><p>  阅读文章：<br> <a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/（推荐）</a><br> <a href="http://blog.csdn.net/zhoudaxia/article/details/35824249" target="_blank" rel="noopener">http://blog.csdn.net/zhoudaxia/article/details/35824249</a> </p><h1 id="49-xml解析方式"><a href="#49-xml解析方式" class="headerlink" title="49.xml解析方式"></a>49.xml解析方式</h1><p>  一.DOM(JAXP Crimson解析器)<br> 二.SAX<br> 三.JDOM<br> 四.DOM4J<br> 区别：<br> 一.DOM4J性能最好，连Sun的JAXM也在用DOM4J。目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J.<br> 二.JDOM和DOM在性能测试时表现不佳，在测试10M<br> 文档时内存溢出。在小文档情况下还值得考虑使用DOM和JDOM。虽然JDOM的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM仍是一个非常好的选择。DOM实现广泛应用于多种编程语言。它还是许多其它与XML相关的标准的基础，因为它正式获得W3C<br> 推荐(与基于非标准的Java模型相对)，所以在某些类型的项目中可能也需要它(如在JavaScript中使用DOM)。<br> 三.SAX表现较好，这要依赖于它特定的解析方式－事件驱动。一个SAX检测即将到来的XML流，但并没有载入到内存(当然当XML流被读入时，会有部分文档暂时隐藏在内存中)。 </p><h1 id="50-Statement和PreparedStatement之间的区别"><a href="#50-Statement和PreparedStatement之间的区别" class="headerlink" title="50.Statement和PreparedStatement之间的区别"></a>50.Statement和PreparedStatement之间的区别</h1><p>  一.PreparedStatement是预编译的,对于批量处理可以大大提高效率. 也叫JDBC存储过程<br> 二.使用Statement 对象。在对数据库只执行一次性存取的时侯，用Statement 对象进行处理。PreparedStatement 对象的开销比Statement大，对于一次性操作并不会带来额外的好处。<br> 三.statement每次执行sql语句，相关数据库都要执行sql语句的编译，preparedstatement是预编译得,<br> preparedstatement支持批处理<br> 四.<br> 代码片段1:<br> String updateString = “UPDATE COFFEES SET SALES = 75 “ + “WHERE<br> COF_NAME LIKE ′Colombian′”;<br> stmt.executeUpdate(updateString);<br> 代码片段2:<br> PreparedStatement updateSales = con.prepareStatement(“UPDATE COFFEES SET<br> SALES = ? WHERE COF_NAME LIKE ? “);<br> updateSales.setInt(1, 75);<br> updateSales.setString(2, “Colombian”);<br> updateSales.executeUpdate();<br> 片断2和片断1的区别在于，后者使用了PreparedStatement对象，而前者是普通的Statement对象。PreparedStatement对象不仅包含了SQL语句，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需DBMS运行SQL语句，而不必先编译。当你需要执行Statement对象多次的时候，PreparedStatement对象将会大大降低运行时间，当然也加快了访问数据库的速度。<br> 这种转换也给你带来很大的便利，不必重复SQL语句的句法，而只需更改其中变量的值，便可重新执行SQL语句。选择PreparedStatement对象与否，在于相同句法的SQL语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。<br> 五.执行许多SQL语句的JDBC程序产生大量的Statement和PreparedStatement对象。通常认为PreparedStatement对象比Statement对象更有效,特别是如果带有不同参数的同一SQL语句被多次执行的时候。PreparedStatement对象允许数据库预编译SQL语句，这样在随后的运行中可以节省时间并增加代码的可读性。<br> 然而，在Oracle环境中，开发人员实际上有更大的灵活性。当使用Statement或PreparedStatement对象时，Oracle数据库会缓存SQL语句以便以后使用。在一些情况下,由于驱动器自身需要额外的处理和在Java应用程序和Oracle服务器间增加的网络活动，执行PreparedStatement对象实际上会花更长的时间。<br> 然而，除了缓冲的问题之外，至少还有一个更好的原因使我们在企业应用程序中更喜欢使用PreparedStatement对象,那就是安全性。传递给PreparedStatement对象的参数可以被强制进行类型转换，使开发人员可以确保在插入或查询数据时与底层的数据库格式匹配。<br> 当处理公共Web站点上的用户传来的数据的时候，安全性的问题就变得极为重要。传递给PreparedStatement的字符串参数会自动被驱动器忽略。最简单的情况下，这就意味着当你的程序试着将字符串“D’Angelo”插入到VARCHAR2中时，该语句将不会识别第一个“，”，从而导致悲惨的失败。几乎很少有必要创建你自己的字符串忽略代码。<br> 在Web环境中，有恶意的用户会利用那些设计不完善的、不能正确处理字符串的应用程序。特别是在公共Web站点上,在没有首先通过PreparedStatement对象处理的情况下，所有的用户输入都不应该传递给SQL语句。此外，在用户有机会修改SQL语句的地方，如HTML的隐藏区域或一个查询字符串上，SQL语句都不应该被显示出来。 </p><h1 id="51-servlet生命周期及各个方法"><a href="#51-servlet生命周期及各个方法" class="headerlink" title="51.servlet生命周期及各个方法"></a>51.servlet生命周期及各个方法</h1><p>  参考文章<a href="http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html" target="_blank" rel="noopener">http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html</a> </p><h1 id="52-servlet中如何自定义filter"><a href="#52-servlet中如何自定义filter" class="headerlink" title="52.servlet中如何自定义filter"></a>52.servlet中如何自定义filter</h1><p>  参考文章<a href="http://www.cnblogs.com/javawebsoa/archive/2013/07/31/3228858.html" target="_blank" rel="noopener">http://www.cnblogs.com/javawebsoa/archive/2013/07/31/3228858.html</a> </p><h1 id="53-JSP原理"><a href="#53-JSP原理" class="headerlink" title="53.JSP原理"></a>53.JSP原理</h1><p>  参考文章<a href="http://blog.csdn.net/hanxuemin12345/article/details/23831645" target="_blank" rel="noopener">http://blog.csdn.net/hanxuemin12345/article/details/23831645</a> </p><h1 id="54-JSP和Servlet的区别"><a href="#54-JSP和Servlet的区别" class="headerlink" title="54.JSP和Servlet的区别"></a>54.JSP和Servlet的区别</h1><p>  (1)JSP经编译后就变成了“类servlet”。<br> (2)JSP由HTML代码和JSP标签构成，更擅长页面显示；Servlet更擅长流程控制。<br> (3)JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。 </p><h1 id="55-JSP的动态include和静态include"><a href="#55-JSP的动态include和静态include" class="headerlink" title="55.JSP的动态include和静态include"></a>55.JSP的动态include和静态include</h1><p>  (1)动态include用jsp:include动作实现，如&lt;jsp:include page=”abc.jsp” flush=”true” /&gt;，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。会先解析所要包含的页面，解析后和主页面合并一起显示，即先编译后包含。<br> (2)静态include用include伪码实现，不会检查所含文件的变化，适用于包含静态页面，如&lt;%@<br> include file=”qq.htm” %&gt;，不会提前解析所要包含的页面，先把要显示的页面包含进来，然后统一编译，即先包含后编译。 </p><h1 id="56-Struts中请求处理过程"><a href="#56-Struts中请求处理过程" class="headerlink" title="56.Struts中请求处理过程"></a>56.Struts中请求处理过程</h1><p>  参考文章<a href="http://www.cnblogs.com/liuling/p/2013-8-10-01.html" target="_blank" rel="noopener">http://www.cnblogs.com/liuling/p/2013-8-10-01.html</a> </p><h1 id="57-MVC概念"><a href="#57-MVC概念" class="headerlink" title="57.MVC概念"></a>57.MVC概念</h1><p>  参考文章<a href="http://www.cnblogs.com/scwyh/articles/1436802.html" target="_blank" rel="noopener">http://www.cnblogs.com/scwyh/articles/1436802.html</a> </p><h1 id="58-Springmvc与Struts区别"><a href="#58-Springmvc与Struts区别" class="headerlink" title="58.Springmvc与Struts区别"></a>58.Springmvc与Struts区别</h1><p>  参考文章：<br> <a href="http://blog.csdn.net/tch918/article/details/38305395" target="_blank" rel="noopener">http://blog.csdn.net/tch918/article/details/38305395</a><br> <a href="http://blog.csdn.net/chenleixing/article/details/44570681" target="_blank" rel="noopener">http://blog.csdn.net/chenleixing/article/details/44570681</a> </p><h1 id="59-Hibernate-Ibatis两者的区别"><a href="#59-Hibernate-Ibatis两者的区别" class="headerlink" title="59.Hibernate/Ibatis两者的区别"></a>59.Hibernate/Ibatis两者的区别</h1><p>  参考文章<a href="http://blog.csdn.net/firejuly/article/details/8190229" target="_blank" rel="noopener">http://blog.csdn.net/firejuly/article/details/8190229</a> </p><h1 id="60-Hibernate一级和二级缓存"><a href="#60-Hibernate一级和二级缓存" class="headerlink" title="60.Hibernate一级和二级缓存"></a>60.Hibernate一级和二级缓存</h1><p>  参考文章<a href="http://blog.csdn.net/windrui/article/details/23165845" target="_blank" rel="noopener">http://blog.csdn.net/windrui/article/details/23165845</a> </p><h1 id="61-简述Hibernate常见优化策略"><a href="#61-简述Hibernate常见优化策略" class="headerlink" title="61.简述Hibernate常见优化策略"></a>61.简述Hibernate常见优化策略</h1><p>  参考文章<a href="http://blog.csdn.net/shimiso/article/details/8819114" target="_blank" rel="noopener">http://blog.csdn.net/shimiso/article/details/8819114</a> </p><h1 id="62-Springbean的加载过程-推荐看Spring的源码"><a href="#62-Springbean的加载过程-推荐看Spring的源码" class="headerlink" title="62.Springbean的加载过程(推荐看Spring的源码)"></a>62.Springbean的加载过程(推荐看Spring的源码)</h1><p>  参考文章<a href="http://geeekr.com/read-spring-source-1-how-to-load-bean/" target="_blank" rel="noopener">http://geeekr.com/read-spring-source-1-how-to-load-bean/</a> </p><h1 id="63-Springbean的实例化-推荐看Spring的源码"><a href="#63-Springbean的实例化-推荐看Spring的源码" class="headerlink" title="63.Springbean的实例化(推荐看Spring的源码)"></a>63.Springbean的实例化(推荐看Spring的源码)</h1><p>  参考文章<a href="http://geeekr.com/read-spring-source-two-beans-initialization/" target="_blank" rel="noopener">http://geeekr.com/read-spring-source-two-beans-initialization/</a> </p><h1 id="64-Spring如何实现AOP和IOC-推荐看Spring的源码"><a href="#64-Spring如何实现AOP和IOC-推荐看Spring的源码" class="headerlink" title="64.Spring如何实现AOP和IOC(推荐看Spring的源码)"></a>64.Spring如何实现AOP和IOC(推荐看Spring的源码)</h1><p>  参考文章<a href="http://www.360doc.com/content/15/0116/21/12385684_441408260.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/0116/21/12385684_441408260.shtml</a> </p><h1 id="65-Springbean注入方式"><a href="#65-Springbean注入方式" class="headerlink" title="65.Springbean注入方式"></a>65.Springbean注入方式</h1><p>  参考文章<a href="http://blessht.iteye.com/blog/1162131" target="_blank" rel="noopener">http://blessht.iteye.com/blog/1162131</a> </p><h1 id="66-Spring的事务管理"><a href="#66-Spring的事务管理" class="headerlink" title="66.Spring的事务管理"></a>66.Spring的事务管理</h1><p>  这个主题的参考文章没找到特别好的，<a href="http://blog.csdn.net/trigl/article/details/50968079%E8%BF%99%E4%B8%AA%E8%BF%98%E5%8F%AF%E4%BB%A5%E3%80%82" target="_blank" rel="noopener">http://blog.csdn.net/trigl/article/details/50968079这个还可以。</a> </p><h1 id="67-Spring事务的传播特性"><a href="#67-Spring事务的传播特性" class="headerlink" title="67.Spring事务的传播特性"></a>67.Spring事务的传播特性</h1><p>  参考文章<a href="http://blog.csdn.net/lfsf802/article/details/9417095" target="_blank" rel="noopener">http://blog.csdn.net/lfsf802/article/details/9417095</a> </p><h1 id="68-springmvc原理"><a href="#68-springmvc原理" class="headerlink" title="68.springmvc原理"></a>68.springmvc原理</h1><p>  参考文章<a href="http://blog.sina.com.cn/s/blog_7ef0a3fb0101po57.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7ef0a3fb0101po57.html</a> </p><h1 id="69-springmvc用过哪些注解"><a href="#69-springmvc用过哪些注解" class="headerlink" title="69.springmvc用过哪些注解"></a>69.springmvc用过哪些注解</h1><p>  参考文章<a href="http://aijuans.iteye.com/blog/2160141" target="_blank" rel="noopener">http://aijuans.iteye.com/blog/2160141</a> </p><h1 id="70-Restful有几种请求"><a href="#70-Restful有几种请求" class="headerlink" title="70.Restful有几种请求"></a>70.Restful有几种请求</h1><p>  参考文章，<a href="http://www.infoq.com/cn/articles/designing-restful-http-apps-roth%EF%BC%8C%E8%AF%A5%E7%AF%87%E5%86%99%E7%9A%84%E6%AF%94%E8%BE%83%E5%85%A8%E3%80%82" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/designing-restful-http-apps-roth，该篇写的比较全。</a> </p><h1 id="71-Restful好处"><a href="#71-Restful好处" class="headerlink" title="71.Restful好处"></a>71.Restful好处</h1><p>  (1)客户-服务器：客户-服务器约束背后的原则是分离关注点。通过分离用户接口和数据存储这两个关注点，改善了用户接口跨多个平台的可移植性；同时通过简化服务器组件，改善了系统的可伸缩性。<br> (2)无状态：通信在本质上是无状态的，改善了可见性、可靠性、可伸缩性.<br> (3)缓存：改善了网络效率减少一系列交互的平均延迟时间，来提高效率、可伸缩性和用户可觉察的性能。<br> (4)统一接口：REST架构风格区别于其他基于网络的架构风格的核心特征是，它强调组件之间要有一个统一的接口。 </p><h1 id="72-Tomcat，Apache，JBoss的区别"><a href="#72-Tomcat，Apache，JBoss的区别" class="headerlink" title="72.Tomcat，Apache，JBoss的区别"></a>72.Tomcat，Apache，JBoss的区别</h1><p>  Apache:HTTP服务器(WEB服务器)，类似IIS，可以用于建立虚拟站点，编译处理静态页面，可以支持SSL技术，支持多个虚拟主机等功能。<br> Tomcat:Servlet容器，用于解析jsp，Servlet的Servlet容器，是高效，轻量级的容器。缺点是不支持EJB，只能用于java应用。<br> Jboss:应用服务器，运行EJB的J2EE应用服务器，遵循J2EE规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA等，其对Servlet的支持是通过集成其他Servlet容器来实现的，如tomcat和jetty。 </p><h1 id="73-memcached和redis的区别"><a href="#73-memcached和redis的区别" class="headerlink" title="73.memcached和redis的区别"></a>73.memcached和redis的区别</h1><p>  (1)性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。<br> (2)内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。<br> (3)Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。 </p><h1 id="74-如何理解分布式锁"><a href="#74-如何理解分布式锁" class="headerlink" title="74.如何理解分布式锁"></a>74.如何理解分布式锁</h1><p>  参考文章：<br> <a href="http://blog.csdn.net/zheng0518/article/details/51607063" target="_blank" rel="noopener">http://blog.csdn.net/zheng0518/article/details/51607063</a><br> <a href="http://blog.csdn.net/nicewuranran/article/details/51730131%E3%80%82" target="_blank" rel="noopener">http://blog.csdn.net/nicewuranran/article/details/51730131。</a> </p><h1 id="75-你知道的开源协议有哪些"><a href="#75-你知道的开源协议有哪些" class="headerlink" title="75.你知道的开源协议有哪些"></a>75.你知道的开源协议有哪些</h1><p>  常见的开源协议有GPL、LGPL、BSD、Apache Licence<br> vesion 2.0、MIT，详细内容参考文章:<br> <a href="http://blog.jobbole.com/44175/%E3%80%81http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html%E3%80%82" target="_blank" rel="noopener">http://blog.jobbole.com/44175/、http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html。</a> </p><h1 id="76-json和xml区别"><a href="#76-json和xml区别" class="headerlink" title="76.json和xml区别"></a>76.json和xml区别</h1><p>  XML:<br> (1)应用广泛，可扩展性强，被广泛应用各种场合；<br> (2)读取、解析没有JSON快；<br> (3)可读性强，可描述复杂结构。<br> JSON:<br> (1)结构简单，都是键值对；<br> (2)读取、解析速度快，很多语言支持；<br> (3)传输数据量小，传输速率大大提高；<br> (4)描述复杂结构能力较弱。 </p><h1 id="77-设计模式"><a href="#77-设计模式" class="headerlink" title="77.设计模式"></a>77.设计模式</h1><p>  参考文章：<a href="http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445%E3%80%82" target="_blank" rel="noopener">http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445。</a> </p><h1 id="78-设计模式的六大原则"><a href="#78-设计模式的六大原则" class="headerlink" title="78.设计模式的六大原则"></a>78.设计模式的六大原则</h1><p>  参考文章<a href="http://www.uml.org.cn/sjms/201211023.asp%E3%80%82" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp。</a> </p><h1 id="79-用一个设计模式写一段代码或画出一个设计模式的UML"><a href="#79-用一个设计模式写一段代码或画出一个设计模式的UML" class="headerlink" title="79.用一个设计模式写一段代码或画出一个设计模式的UML"></a>79.用一个设计模式写一段代码或画出一个设计模式的UML</h1><p>  参考文章<a href="http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445" target="_blank" rel="noopener">http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445</a> </p><h1 id="80-高内聚，低耦合方面的理解"><a href="#80-高内聚，低耦合方面的理解" class="headerlink" title="80.高内聚，低耦合方面的理解"></a>80.高内聚，低耦合方面的理解</h1><p>  参考文章<a href="http://my.oschina.net/heweipo/blog/423235%E3%80%82" target="_blank" rel="noopener">http://my.oschina.net/heweipo/blog/423235。</a> </p><h1 id="81-深度优先和广度优先算法"><a href="#81-深度优先和广度优先算法" class="headerlink" title="81.深度优先和广度优先算法"></a>81.深度优先和广度优先算法</h1><p>  推荐看书籍复习！可参考文章：<br> <a href="http://blog.163.com/zhoumhan_0351/blog/static/3995422720098342257387/" target="_blank" rel="noopener">http://blog.163.com/zhoumhan_0351/blog/static/3995422720098342257387/</a><br> <a href="http://blog.163.com/zhoumhan_0351/blog/static/3995422720098711040303/" target="_blank" rel="noopener">http://blog.163.com/zhoumhan_0351/blog/static/3995422720098711040303/</a><br> <a href="http://blog.csdn.net/andyelvis/article/details/1728378" target="_blank" rel="noopener">http://blog.csdn.net/andyelvis/article/details/1728378</a><br> <a href="http://driftcloudy.iteye.com/blog/782873" target="_blank" rel="noopener">http://driftcloudy.iteye.com/blog/782873</a> </p><h1 id="82-排序算法及对应的时间复杂度和空间复杂度"><a href="#82-排序算法及对应的时间复杂度和空间复杂度" class="headerlink" title="82.排序算法及对应的时间复杂度和空间复杂度"></a>82.排序算法及对应的时间复杂度和空间复杂度</h1><p>  推荐看书籍复习！可参考文章：<br> <a href="http://www.cnblogs.com/liuling/p/2013-7-24-01.html" target="_blank" rel="noopener">http://www.cnblogs.com/liuling/p/2013-7-24-01.html</a><br> <a href="http://blog.csdn.net/cyuyanenen/article/details/51514443" target="_blank" rel="noopener">http://blog.csdn.net/cyuyanenen/article/details/51514443</a><br> <a href="http://blog.csdn.net/whuslei/article/details/6442755" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6442755</a> </p><h1 id="83-排序算法编码实现"><a href="#83-排序算法编码实现" class="headerlink" title="83.排序算法编码实现"></a>83.排序算法编码实现</h1><p>  参考<a href="http://www.cnblogs.com/liuling/p/2013-7-24-01.html" target="_blank" rel="noopener">http://www.cnblogs.com/liuling/p/2013-7-24-01.html</a> </p><h1 id="84-查找算法"><a href="#84-查找算法" class="headerlink" title="84.查找算法"></a>84.查找算法</h1><p>  参考<a href="http://sanwen8.cn/p/142Wbu5.html" target="_blank" rel="noopener">http://sanwen8.cn/p/142Wbu5.html</a> </p><h1 id="85-B-树"><a href="#85-B-树" class="headerlink" title="85.B+树"></a>85.B+树</h1><p>  参考<a href="http://www.cnblogs.com/syxchina/archive/2011/03/02/2197251.html" target="_blank" rel="noopener">http://www.cnblogs.com/syxchina/archive/2011/03/02/2197251.html</a> </p><h1 id="86-KMP算法"><a href="#86-KMP算法" class="headerlink" title="86.KMP算法"></a>86.KMP算法</h1><p>  推荐阅读数据复习！参考<a href="http://www.cnblogs.com/c-cloud/p/3224788.html" target="_blank" rel="noopener">http://www.cnblogs.com/c-cloud/p/3224788.html</a> </p><h1 id="87-hash算法及常用的hash算法"><a href="#87-hash算法及常用的hash算法" class="headerlink" title="87.hash算法及常用的hash算法"></a>87.hash算法及常用的hash算法</h1><p>  参考<a href="http://www.360doc.com/content/13/0409/14/10384031_277138819.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/13/0409/14/10384031_277138819.shtml</a> </p><h1 id="88-如何判断一个单链表是否有环"><a href="#88-如何判断一个单链表是否有环" class="headerlink" title="88.如何判断一个单链表是否有环"></a>88.如何判断一个单链表是否有环</h1><p>  参考文章：<br> <a href="http://www.jianshu.com/p/0e28d31600dd" target="_blank" rel="noopener">http://www.jianshu.com/p/0e28d31600dd</a><br> <a href="http://my.oschina.net/u/2391658/blog/693277?p=%7B%7BtotalPage%7D%7D" target="_blank" rel="noopener">http://my.oschina.net/u/2391658/blog/693277?p=</a> </p><h1 id="89-队列、栈、链表、树、堆、图"><a href="#89-队列、栈、链表、树、堆、图" class="headerlink" title="89.队列、栈、链表、树、堆、图"></a>89.队列、栈、链表、树、堆、图</h1><p>  推荐阅读数据复习！ </p><h1 id="90-linux常用命令"><a href="#90-linux常用命令" class="headerlink" title="90.linux常用命令"></a>90.linux常用命令</h1><p>  参考<a href="http://www.jianshu.com/p/03cfc1a721b8" target="_blank" rel="noopener">http://www.jianshu.com/p/03cfc1a721b8</a> </p><h1 id="91-如何查看内存使用情况"><a href="#91-如何查看内存使用情况" class="headerlink" title="91.如何查看内存使用情况"></a>91.如何查看内存使用情况</h1><p>  参考<a href="http://blog.csdn.net/windrui/article/details/40046413" target="_blank" rel="noopener">http://blog.csdn.net/windrui/article/details/40046413</a> </p><h1 id="92-Linux下如何进行进程调度"><a href="#92-Linux下如何进行进程调度" class="headerlink" title="92.Linux下如何进行进程调度"></a>92.Linux下如何进行进程调度</h1><p>  推荐阅读书籍复习，参考文章：<br> <a href="http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html</a><br> <a href="http://blog.csdn.net/rainharder/article/details/7975387" target="_blank" rel="noopener">http://blog.csdn.net/rainharder/article/details/7975387</a> </p><h1 id="93-产生死锁的必要条件"><a href="#93-产生死锁的必要条件" class="headerlink" title="93.产生死锁的必要条件"></a>93.产生死锁的必要条件</h1><p>  参考<a href="http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html</a> </p><h1 id="94-死锁预防"><a href="#94-死锁预防" class="headerlink" title="94.死锁预防"></a>94.死锁预防</h1><p>  参考<a href="http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html</a> </p><h1 id="95-数据库范式"><a href="#95-数据库范式" class="headerlink" title="95.数据库范式"></a>95.数据库范式</h1><p>  参考<a href="http://www.360doc.com/content/12/0712/20/5287961_223855037.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/12/0712/20/5287961_223855037.shtml</a> </p><h1 id="96-数据库事务隔离级别"><a href="#96-数据库事务隔离级别" class="headerlink" title="96.数据库事务隔离级别"></a>96.数据库事务隔离级别</h1><p>  参考<a href="http://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="noopener">http://blog.csdn.net/fg2006/article/details/6937413</a> </p><h1 id="97-数据库连接池的原理"><a href="#97-数据库连接池的原理" class="headerlink" title="97.数据库连接池的原理"></a>97.数据库连接池的原理</h1><p>  参考<a href="http://blog.csdn.net/shuaihj/article/details/14223015" target="_blank" rel="noopener">http://blog.csdn.net/shuaihj/article/details/14223015</a> </p><h1 id="98-乐观锁和悲观锁"><a href="#98-乐观锁和悲观锁" class="headerlink" title="98.乐观锁和悲观锁"></a>98.乐观锁和悲观锁</h1><p>  参考<a href="http://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1452046967245.html</a> </p><h1 id="99-如何实现不同数据库的数据查询分页"><a href="#99-如何实现不同数据库的数据查询分页" class="headerlink" title="99.如何实现不同数据库的数据查询分页"></a>99.如何实现不同数据库的数据查询分页</h1><p>  参考<a href="http://blog.csdn.net/yztezhl/article/details/20489387" target="_blank" rel="noopener">http://blog.csdn.net/yztezhl/article/details/20489387</a> </p><h1 id="100-SQL注入的原理，如何预防"><a href="#100-SQL注入的原理，如何预防" class="headerlink" title="100.SQL注入的原理，如何预防"></a>100.SQL注入的原理，如何预防</h1><p>  参考<a href="https://www.aliyun.com/zixun/content/3_15_245099.html" target="_blank" rel="noopener">https://www.aliyun.com/zixun/content/3_15_245099.html</a> </p><h1 id="101-数据库索引的实现-B-树介绍、和B树、R树区别"><a href="#101-数据库索引的实现-B-树介绍、和B树、R树区别" class="headerlink" title="101.数据库索引的实现(B+树介绍、和B树、R树区别)"></a>101.数据库索引的实现(B+树介绍、和B树、R树区别)</h1><p>  参考文章：<br> <a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="noopener">http://blog.csdn.net/kennyrose/article/details/7532032</a><br> <a href="http://www.xuebuyuan.com/2216918.html" target="_blank" rel="noopener">http://www.xuebuyuan.com/2216918.html</a> </p><h1 id="102-SQL性能优化"><a href="#102-SQL性能优化" class="headerlink" title="102.SQL性能优化"></a>102.SQL性能优化</h1><p>  参考文章：<br> <a href="http://database.51cto.com/art/200904/118526.htm" target="_blank" rel="noopener">http://database.51cto.com/art/200904/118526.htm</a><br> <a href="http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html" target="_blank" rel="noopener">http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html</a> </p><h1 id="103-数据库索引的优缺点以及什么时候数据库索引失效"><a href="#103-数据库索引的优缺点以及什么时候数据库索引失效" class="headerlink" title="103.数据库索引的优缺点以及什么时候数据库索引失效"></a>103.数据库索引的优缺点以及什么时候数据库索引失效</h1><p>  参考文章：<br> <a href="http://www.cnblogs.com/mxmbk/articles/5226344.html" target="_blank" rel="noopener">http://www.cnblogs.com/mxmbk/articles/5226344.html</a><br> <a href="http://www.cnblogs.com/simplefrog/archive/2012/07/15/2592527.html" target="_blank" rel="noopener">http://www.cnblogs.com/simplefrog/archive/2012/07/15/2592527.html</a><br> <a href="http://www.open-open.com/lib/view/open1418476492792.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1418476492792.html</a><br> <a href="http://blog.csdn.net/colin_liu2009/article/details/7301089" target="_blank" rel="noopener">http://blog.csdn.net/colin_liu2009/article/details/7301089</a><br> <a href="http://www.cnblogs.com/hongfei/archive/2012/10/20/2732589.html" target="_blank" rel="noopener">http://www.cnblogs.com/hongfei/archive/2012/10/20/2732589.html</a> </p><h1 id="104-Redis的数据类型"><a href="#104-Redis的数据类型" class="headerlink" title="104.Redis的数据类型"></a>104.Redis的数据类型</h1><p>  参考<a href="http://blog.csdn.net/hechurui/article/details/49508735" target="_blank" rel="noopener">http://blog.csdn.net/hechurui/article/details/49508735</a> </p><h1 id="105-OSI七层模型以及TCP-IP四层模型"><a href="#105-OSI七层模型以及TCP-IP四层模型" class="headerlink" title="105.OSI七层模型以及TCP/IP四层模型"></a>105.OSI七层模型以及TCP/IP四层模型</h1><p>  参考文章：<br> <a href="http://blog.csdn.net/sprintfwater/article/details/8751453" target="_blank" rel="noopener">http://blog.csdn.net/sprintfwater/article/details/8751453</a><br> <a href="http://www.cnblogs.com/commanderzhu/p/4821555.html" target="_blank" rel="noopener">http://www.cnblogs.com/commanderzhu/p/4821555.html</a><br> <a href="http://blog.csdn.net/superjunjin/article/details/7841099" target="_blank" rel="noopener">http://blog.csdn.net/superjunjin/article/details/7841099</a> </p><h1 id="106-HTTP和HTTPS区别"><a href="#106-HTTP和HTTPS区别" class="headerlink" title="106.HTTP和HTTPS区别"></a>106.HTTP和HTTPS区别</h1><p>  参考：<br> <a href="http://blog.csdn.net/mingli198611/article/details/8055261" target="_blank" rel="noopener">http://blog.csdn.net/mingli198611/article/details/8055261</a><br> <a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">http://www.mahaixiang.cn/internet/1233.html</a> </p><h1 id="107-HTTP报文内容"><a href="#107-HTTP报文内容" class="headerlink" title="107.HTTP报文内容"></a>107.HTTP报文内容</h1><p>  参考文章：<br> <a href="https://yq.aliyun.com/articles/44675" target="_blank" rel="noopener">https://yq.aliyun.com/articles/44675</a><br> <a href="http://www.cnblogs.com/klguang/p/4618526.html" target="_blank" rel="noopener">http://www.cnblogs.com/klguang/p/4618526.html</a><br> <a href="http://my.oschina.net/orgsky/blog/387759" target="_blank" rel="noopener">http://my.oschina.net/orgsky/blog/387759</a> </p><h1 id="108-get提交和post提交的区别"><a href="#108-get提交和post提交的区别" class="headerlink" title="108.get提交和post提交的区别"></a>108.get提交和post提交的区别</h1><p>  参考文章：<br> <a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html</a><br> <a href="http://www.jellythink.com/archives/806" target="_blank" rel="noopener">http://www.jellythink.com/archives/806</a> </p><h1 id="109-get提交是否有字节限制，如果有是在哪限制的"><a href="#109-get提交是否有字节限制，如果有是在哪限制的" class="headerlink" title="109.get提交是否有字节限制，如果有是在哪限制的"></a>109.get提交是否有字节限制，如果有是在哪限制的</h1><p>  参考<a href="http://www.jellythink.com/archives/806" target="_blank" rel="noopener">http://www.jellythink.com/archives/806</a> </p><h1 id="110-TCP的三次握手和四次挥手"><a href="#110-TCP的三次握手和四次挥手" class="headerlink" title="110.TCP的三次握手和四次挥手"></a>110.TCP的三次握手和四次挥手</h1><p>  阅读<a href="http://www.jianshu.com/p/f7d1010fa603" target="_blank" rel="noopener">http://www.jianshu.com/p/f7d1010fa603</a> </p><h1 id="111-session和cookie的区别"><a href="#111-session和cookie的区别" class="headerlink" title="111.session和cookie的区别"></a>111.session和cookie的区别</h1><p>  参考<a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="noopener">http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html</a> </p><h1 id="112-HTTP请求中Session实现原理"><a href="#112-HTTP请求中Session实现原理" class="headerlink" title="112.HTTP请求中Session实现原理"></a>112.HTTP请求中Session实现原理</h1><p>  参考<a href="http://blog.csdn.net/zhq426/article/details/2992488" target="_blank" rel="noopener">http://blog.csdn.net/zhq426/article/details/2992488</a> </p><h1 id="113-redirect与forward区别"><a href="#113-redirect与forward区别" class="headerlink" title="113.redirect与forward区别"></a>113.redirect与forward区别</h1><p>  参考<a href="http://www.cnblogs.com/wxgblogs/p/5602849.html" target="_blank" rel="noopener">http://www.cnblogs.com/wxgblogs/p/5602849.html</a> </p><h1 id="114-DDos攻击及预防"><a href="#114-DDos攻击及预防" class="headerlink" title="114.DDos攻击及预防"></a>114.DDos攻击及预防</h1><p>  参考文章：<br> <a href="http://blog.csdn.net/huwei2003/article/details/45476743" target="_blank" rel="noopener">http://blog.csdn.net/huwei2003/article/details/45476743</a><br> <a href="http://www.leiphone.com/news/201509/9zGlIDvLhwguqOtg.html" target="_blank" rel="noopener">http://www.leiphone.com/news/201509/9zGlIDvLhwguqOtg.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;局部变量能否和成员变量重名？&quot;&gt;&lt;a href=&quot;#局部变量能否和成员变量重名？&quot; class=&quot;headerlink&quot; title=&quot;局部变量能否和成员变量重名？&quot;&gt;&lt;/a&gt;局部变量能否和成员变量重名？&lt;/h1&gt;&lt;p&gt;局部变量可以和成员变量重名，不加“this”
      
    
    </summary>
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识小集</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/14/操作系统知识小集/</id>
    <published>2018-04-14T12:50:06.000Z</published>
    <updated>2018-04-25T12:34:29.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程状态变化"><a href="#进程状态变化" class="headerlink" title="进程状态变化"></a>进程状态变化</h1><p><img src="http://uploadfiles.nowcoder.net/images/20150920/458054_1442753187771_5CDBB527FAC51A534C0C85F7B4B46194" alt="img"></p><p>1.银行家算法：系统处于不安全状态可能会发生死锁，处于安全状态一定不会发生死锁</p><p>2.Windows操作系统中，文件组织采用树型目录结构。</p><p>3.在设备管理中，逻辑设备表（LUT）的作用是（在物理设备和逻辑设备之间建立对应关系）。</p><p>4.某个磁盘系统采用最短寻道时间优先（SSTF）磁盘调度算法，假设有一个请求柱面读写的磁盘请</p><p>  求队列如下：27、136、58、100、72、40，当前磁头位置是80 柱面。请问，磁盘总的移动距离为（）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 最短寻道时间优先（SSTF）磁盘调度算法，每次寻找最近的位置访问。</span><br><span class="line">(1)方向假设从磁盘内部向外部移动</span><br><span class="line">起始  80   移动距离（柱面）</span><br><span class="line">72              8</span><br><span class="line">58             14    </span><br><span class="line">40             18</span><br><span class="line">27             13</span><br><span class="line">100            73</span><br><span class="line">136            36</span><br><span class="line">磁盘总的移动距离：8+14+18+13+73+36=162</span><br><span class="line">可以直接80-27+136-27 = 162</span><br><span class="line"></span><br><span class="line">(2)方向假设从磁盘外部向内部移动</span><br><span class="line">起始  80   移动距离</span><br><span class="line">100           20</span><br><span class="line">136           36</span><br><span class="line">72            64</span><br><span class="line">58            14</span><br><span class="line">40            18</span><br><span class="line">27            13</span><br><span class="line">磁盘总的移动距离：20+36+64+14+18+13=165</span><br></pre></td></tr></table></figure><p>5.最短任务优先（SJF）调度算法可能会导致进程饿死（Starvation）</p><p>6.chmod   命令，改写文件的读写许可设置</p><p>语法为：  chmod abc file</p><p>其中  a,b,c  各为一个数字，分别表示  User, Group, Other  的权限</p><p>读r = 4, 写w = 2, 执行x = 1</p><p>7.若一个 程序或 子程序可以安全的被 并行执行，则称其为 可重入（ reentrant或re-entrant）的；即，当该子程序正在运行时，可以再次进入并执行它。若一个函数是可重入的，则该函数：  </p><p>不能含有 静态（全局）非常量数据。 不能返回静态（全局）非常量数据的地址。 只能处理由调用者提供的数据。 不能依赖于单实例模式资源的锁。 不能调用不可重入的函数。 多’用户/对象/进程 优先级’以及 多进程一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的资源。 </p><p>8.一个完整的计算机系统应包括___硬件系统和软件系统</p><p>9.多道程序技术即是指在内存中存放多道作业，运行结束或出错，自动调度内存中另一道作业运行。多道程序主要优点如下： </p><p>（1）资源利用率高。由于内存中装入了多道程序，使它们共享资源，保持系统资源处于忙碌状态，从而使各种资源得以充分利用。 </p><p>（2）系统吞吐量大。由于CPU和其它系统资源保持“忙碌”状态，而且仅当作业完成或运行不下去时才切换，系统开销小，所以吞吐量 </p><p>10.文件的保密是防止文件被（窃取）</p><p>11.实现进程之间同步与互斥的通信工具为（ P、V操作  ）。</p><p>12.进程的三个状态： </p><p>​      <strong>运行态</strong>：进程占有处理器运行</p><p>​      <strong>就绪态</strong>：进程具备运行条件等待处理器运行</p><p>​      <strong>等待态</strong>：进程由于等待资源、输入输出、信号等而不具备运行条件</p><p>  三种状态之间的转换： </p><p>​      <strong>运行态</strong>——&gt;<strong>等待态</strong>：等待资源、I/O、信号</p><p>​      <strong>等待态</strong>——&gt;<strong>就绪态</strong>：资源满足、I/O结束、信号完成 </p><p>​      <strong>就绪态</strong>——&gt;<strong>运行态</strong>：处理器空闲时选择更高优先权进程抢占 </p><p>​      <strong>运行态</strong>——&gt;<strong>就绪态</strong>：运行时间片到、有更高优先权进程 </p><p>13.用管程实现进程同步时，管程中的过程是不可中断的。<strong>管程中的过程是原语，是不能中断的。</strong></p><p>14.在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是（）。有上邻空闲区，也有下邻空闲区</p><p><img src="/BameirilyoBlog/2018/04/14/操作系统知识小集/空闲区数.png" alt="preview"></p><p>15.临界资源是指每次仅允许一个进程访问的资源。</p><p>属于临界资源的硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。 诸进程间应采取互斥方式，实现对这种资源的共享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程状态变化&quot;&gt;&lt;a href=&quot;#进程状态变化&quot; class=&quot;headerlink&quot; title=&quot;进程状态变化&quot;&gt;&lt;/a&gt;进程状态变化&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://uploadfiles.nowcoder.net/images/20150
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>找东西背后的概率问题</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/14/%E6%89%BE%E4%B8%9C%E8%A5%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/14/找东西背后的概率问题/</id>
    <published>2018-04-14T12:44:16.000Z</published>
    <updated>2018-04-14T12:46:45.814Z</updated>
    
    <content type="html"><![CDATA[<p>来自于《思考的乐趣-Matrix67数学笔记》第一部分第2节的一条小题</p><p><strong>题目：</strong></p><p>我的书桌有8个抽屉，分别用数字1到8编号。每次拿到一份文件后，我都会把这份文件随机的放在一个抽屉中。但是我非常粗心，有1/5的概率会忘了把文件放进抽屉里，最终把文件搞丢。<br>            现在我要找一份非常重要的文件。我将按顺序打开每一个抽屉，直到找到这份文件为止（或者很悲剧的发现，翻遍了所有抽屉都没能找到这份文件）。考虑下面三个问题。<br>(1) 假如我打开了第一个抽屉，发现里面没有我要的文件。这份文件在其余的7个抽屉里的概率是多少？<br>(2) 假如我翻遍了前4个抽屉，里面都没有我要的文件。这份文件在剩下的4个抽屉里的概率是多少？<br>(3) 假如我翻遍了前7个抽屉，里面都没有我要的文件。这份文件在最后一个抽屉里的概率是多少？</p><p>解：</p><p>M牛在书中给出的一个巧妙解法是这样的:</p><blockquote><p><strong>注意到，平均每10份文件就有两份被搞丢，其余8份平均地分给了8个抽屉。假如我把所有搞丢了的文件都找了回来，那么它们应该还占2个抽屉。这让我们想到了这样一个有趣的思路：在这8个抽屉后加上2个虚拟抽屉——抽屉9和抽屉10，这两个抽屉专门用来装我丢掉的文件。我们甚至可以把题目等价地变为：随机把文件放在10个抽屉里，但找文件时不允许打开最后2个抽屉。当我已经找过n个抽屉但仍没找到我想要的文件时，文件只能在剩下的10-n个抽屉里，但是我只能打开剩下的8-n个抽屉，因此所有的概率是(8 - n)/(10 - n)。当n分别等于1、4、7时，这个概率值分别是7/9、2/3和1/3。</strong></p></blockquote><p>从基本的解法中可发现，对于此题中的事件A、B，有P(A|B)恒等于1。因此，实际上当文件不在前n个抽屉中时，文件在后(抽屉总数-n)个抽屉中的概率就为(文件在后(抽屉总数 - n)个抽屉中的概率 除以 文件不在前n个抽屉中的概率)</p><p>考虑文件不在前n个抽屉中的概率，可得P(文件不在前n个抽屉中) = 1 - P(文件不丢失)·(n / 抽屉总数)</p><p>考虑文件在后(抽屉总数 - n)个抽屉中的概率，可得P(文件在后(抽屉总数 - n)个抽屉中) = P(文件不丢失)·(抽屉总数 - n) / 抽屉总数</p><p>则总体概率为P(B|A) = P(文件不丢失)·(抽屉总数 - n) / (抽屉总数 - P(文件不丢失)·n)</p><p>代入P(文件不丢失) = 4/5， 抽屉总数 = 8，可得</p><p>总体概率P = (4/5)·(8 - n) / (8 - 4·n / 5) = (8 - n) / (10 - n)</p><p>转载自网络</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来自于《思考的乐趣-Matrix67数学笔记》第一部分第2节的一条小题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的书桌有8个抽屉，分别用数字1到8编号。每次拿到一份文件后，我都会把这份文件随机的放在一个抽屉中。但是我非常粗心，有1/5的概率会
      
    
    </summary>
    
      <category term="数学题" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
    
      <category term="数学题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Deepin用终端查看已安装的软件列表及软件卸载</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/13/Deepin%E7%94%A8%E7%BB%88%E7%AB%AF%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/13/Deepin用终端查看已安装的软件列表及软件卸载/</id>
    <published>2018-04-13T05:04:56.000Z</published>
    <updated>2018-04-13T05:08:09.440Z</updated>
    
    <content type="html"><![CDATA[<ul><li>查看已经安装的软件包：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l</span><br></pre></td></tr></table></figure><ul><li>卸载命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge 软件包名称</span><br></pre></td></tr></table></figure><ul><li>用于清理下载文件的存档 ：</li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> clean</span><br></pre></td></tr></table></figure><ul><li>只清理过时的包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoclean</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;查看已经安装的软件包：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"/>
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java访问权限修饰词的作用域</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/12/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/12/Java访问权限修饰词的作用域/</id>
    <published>2018-04-12T14:46:16.000Z</published>
    <updated>2018-04-12T14:47:01.616Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">作用域（可见）</th><th style="text-align:center">当前类</th><th style="text-align:center">同包</th><th style="text-align:center">子孙类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">default(friendly)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用域（可见）&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;当前类&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;同包&lt;/th&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder以及对String不变性的理解</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/12/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%BB%A5%E5%8F%8A%E5%AF%B9String%E4%B8%8D%E5%8F%98%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/12/String、StringBuffer、StringBuilder以及对String不变性的理解/</id>
    <published>2018-04-12T14:40:27.000Z</published>
    <updated>2018-04-17T05:47:45.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><ul><li>都是 final 类, 都不允许被继承; </li><li>String 长度是不可变的,StringBuffer、StringBuilder 长度是可变的; </li><li>StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer在StringBuilder的方法之上添加了synchronized修饰，保证线程安全。 </li><li>StringBuilder比StringBuffer拥有更好的性能。 </li><li>如果一个String类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时String的速度比StringBuffer和StringBuilder的性能好的多。 </li></ul><h2 id="String不变性的理解"><a href="#String不变性的理解" class="headerlink" title="String不变性的理解"></a>String不变性的理解</h2><ul><li>String 类是被final进行修饰的，不能被继承。 </li><li>在用+号链接字符串的时候会创建新的字符串。 </li><li>String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有“Hello world”字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有“Hello world”对象，则堆上和静态区中都需要创建对象。 </li><li>在 java 中, 通过使用 “+” 符号来串联字符串的时候, 实际上底层会转成通过 StringBuilder 实例的 append() 方法来实现。 </li></ul><h2 id="String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？"><a href="#String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？" class="headerlink" title="String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？"></a>String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？</h2><p><strong>String有重写Object的hashcode和toString吗？</strong></p><p>String重写了Object类的hashcode和toString方法。 </p><p><strong>当equals方法被重写时，通常有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相对等的两个对象必须有相同的hashCode</strong></p><ul><li>object1.euqal(object2) 为true时，object1.hashCode() == object2.hashCode() 为true </li><li>object1.hashCode() ==  object2.hashCode() 为false时，object1.euqal(object2)必定为false </li><li>object1.hashCode() ==  object2.hashCode() 为true时，但object1.euqal(object2)不一定为true </li></ul><p><strong>重写equals不重写hashcode会出现什么问题</strong></p><p>在存储散列集合时(如Set类)，如果原对象.equals(新对象)，但没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写equals方法时，必须重写hashCode方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;String、StringBuffer、StringBuilder&quot;&gt;&lt;a href=&quot;#String、StringBuffer、StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;String、StringBuffer、String
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP与UDP、三次握手四次挥手</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/12/TCP%E4%B8%8EUDP%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/12/TCP与UDP、三次握手四次挥手/</id>
    <published>2018-04-12T14:37:51.000Z</published>
    <updated>2018-04-20T09:04:23.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li>TCP 提供面向连接、可靠的数据流传输，而UDP 提供的是非面向连接的、不可靠的数据流传输。</li><li>TCP 传输单位称为TCP 报文段，UDP 传输单位称为用户数据报。</li><li>TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</li></ul><ul><li>TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。</li><li>TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</li><li>TCP首部开销20字节；UDP的首部开销小，只有8个字节。</li><li>TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</li></ul><h1 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h1><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p><p>（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</p><p>（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</p><p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p><h1 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h1><p><img src="/BameirilyoBlog/2018/04/12/TCP与UDP、三次握手四次挥手/0.jpg" alt="preview"></p><p>TCP共有6个标志位，分别是：</p><ul><li>SYN(synchronous),建立联机。</li><li>ACK(acknowledgement),确认。</li><li>PSH(push),传输。</li><li>FIN(finish),结束。</li><li>RST(reset),重置。</li><li>URG(urgent),紧急。</li></ul><p>三次握手与四次挥手分别对应TCP连接建立过程与断开过程，先上TCP报文格式：</p><p><img src="/BameirilyoBlog/2018/04/12/TCP与UDP、三次握手四次挥手/1.png" alt="img"></p><h1 id="三次握手过程："><a href="#三次握手过程：" class="headerlink" title="三次握手过程："></a>三次握手过程：</h1><p><img src="/BameirilyoBlog/2018/04/12/TCP与UDP、三次握手四次挥手/3.png" alt="img"></p><h2 id="问题1：-为什么要三次握手？"><a href="#问题1：-为什么要三次握手？" class="headerlink" title="问题1： 为什么要三次握手？"></a>问题1： 为什么要三次握手？</h2><p>答案一：</p><p><strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 </strong></p><p>例子 ：</p><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” </p><p>答案二：</p><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收机能正常。</p><p>​        第一次握手：Client什么都不能确认；Server确认了对方发送正常</p><p>​        第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常</p><p>​        第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h2 id="问题2：为什么要发送特定的数据包，随便发不行吗？"><a href="#问题2：为什么要发送特定的数据包，随便发不行吗？" class="headerlink" title="问题2：为什么要发送特定的数据包，随便发不行吗？"></a>问题2：为什么要发送特定的数据包，随便发不行吗？</h2><p>答：三次握手的另外一个目的就是确认双方都支持TCP，告知对方用TCP传输。</p><p>​        第一次握手：Server 猜测Client可能要建立TCP请求，但不确定，因为也可能是Client乱发了一个数据包给自己</p><p>​        第二次握手：通过ack=J+1，Client知道Server是支持TCP的，且理解了自己要建立TCP连接的意图</p><p>​        第三次握手：通过ack=K+1，Server知道Client是支持TCP的，且确实是要建立TCP连接</p><h2 id="问题3：上图中的SYN和ACK是什么？"><a href="#问题3：上图中的SYN和ACK是什么？" class="headerlink" title="问题3：上图中的SYN和ACK是什么？"></a>问题3：上图中的SYN和ACK是什么？</h2><p>答：SYN是标志位，SYN=1表示请求连接；</p><p>​        ACK其实就是ack后面加上的那个数，真正发送的时候不单独发ACK，只发ack，下面四次挥手的图同理</p><h1 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h1><p><img src="/BameirilyoBlog/2018/04/12/TCP与UDP、三次握手四次挥手/4.png" alt="img"></p><p><strong>【注意】中断连接端可以是Client端，也可以是Server端。</strong></p><h2 id="问题1：-为什么要四次挥手？"><a href="#问题1：-为什么要四次挥手？" class="headerlink" title="问题1： 为什么要四次挥手？"></a>问题1： 为什么要四次挥手？</h2><p>答：根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。</p><p>​        举个例子：A和B打电话，通话即将结束后，A说“我没啥要说的了”，B回答“我知道了”，但是B可能还会有要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说“我说完了”，A回答“知道了”，这样通话才算结束。</p><h2 id="问题2：为什么双方要发送这样的数据包？"><a href="#问题2：为什么双方要发送这样的数据包？" class="headerlink" title="问题2：为什么双方要发送这样的数据包？"></a>问题2：为什么双方要发送这样的数据包？</h2><p>答：和握手的情况类似，只是为了让对方知晓自己理解了对方的意图。</p><h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a><strong>附加</strong></h2><h3 id="SYN网络攻击："><a href="#SYN网络攻击：" class="headerlink" title="SYN网络攻击："></a><strong>SYN网络攻击：</strong></h3><p>原理：<br>  在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open<br>connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p><p>检测：<br>SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。windows下打开cmd,输入命令：”netstat<br> -n -p TCP“，查看是否有大量的”SYN_RECEIVED“状态。</p><h1 id="关于tcp中time-wait状态的4个问题"><a href="#关于tcp中time-wait状态的4个问题" class="headerlink" title="关于tcp中time_wait状态的4个问题"></a>关于tcp中time_wait状态的4个问题</h1><p>time_wait是个常问的问题，tcp网络编程中最不容易理解的也是它的time_wait状态，这也说明了tcp/ip四次挥手中time_wait状态的重要性。 </p><p><strong>1.time_wait状态是什么</strong></p><p>简单来说：time_wait状态是四次挥手中服务器向客户端发送FIN终止连接后进入的状态。</p><p>  可以看到time_wait状态存在于客户端收到服务器Fin并返回ack包时的状态<br>  当处于time_wait状态时，我们无法创建新的连接，因为端口被占用。</p><h3 id="2-为什么会有time-wait状态"><a href="#2-为什么会有time-wait状态" class="headerlink" title="2.为什么会有time_wait状态"></a>2.为什么会有time_wait状态</h3><p>time_wait存在的原因有两点<br>  1.可靠的终止TCP连接。<br>  2.保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p><p>1.可靠的终止TCP连接，若处于time_wait的客户端发送给服务器确认报文段丢失的话，服务器将在此重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait而不是close状态。<br> 2.保证迟来的TCP报文段有足够的时间被识别并丢弃，linux中一个TCP端口不能打开两次或两次以上，当客户端处于time_wait状态时我们将无法使用此端口建立新连接，如果不存在time_wait状态，新连接可能会收到旧连接的数据。time_wait持续的时间是2MSL，保证旧的数据可以丢弃，因为网络中的数据最大存在MSL(maxinum segment lifetime)。</p><h3 id="3-哪一方会有time-wait状态"><a href="#3-哪一方会有time-wait状态" class="headerlink" title="3.哪一方会有time_wait状态"></a>3.哪一方会有time_wait状态</h3><p>time_wait状态是一般有客户端的状态。而且会占用端口<br>有时产生在服务器端，因为服务器主动断开连接或者发生异常</p><h3 id="4-如何避免time-wait状态占用资源"><a href="#4-如何避免time-wait状态占用资源" class="headerlink" title="4.如何避免time_wait状态占用资源"></a>4.如何避免time_wait状态占用资源</h3><p>如果是客户端，我们一般不用担心，因为客户端一般选用临时端口，再次创建连接会新分配一个端口。除非指定客户端使用某端口，不过一般不需要这么做。</p><p>如果是服务器主动关闭连接后异常终止，则因为它总是使用用一个知名服务器端口号，所以连接的time_wait状态将导致它不能重启，不过我们可以通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口。<br>通过socksetopt设置后，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用。</p><p>此外也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而是tcp连接根本不进入time_wait状态，进而允许应用程序立即重用本地的socket地址。</p><h1 id="close-wait状态出现的原因"><a href="#close-wait状态出现的原因" class="headerlink" title="close_wait状态出现的原因"></a>close_wait状态出现的原因</h1><p>某一方在网络连接断开后，对等方没有检测到这个错误（对方断开）而没有调用 closesocket，导致了这个状态的出现。</p><p>Server 程序处于CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做,导致没有发这个FIN packet。 </p><h1 id="为什么TCP连接需要三次握手，两次不可以吗，为什么"><a href="#为什么TCP连接需要三次握手，两次不可以吗，为什么" class="headerlink" title="为什么TCP连接需要三次握手，两次不可以吗，为什么"></a>为什么TCP连接需要三次握手，两次不可以吗，为什么</h1><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 </p><p>例子 ：</p><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” </p><p>转载自：<a href="https://blog.csdn.net/zixiaomuwu/article/details/60965466" target="_blank" rel="noopener">https://blog.csdn.net/zixiaomuwu/article/details/60965466</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;TCP 提供面向连接、可靠的数据流传输，而UDP 提供的是非面向连接的、不可靠的数据流传输。&lt;/li&gt;
&lt;li&gt;TCP 传输单位
      
    
    </summary>
    
      <category term="网络" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/11/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/11/查找算法/</id>
    <published>2018-04-11T11:14:34.000Z</published>
    <updated>2018-04-11T13:53:17.400Z</updated>
    
    <content type="html"><![CDATA[<p>目前查找方法主要：顺序查找、有序查找（分为：折半查找即二分查找、差值查找和斐波那契查找方法）、线性索引查找、二叉排序树、平衡二叉树（AVL树）以及多路查找树（B树）、散列表查找（哈希表）等查找方法</p><p>​     <strong>【1】顺序查找</strong>：是最简单的查找方法，其时间复杂度为O(n)，是通过构造一个线性表，采用遍历的方法，将记录与关键字一个一个的对比，若相等则查找成功，若全都不相等，则查找失败即记录不存在；</p><p>​     <strong>【2】有序查找</strong>：顺序表的记录一般是无序，而有序表的记录是有序的；使用有序表查找方法时，前提条件是待查找的记录必须是已经排好序的。 有序查找分为：<strong>二分查找、插值查找和斐波那契查找方法</strong></p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>算法思想：又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。时间复杂度为 O(logN)。</p><p>实现：</p><p> 1.非递归代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]==a)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;a)&#123;</span><br><span class="line">                lo=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo&lt;=hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a==array[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;array[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(array,a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(array,a,lo,mid-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>对二分法查找进行改进，将要查找的关键字key与查找表中的最大最小值记录进行比较后，再确定查找的范围。在二分法查找中，是以中间记录作为查找分区的，即将表一分为二，分为上下两个查找分区：</p><p><img src="https://img-blog.csdn.net/20160409181253212?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>而插值查找采用插值公式的方法，来确定查找分区。可简单这样理解，比如有100个数其值在0~1000范围之间从小到大排序，你要查找关键字为5的位置下标，若采用二分法，则大概在500的地方往下查找，但采用插值的方法，可以通过插值计算出5这个关键字应该在靠近0的地方，因此查找时从50往下开始查找，从而提高效率：</p><p><img src="https://img-blog.csdn.net/20160409181658604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>​      因此插值查找只需要在折半查找算法的代码中简单修改一下即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] num = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;<span class="comment">//必须有序</span></span><br><span class="line"><span class="keyword">int</span> index = Insert_Search(num, <span class="number">5</span>);</span><br><span class="line">System.out.print(index);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *num：有序表（由小到大排列） key：要查找的关键字 </span></span><br><span class="line"><span class="comment"> *return：还回查找到关键字的下标，没有找到则还回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Insert_Search</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low, high, mid;</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = num.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="comment">// mid = (low + high) / 2;//二分查找</span></span><br><span class="line">            mid = low + (high - low) * (key - num[low])/ (num[high] - num[low]);<span class="comment">//插值查找</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; num[mid])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; num[mid])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果等于则直接还回下标值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h1><p>​       斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。 </p><p>​      斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F<a href="如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素">n</a>，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 斐波那契数列 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] f = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契查找(黄金分割原理)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待查询数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 待查找关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回关键字在a数组中的下标，返回-1表示数组中不存在此关键字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonaciSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, mid, high, k;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 斐波那契数列下标</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取斐波那契分割值下标</span></span><br><span class="line">    <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>)</span><br><span class="line">        k++;</span><br><span class="line">    <span class="comment">// 利用Java工具类Arrays构造长度为f[k]的新数组并指向引用a</span></span><br><span class="line">    a = Arrays.copyOf(a, f[k]);</span><br><span class="line">    <span class="comment">// 对新数组后面多余的元素赋值最大的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; f[k]; i++) &#123;</span><br><span class="line">        a[i] = a[high];<span class="comment">//当key是是最大值时候，防止角标越界异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 前半部分有f[k-1]个元素，由于下标从0开始</span></span><br><span class="line">        <span class="comment">// 减去 1 获取 分割位置元素的下标</span></span><br><span class="line">        mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;<span class="comment">//关键字小于分割位置元素，则继续查找前半部分，高位指针移动</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// (全部元素) = (前半部分)+(后半部分)</span></span><br><span class="line">            <span class="comment">// f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">            <span class="comment">// 因为前半部分有f[k-1]个元素， 则继续拆分f[k-1] = f[k-2] + f[k-3]成立</span></span><br><span class="line">            <span class="comment">// 即在f[k-1]个元素的前半部分f[k-2]中继续查找，所以k = k - 1,</span></span><br><span class="line">            <span class="comment">// 则下次循环mid = low + f[k - 1 - 1] - 1;</span></span><br><span class="line">            k = k - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])&#123;<span class="comment">//关键字大于分割位置元素，则查找后半部分，低位指针移动</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// (全部元素) = (前半部分)+(后半部分)</span></span><br><span class="line">            <span class="comment">// f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">            <span class="comment">// 因为后半部分有f[k-2]个元素， 则继续拆分f[k-2] = f[k-3] + f[k-4]成立</span></span><br><span class="line">            <span class="comment">// 即在f[k-2]个元素的前半部分f[k-3]继续查找，所以k = k - 2,</span></span><br><span class="line">            <span class="comment">// 则下次循环mid = low + f[k - 2 - 1] - 1;</span></span><br><span class="line">            k = k - <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当条件成立的时候，则找到元素</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= high)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 出现这种情况是查找到补充的元素</span></span><br><span class="line">                <span class="comment">// 而补充的元素与high位置的元素一样</span></span><br><span class="line">                <span class="keyword">return</span> high;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前查找方法主要：顺序查找、有序查找（分为：折半查找即二分查找、差值查找和斐波那契查找方法）、线性索引查找、二叉排序树、平衡二叉树（AVL树）以及多路查找树（B树）、散列表查找（哈希表）等查找方法&lt;/p&gt;
&lt;p&gt;​     &lt;strong&gt;【1】顺序查找&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>E05_2数组B合并到A数组</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/10/E05-2%E6%95%B0%E7%BB%84B%E5%90%88%E5%B9%B6%E5%88%B0A%E6%95%B0%E7%BB%84/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/10/E05-2数组B合并到A数组/</id>
    <published>2018-04-10T14:49:46.000Z</published>
    <updated>2018-04-10T14:52:55.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="E05-2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。"><a href="#E05-2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。" class="headerlink" title="E05_2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。"></a>E05_2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。</h1><p>题目：</p><p>有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。</p><p>给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。</p><p>方法一：直接暴力解法，把B直接添加到A中，然后再排序，快排时间复杂度为nlog(n);</p><p>方法二：新建已个数组（这个题可以不需要建立数组），把A和B 的元素都添加到新数组中去，时间复杂度为O（M+N）;空间复杂度增加了O（M）；</p><p>方法三：在A的左边和B比较，然后将B插入到A中去，但是移动的次数过多，移动一次时间复杂度为O（M）,那么时间复杂就为O（M*N）;</p><p>方法四：先计算A和B的长度，由于数组的后面的元素是空的，所以可以从后面复杂数组元素。时间复杂度为O（M+N），空间复杂度为O（1）；</p><p>下列是解法：</p><p>把A看成有序的，然后把B中的数据插入到A中，再利用插入排序算法对A进行排序。<br>假设A = {1, 4, 5}，B = ｛2, 3｝<br>初始状态如下：<br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949425691_1.png" alt="img"><br>此时A[0 ~ 2]是有序的，利用插入排序向A中插入2，插入后如下图所示<br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949440458_2.png" alt="img"><br>A中的 4 和 5 向后移动了，接着向A[0 ~ 3]中插入3后<br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949452997_3.png" alt="img"><br>此时4 和 5又向后移动了。<br>再合并的时候，我们是从左向右合并的，结果造成了一些数据的多次移动，导致效率不理想。<br>如果考虑从右向左合并呢？<br>这时我们需要先断定合并后的从长度：k=lenA + lenB-1<br>令i=lenA-1, j=lenB-1<br>比较A[i]和B[j]，如果A[i]&gt;B[j]，A[k–]=A[i–];<br>如果A[i]&lt;B[j]，A[k–]=B[j–];<br>如此循环，直到 i&lt;0 或 j&lt;0<br>最后再判断j是否为0，不为0就继续A[k–]=B[j–]<br>按上面的流程执行，结果如下图所示<br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949247085_4.png" alt="img"><br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949261509_5.png" alt="img"><br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949276407_6.png" alt="img"><br><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438949299226_7.png" alt="img"><br>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeAB</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span> n,<span class="keyword">int</span>[] B,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=n-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> j=m-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> k=m+n-<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= B[j])&#123;</span><br><span class="line">            A[k--] = A[i--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[k--] = B[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        A[k--]=B[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;E05-2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。&quot;&gt;&lt;a href=&quot;#E05-2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。&quot; cl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>E04二维数组中的查找</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/10/E04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/10/E04二维数组中的查找/</id>
    <published>2018-04-10T14:44:17.000Z</published>
    <updated>2018-04-10T14:45:37.057Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong></p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = array.length;</span><br><span class="line">    <span class="keyword">int</span> columns = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = columns -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(array != <span class="keyword">null</span> &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; columns &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array [i][j] == target)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>E28对称的二叉树</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E28对称的二叉树/</id>
    <published>2018-04-09T13:52:17.000Z</published>
    <updated>2018-04-10T14:48:43.916Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目:</strong></p><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p><strong>思路：</strong></p><ul><li>首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同</li></ul><ul><li>左子树的右子树和右子树的左子树相同即可，采用递归</li><li>非递归也可，采用栈或队列存取各级子树根节点<br>​</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> comRoot(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">comRoot</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right==<span class="keyword">null</span>;<span class="comment">//此为"等于"的判断，不是赋值</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> comRoot(left.right, right.left) &amp;&amp; comRoot(left.left, right.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根节点以及其左右子树
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>E27二叉树的镜像</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E27二叉树的镜像/</id>
    <published>2018-04-09T13:32:59.000Z</published>
    <updated>2018-04-09T13:35:14.613Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><strong>思路：</strong></p><p>先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，<br>当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        TreeNode pTemp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = pTemp;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            Mirror(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，&lt;br&gt;当交换完所有的非叶
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>E26树的子结构</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E26树的子结构/</id>
    <published>2018-04-09T12:41:58.000Z</published>
    <updated>2018-04-09T12:46:26.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p><strong>思路：</strong></p><p>(1)在树A中找到和数B的根节点相同的节点；</p><p>   可以利用前序遍历A树中的节点，找到和B树的根节点相同的节点。</p><p>(2)在树A中找到和树B根节点相同的节点设为R；</p><p>   再对比节点R在树B中的左孩子和右孩子是否和树B中的节点相同。</p><p>   如果R节点的值和树B中的节点的值不同，则不是子结构，如果相同，递归去判断他们的各自的左孩子和右孩子是否相同。</p><p>   递归的出口是到达树A或者树B的叶节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                result = doesTree1HaveTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                result = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                result = HasSubtree(root1.right,root2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree2</span><span class="params">(TreeNode node1, TreeNode node2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1.val != node2.val) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">        <span class="keyword">return</span> doesTree1HaveTree2(node1.left,node2.left) &amp;&amp;</span><br><span class="line">            doesTree1HaveTree2(node1.right,node2.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)在树A中找到和数B的根节点相同的节点；&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>E08二叉树的下一个结点</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E08二叉树的下一个结点/</id>
    <published>2018-04-09T11:32:59.000Z</published>
    <updated>2018-04-09T11:38:53.661Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123; <span class="comment">//如果有右子树，则找右子树的最左节点</span></span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span>(node.left!=<span class="keyword">null</span>) node = node.left;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//没右子树，则找第一个当前节点是父节点左孩子的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.next.left==node) <span class="keyword">return</span> node.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//退到了根节点仍没找到，则返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>E07重建二叉树</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/E07重建二叉树/</id>
    <published>2018-04-09T08:25:27.000Z</published>
    <updated>2018-04-09T08:40:01.570Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>思路：</strong></p><p>根据先序遍历数组，可以得到树的根节点，根据得到的根节点，去中序数组中找到相应的根节点，因为中序的遍历顺序是左–根–右，可以得到根节点的左子树和右子树的中序遍历数组，这样树的左子树中节点的个数和右子树上节点的个数就确定了。在先序数组中，左子树的先序和左子树的先序也可以确定了。</p><p><strong>参数：</strong></p><p>先序遍历数组，子树在先序数组中的开始位置，结束位置。</p><p>中序遍历数组，子树在中序数组中的开始位置，结束位置。</p><p>可以根据先序和中序数组得到子树的先序和中序数组，所以此问题可以用递归解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in ==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root=reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="keyword">int</span>[] in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(startPre &gt; endPre || startIn &gt; endIn)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn;i &lt;= endIn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[startPre])&#123;</span><br><span class="line">            root.left=reConstructBinaryTree(pre,startPre+<span class="number">1</span>,startPre+i-startIn,</span><br><span class="line">                                            in,startIn,i-<span class="number">1</span>);</span><br><span class="line">            root.right=reConstructBinaryTree(pre,i-startIn+startPre+<span class="number">1</span>,endPre, </span><br><span class="line">                                             in,i+<span class="number">1</span>,endIn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/09/二叉树的遍历/</id>
    <published>2018-04-09T08:05:11.000Z</published>
    <updated>2018-04-09T08:24:46.287Z</updated>
    
    <content type="html"><![CDATA[<p>创建一棵树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;  </span><br><span class="line">    <span class="keyword">private</span> Node leftNode;  </span><br><span class="line">    <span class="keyword">private</span> Node rightNode;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, Node leftNode, Node rightNode)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">        <span class="keyword">this</span>.leftNode = leftNode;  </span><br><span class="line">        <span class="keyword">this</span>.rightNode = rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> leftNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(Node leftNode)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.leftNode = leftNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(Node rightNode)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.rightNode = rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历时先判断二叉树是否为空的情况</strong></p><p><strong>递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//二叉树的先序中序后序排序 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错</span></span><br><span class="line">        Node J = <span class="keyword">new</span> Node(<span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">        Node H = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node G = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node F = <span class="keyword">new</span> Node(<span class="number">7</span>, <span class="keyword">null</span>, J);</span><br><span class="line">        Node E = <span class="keyword">new</span> Node(<span class="number">5</span>, H, <span class="keyword">null</span>);</span><br><span class="line">        Node D = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">null</span>, G);</span><br><span class="line">        Node C = <span class="keyword">new</span> Node(<span class="number">9</span>, F, <span class="keyword">null</span>);</span><br><span class="line">        Node B = <span class="keyword">new</span> Node(<span class="number">3</span>, D, E); </span><br><span class="line">        Node A = <span class="keyword">new</span> Node(<span class="number">6</span>, B, C); </span><br><span class="line">        <span class="keyword">return</span> A;   <span class="comment">//返回根节点  </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node node)</span></span>&#123;<span class="comment">//打印  </span></span><br><span class="line">        System.out.print(node.getData());  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theFirstTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//先序遍历  </span></span><br><span class="line">        printNode(root);  </span><br><span class="line">        <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  <span class="comment">//使用递归进行遍历左孩子  </span></span><br><span class="line">            theFirstTraversal(root.getLeftNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  <span class="comment">//递归遍历右孩子  </span></span><br><span class="line">            theFirstTraversal(root.getRightNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theInOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//中序遍历  </span></span><br><span class="line">        <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            theInOrderTraversal(root.getLeftNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">        printNode(root);  </span><br><span class="line">        <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            theInOrderTraversal(root.getRightNode());  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thePostOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//后序遍历  </span></span><br><span class="line">        <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            thePostOrderTraversal(root.getLeftNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(root.getRightNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            thePostOrderTraversal(root.getRightNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">        printNode(root);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BinaryTree tree = <span class="keyword">new</span> BinaryTree();  </span><br><span class="line">        Node root = tree.init();  </span><br><span class="line">        System.out.println(<span class="string">"先序遍历"</span>);  </span><br><span class="line">        tree.theFirstTraversal(root);  </span><br><span class="line">        System.out.println(<span class="string">""</span>);  </span><br><span class="line">        System.out.println(<span class="string">"中序遍历"</span>);  </span><br><span class="line">        tree.theInOrderTraversal(root);  </span><br><span class="line">        System.out.println(<span class="string">""</span>);  </span><br><span class="line">        System.out.println(<span class="string">"后序遍历"</span>);  </span><br><span class="line">        tree.thePostOrderTraversal(root);  </span><br><span class="line">        System.out.println(<span class="string">""</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree1</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Node <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错  </span></span><br><span class="line">            Node J = <span class="keyword">new</span> Node(<span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            Node H = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            Node G = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            Node F = <span class="keyword">new</span> Node(<span class="number">7</span>, <span class="keyword">null</span>, J);  </span><br><span class="line">            Node E = <span class="keyword">new</span> Node(<span class="number">5</span>, H, <span class="keyword">null</span>);  </span><br><span class="line">            Node D = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">null</span>, G);  </span><br><span class="line">            Node C = <span class="keyword">new</span> Node(<span class="number">9</span>, F, <span class="keyword">null</span>);  </span><br><span class="line">            Node B = <span class="keyword">new</span> Node(<span class="number">3</span>, D, E);  </span><br><span class="line">            Node A = <span class="keyword">new</span> Node(<span class="number">6</span>, B, C);  </span><br><span class="line">            <span class="keyword">return</span> A;   <span class="comment">//返回根节点  </span></span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node node)</span></span>&#123;  </span><br><span class="line">        System.out.print(node.getData());  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theFirstTraversal_Stack</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//先序遍历  </span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();  </span><br><span class="line">        Node node = root;  </span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;  <span class="comment">//将所有左孩子压栈  </span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;   <span class="comment">//压栈之前先访问  </span></span><br><span class="line">                printNode(node);  </span><br><span class="line">                stack.push(node);  </span><br><span class="line">                node = node.getLeftNode();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                node = stack.pop();  </span><br><span class="line">                node = node.getRightNode();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theInOrderTraversal_Stack</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//中序遍历  </span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();  </span><br><span class="line">        Node node = root;  </span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                stack.push(node);   <span class="comment">//直接压栈  </span></span><br><span class="line">                node = node.getLeftNode();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                node = stack.pop(); <span class="comment">//出栈并访问  </span></span><br><span class="line">                printNode(node); </span><br><span class="line">                node = node.getRightNode(); </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thePostOrderTraversal_Stack</span><span class="params">(Node root)</span> </span>&#123;   <span class="comment">//后序遍历  </span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();  </span><br><span class="line">        Stack&lt;Node&gt; output = <span class="keyword">new</span> Stack&lt;Node&gt;();<span class="comment">//构造一个中间栈来存储逆后序遍历的结果  </span></span><br><span class="line">        Node node = root;  </span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> || stack.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                output.push(node);  </span><br><span class="line">                stack.push(node);                 </span><br><span class="line">                node = node.getRightNode();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                node = stack.pop();               </span><br><span class="line">                node = node.getLeftNode();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(output.size());</span><br><span class="line">        <span class="keyword">while</span> (output.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            printNode(output.pop());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BinaryTree1 tree = <span class="keyword">new</span> BinaryTree1();  </span><br><span class="line">        Node root = tree.init();  </span><br><span class="line">        System.out.println(<span class="string">"先序遍历"</span>);  </span><br><span class="line">        tree.theFirstTraversal_Stack(root);  </span><br><span class="line">        System.out.println(<span class="string">""</span>);  </span><br><span class="line">        System.out.println(<span class="string">"中序遍历"</span>);  </span><br><span class="line">        tree.theInOrderTraversal_Stack(root);  </span><br><span class="line">        System.out.println(<span class="string">""</span>);  </span><br><span class="line">        System.out.println(<span class="string">"后序遍历"</span>);  </span><br><span class="line">        tree.thePostOrderTraversal_Stack(root);  </span><br><span class="line">        System.out.println(<span class="string">""</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建一棵树：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/%E6%A0%88/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/栈/</id>
    <published>2018-04-08T12:34:18.000Z</published>
    <updated>2018-04-08T13:03:40.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义：</strong></p><p>栈是一种只能在一端进行插入或删除操作的线性表。（先进后出表）</p><p><strong>java中的Stack继承Vector</strong></p><p><strong>实例化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure><p><strong>基本使用</strong></p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">boolean empty()                     测试堆栈是否为空。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">Object peek( )                          查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">Object pop( )                           移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">Object push(Object element)  把项压入堆栈顶部。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">int search(Object element)         返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack stack=<span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="comment">//1.empty()栈是否为空</span></span><br><span class="line">        System.out.println(stack.empty());</span><br><span class="line">        <span class="comment">//2.peek()栈顶值    </span></span><br><span class="line">        <span class="comment">//3.进栈push()</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        stack.push(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        <span class="comment">//4.pop()出栈</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        System.out.println(stack.empty());</span><br><span class="line">        <span class="comment">//5.search（）搜索位置</span></span><br><span class="line">        System.out.println(stack.search(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line">b</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈是一种只能在一端进行插入或删除操作的线性表。（先进后出表）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java中的Stack继承Vector&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例化&lt;/strong&gt;&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>E52两个链表的第一个公共节点</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E52两个链表的第一个公共节点/</id>
    <published>2018-04-08T11:47:10.000Z</published>
    <updated>2018-04-08T11:53:15.233Z</updated>
    
    <content type="html"><![CDATA[<p>思路：</p><p><strong>首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findFirstCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = getListLength(head1);</span><br><span class="line">    <span class="keyword">int</span> len2 = getListLength(head2);</span><br><span class="line">    ListNode longListNode = head1;</span><br><span class="line">    ListNode shortListNode = head2;</span><br><span class="line">    <span class="keyword">int</span> dif = len1 - len2;</span><br><span class="line">    <span class="keyword">if</span> (len2 &gt; len1) &#123;</span><br><span class="line">        longListNode = head2;</span><br><span class="line">        shortListNode = head1;</span><br><span class="line">        dif = len2 - len1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dif; i++) &#123;</span><br><span class="line">        longListNode = longListNode.nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (longListNode != <span class="keyword">null</span> &amp;&amp; shortListNode != <span class="keyword">null</span> </span><br><span class="line">           &amp;&amp; longListNode != shortListNode) &#123;</span><br><span class="line">        longListNode = longListNode.nextNode;</span><br><span class="line">        shortListNode = shortListNode.nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longListNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(ListNode head1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    ListNode point = head1;</span><br><span class="line">    <span class="keyword">while</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">        point = point.nextNode;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点&lt;/strong&gt;。&lt;/p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E18_2删除链表中重复的节点</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E18-2%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E18-2删除链表中重复的节点/</id>
    <published>2018-04-08T11:20:15.000Z</published>
    <updated>2018-04-08T11:23:47.561Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>在一个排序的链表中，如何删除重复的节点？ </p><p>样例输入： 1 2 3 3 4 4 5 </p><p>样例输出： 1 2 5</p><p>解法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123; <span class="comment">// 只有0个或1个结点，则返回</span></span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123; <span class="comment">// 当前结点是重复结点</span></span><br><span class="line">        ListNode pNode = pHead.next;</span><br><span class="line">        <span class="keyword">while</span> (pNode != <span class="keyword">null</span> &amp;&amp; pNode.val == pHead.val) &#123;</span><br><span class="line">            <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplication(pNode); <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前结点不是重复结点</span></span><br><span class="line">        pHead.next = deleteDuplication(pHead.next); <span class="comment">//保留当前结点，从下一个结点开始递归</span></span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    ListNode helper = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    helper.next = pHead;</span><br><span class="line">    ListNode prev = helper, curr = pHead, next = pHead.next;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(next.val != curr.val)&#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(next != <span class="keyword">null</span> &amp;&amp; next.val == curr.val)</span><br><span class="line">                next = next.next;</span><br><span class="line">            curr = prev.next = next;</span><br><span class="line">            <span class="keyword">if</span>(next != <span class="keyword">null</span>)</span><br><span class="line">                next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个排序的链表中，如何删除重复的节点？ &lt;/p&gt;
&lt;p&gt;样例输入： 1 2 3 3 4 4 5 &lt;/p&gt;
&lt;p&gt;样例输出： 1 2 5&lt;/p&gt;
&lt;p&gt;解法一：&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E18_1删除链表的节点</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E18-1%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E18-1删除链表的节点/</id>
    <published>2018-04-08T09:05:55.000Z</published>
    <updated>2018-04-08T09:59:49.908Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。</p><p><strong>思路：</strong></p><p>由于给定的是单向链表，正常删除链表的时间复杂度是查找链表的时间复杂度即O(n),如果要求在O(1)时间复杂度内删除节点，通过遍历链表找到该节点的上一节点和下一节点的方法是行不通了。所以实现的思路是，根据给定的要删除的节点，可以直接找到其后年的节点，把后面的节点的内容复制到当前节点处，同时将当前节点指向其后面节点的后面节点保证链表不断开，再把下一节点删掉就相当于把给定的节点删除了。</p><p>需要考虑到的一点是，如果要删除的节点是链表的尾节点的话，那还是需要从头结点按照顺序遍历到尾节点的前一节点，然后删除尾节点，总的平均时间复杂度就是[(n-1)*1+O(n)]/n,结果还是O(1)。</p><p><strong>代码实现：</strong></p><p><strong>BUG：</strong>链表只有一个头节点的情况下，该代码无法删除，网上未找到有效代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode head,ListNode node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除尾节点，采用顺序查找找到尾节点的前一节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head.next!=node)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要删除的节点是头结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(head==node)&#123;</span><br><span class="line">        head=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要删除的节点是中间普通节点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        node.data=node.next.data;</span><br><span class="line">        node.next=node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于给定的是单向链表，正常删除链表的时间复杂度是查找链表的时间复杂度即O
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E23链表中环的入口节点(判断链表是否有环)</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E23%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9(%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF)/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E23链表中环的入口节点(判断链表是否有环)/</id>
    <published>2018-04-08T07:51:00.000Z</published>
    <updated>2018-04-08T08:09:58.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个链表中包含环，请找出该链表的环的入口结点。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果链表中有环，那么先获取环中节点个数n，设置两个指针指向pHead </p><p>快指针向前移动n次，然后进行循环，快慢指针同时向后移动，直到指向的节点相同，即环入口节点 </p><p>获取环中节点个数：设置两个指针：p1和p2。p1一次移动一次，p2一次移动两次 </p><p>当p2等于p1，说明存在环。返回该节点 </p><p>通过该节点很容易能获得环中节点个数 </p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 链表中环的入口结点 </span>&#123;</span><br><span class="line">    <span class="comment">//找到一快一慢指针相遇处的节点，相遇的节点一定是在环中</span></span><br><span class="line">    <span class="comment">//此方法可用作判断链表是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fast=fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode meetingNode = meetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span>(meetingNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//      得到环中的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> nodesInLoop = <span class="number">1</span>;</span><br><span class="line">        ListNode p1 = meetingNode;</span><br><span class="line">        <span class="keyword">while</span>(p1.next != meetingNode)&#123;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            ++nodesInLoop;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      移动p1，次数为环中节点数目</span></span><br><span class="line">        p1 = pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nodesInLoop; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      再移动p1，p2</span></span><br><span class="line">        ListNode p2 = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!= p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;一个链表中包含环，请找出该链表的环的入口结点。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>求链表的中间节点</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/%E6%B1%82%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/求链表的中间节点/</id>
    <published>2018-04-08T07:35:36.000Z</published>
    <updated>2018-04-08T07:48:13.096Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数为偶数，返回中间两个结点的任意一个。</p><p><strong>思路：</strong></p><p>设置两个指针fast和slow，两个指针同时向前走，fast指针每次走两步，slow指针每次走一步，直到fast指针走到最后一个结点时，此时slow指针所指的结点就是中间结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度为O（n）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="comment">//每次移动时，让fast结点移动两位，slow结点移动一位</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直到fast结点移动到null时，此时slow指针指向的位置就是中间结点的位置</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<strong>当n为偶数时，得到的中间结点是第n/2 + 1个结点。比如链表有6个节点时，得到的是第4个节点。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数为偶数，返回中间两个结点的任意一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置两个指针fast和slow，两个指针
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E25合并两个排序的链表</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E25合并两个排序的链表/</id>
    <published>2018-04-08T06:17:53.000Z</published>
    <updated>2018-04-08T06:30:31.635Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p><p><strong>步骤：</strong></p><p>Step1.定义一个指向新链表的指针，暂且让它指向NULL；</p><p>Step2.比较两个链表的头结点，让较小的头结点作为新链表的头结点；</p><p>Step3.递归比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点；</p><p><strong>递归解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">Merge</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">Node newHead = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (head1.val &lt;= head2.val)&#123;</span><br><span class="line">        newHead = head1;</span><br><span class="line">        newHead.next = Merge(head1.next, head2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = head2;</span><br><span class="line">        newHead.next = Merge(head1, head2.next);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span>(list2 == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    ListNode tmp1 = list1;</span><br><span class="line">    ListNode tmp2 = list2;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//这里不能把返回链表赋值为null，因为下一行马上就要把它赋值给另一链表，得让它在内存里有位置才行</span></span><br><span class="line">    ListNode headptr = head;</span><br><span class="line">    <span class="keyword">while</span>(tmp1 != <span class="keyword">null</span> &amp;&amp; tmp2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp1.val &lt;= tmp2.val) &#123;</span><br><span class="line">            head.next=tmp1;</span><br><span class="line">            head = head.next;</span><br><span class="line">            tmp1 = tmp1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.next=tmp2;</span><br><span class="line">            head = head.next;</span><br><span class="line">            tmp2=tmp2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其中一个链表已经跑到头之后，继续单链表的合并</span></span><br><span class="line">    <span class="keyword">while</span>(tmp1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        head.next = tmp1;</span><br><span class="line">        head = head.next;</span><br><span class="line">        tmp1= tmp1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        head.next = tmp2;</span><br><span class="line">        head = head.next;</span><br><span class="line">        tmp2= tmp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = headptr.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Step1.定义一个指向新链表的指针，暂且让它指向NULL；&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E24反转链表</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/08/E24反转链表/</id>
    <published>2018-04-08T03:39:04.000Z</published>
    <updated>2018-04-08T03:41:21.711Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义链表*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">this</span>.val = val;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 反转链表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> head; </span><br><span class="line">        &#125;</span><br><span class="line">        Node reHead = <span class="keyword">null</span>;<span class="comment">// 定义新链表头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node cur = head.next;<span class="comment">// 记录下一个节点</span></span><br><span class="line">            head.next = reHead;<span class="comment">// 将rehead节点连接到head节点上</span></span><br><span class="line">            reHead = head;<span class="comment">// 让rehead指向head</span></span><br><span class="line">            head = cur;<span class="comment">// 将head指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**递归反转链表 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)    <span class="keyword">return</span> head;</span><br><span class="line">        Node rehead = reverseList2(head.next);</span><br><span class="line">        head.next.next = head;<span class="comment">// 将头节点置于末端</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;<span class="comment">// 防止链表循环</span></span><br><span class="line">        <span class="keyword">return</span> rehead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**打印链表  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">/*测试*/</span></span><br><span class="line">        Node n1 = <span class="keyword">new</span> Node(<span class="number">1</span>);   Node n2 = <span class="keyword">new</span> Node(<span class="number">2</span>);   Node n3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node n4 = <span class="keyword">new</span> Node(<span class="number">4</span>);   Node n5 = <span class="keyword">new</span> Node(<span class="number">5</span>);   n1.next = n2;</span><br><span class="line">        n2.next = n3;    n3.next = n4; n4.next = n5;</span><br><span class="line">       <span class="comment">// Node rehead = reverseList(n1);</span></span><br><span class="line">        Node rehead = reverseList2(n1);               </span><br><span class="line">        printList(rehead);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>从链表中删除重复元素</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/从链表中删除重复元素/</id>
    <published>2018-04-07T15:25:02.000Z</published>
    <updated>2018-04-08T08:24:17.185Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">deleteDuplecate</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：优点是时间复杂度低，但是需要额外的存储空间来保存遍历过的值。时间复杂度O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete_v1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Hashtable&lt;Integer,Integer&gt; table=<span class="keyword">new</span> Hashtable&lt;Integer,Integer&gt;();</span><br><span class="line">        Node temp=head;</span><br><span class="line">        Node pre=<span class="keyword">null</span>; <span class="comment">//辅助链表的头节点</span></span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(table.containsKey(temp.data))</span><br><span class="line">                pre.next=temp.next;   </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                table.put(temp.data, <span class="number">1</span>);</span><br><span class="line">                pre=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：双重循环遍历链表,优点：不需要额外的存储空间.时间复杂度O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete_v2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node q = p;</span><br><span class="line">            <span class="keyword">while</span>(q.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.next.data==p.data)&#123;</span><br><span class="line">                    q.next=q.next.next;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法三：外循环当前遍历的结点为p，内循环从表头开始遍历至p</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete_v3</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node q=head;</span><br><span class="line">            <span class="keyword">while</span>(q.next!=p &amp;&amp; q.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.next.data==p.data)&#123;</span><br><span class="line">                    q.next=q.next.next;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Node next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E22求链表中倒数第k个节点</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/E22%E6%B1%82%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/E22求链表中倒数第k个节点/</id>
    <published>2018-04-07T15:18:30.000Z</published>
    <updated>2018-04-08T03:42:51.982Z</updated>
    
    <content type="html"><![CDATA[<p>为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。<br>不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。</p><p>如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。<br>设计如下：依次对链表的每一个结点元素进行这样的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。<br>此种方法将对同一批元素进行反复多次的遍历，对于链表的大部分元素而言，都要遍历k个元素，如果链表长度为n，则该算法时间复杂度为O(kn)级，效率太低。<br>存在另一种更高效的方法。<br><strong>在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findElem</span><span class="params">(Node head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p1 = head;</span><br><span class="line">    Node p2 = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123; <span class="comment">//前移k-1步</span></span><br><span class="line">        <span class="keyword">if</span>(p1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。&lt;br&gt;不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表基本代码实现</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/链表基本代码实现/</id>
    <published>2018-04-07T14:40:42.000Z</published>
    <updated>2018-04-07T14:57:34.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表节点定义"><a href="#链表节点定义" class="headerlink" title="链表节点定义"></a>链表节点定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为了方便，这两个变量都使用public，而不用private就不需要编写get、set方法了。</span></span><br><span class="line">    <span class="comment">//存放数据的变量，简单点，直接为int型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">//存放结点的变量,默认为null</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造方法，在构造时就能够给data赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表尾部增加节点"><a href="#链表尾部增加节点" class="headerlink" title="链表尾部增加节点"></a>链表尾部增加节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//链表中有结点，遍历到最后一个结点</span></span><br><span class="line">    Node temp = head;    <span class="comment">//一个移动的指针(把头结点看做一个指向结点的指针)</span></span><br><span class="line">    <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;    <span class="comment">//遍历单链表，直到遍历到最后一个则跳出循环。</span></span><br><span class="line">    temp = temp.next;        <span class="comment">//往后移一个结点，指向下一个结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    temp.next = node;    <span class="comment">//temp为最后一个结点或者是头结点，将其next指向新结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入结点到链表的指定位置"><a href="#插入结点到链表的指定位置" class="headerlink" title="插入结点到链表的指定位置"></a>插入结点到链表的指定位置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * insertNodeByIndex:在链表的指定位置插入结点。</span></span><br><span class="line"><span class="comment">     *         插入操作需要知道1个结点即可，当前位置的前一个结点</span></span><br><span class="line"><span class="comment">     * index:插入链表的位置，从1开始</span></span><br><span class="line"><span class="comment">     * node:插入的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNodeByIndex</span><span class="params">(<span class="keyword">int</span> index,Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否合法，</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;length()+<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"插入位置不合法。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;            <span class="comment">//记录我们遍历到第几个结点了，也就是记录位置。</span></span><br><span class="line">        Node temp = head;        <span class="comment">//可移动的指针</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;<span class="comment">//遍历单链表</span></span><br><span class="line">            <span class="keyword">if</span>(index == length++)&#123;        <span class="comment">//判断是否到达指定位置。</span></span><br><span class="line">                <span class="comment">//注意，我们的temp代表的是当前位置的前一个结点。</span></span><br><span class="line">                <span class="comment">//前一个结点        当前位置        后一个结点</span></span><br><span class="line">                <span class="comment">//temp            temp.next     temp.next.next</span></span><br><span class="line">                <span class="comment">//插入操作。</span></span><br><span class="line">                node.next = temp.next;            </span><br><span class="line">                temp.next = node;                </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="删除指定位置上的结点"><a href="#删除指定位置上的结点" class="headerlink" title="删除指定位置上的结点"></a>删除指定位置上的结点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过index删除指定位置的结点,跟指定位置增加结点是一样的，先找到准确位置。然后进行删除操作。</span></span><br><span class="line"><span class="comment"> * 删除操作需要知道1个结点即可：和当前位置的前一个结点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index：链表中的位置，从1开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNodeByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断index是否合理</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span> || index&gt;length())&#123;</span><br><span class="line">            System.out.println(<span class="string">"给定的位置不合理"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//步骤跟insertNodeByIndex是一样的，只是操作不一样。    </span></span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == length++)&#123;</span><br><span class="line">                <span class="comment">//删除操作。</span></span><br><span class="line">                temp.next = temp.next.next;    </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="单链表进行选择排序"><a href="#单链表进行选择排序" class="headerlink" title="单链表进行选择排序"></a>单链表进行选择排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *对链表中的结点进行排序，按照从小到大的顺序，使用选择排序。</span></span><br><span class="line"><span class="comment"> *使用双层遍历。第一层遍历，正常遍历链表，第二层遍历，遍历第一层遍历时所用的结点后面所有结点并与之比较</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSortNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断链表长度大于2，不然只有一个元素，就不用排序了。</span></span><br><span class="line">    <span class="keyword">if</span>(length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"无需排序"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    Node temp = head; <span class="comment">//第一层遍历使用的移动指针，最处指向头结点，第一个结点用temp.next表示</span></span><br><span class="line">    <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;<span class="comment">//第一层遍历链表，从第一个结点开始遍历</span></span><br><span class="line">Node secondTemp = temp.next; <span class="comment">//第二层遍历使用的移动指针，secondTemp指向第一个结点，我们需要用到是第二个结点开始，所以用secondNode.next       </span></span><br><span class="line">    <span class="keyword">while</span>(secondTemp.next != <span class="keyword">null</span>)&#123;<span class="comment">//第二层遍历,从第二个结点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>( temp.next.data &gt; secondTemp.next.data)&#123;<span class="comment">//第二层中的所有结点依次与第一次遍历中选定的结点进行比较</span></span><br><span class="line">            <span class="keyword">int</span> t = secondTemp.next.data;</span><br><span class="line">            secondTemp.next.data =  temp.next.data;</span><br><span class="line">            temp.next.data = t;                </span><br><span class="line">       &#125;</span><br><span class="line">        secondTemp = secondTemp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算单链表的长度"><a href="#计算单链表的长度" class="headerlink" title="计算单链表的长度"></a>计算单链表的长度</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算单链表的长度，也就是有多少个结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    结点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="遍历单链表，打印data"><a href="#遍历单链表，打印data" class="headerlink" title="遍历单链表，打印data"></a>遍历单链表，打印data</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历单链表，打印所有data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(temp.data+<span class="string">","</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链表节点定义&quot;&gt;&lt;a href=&quot;#链表节点定义&quot; class=&quot;headerlink&quot; title=&quot;链表节点定义&quot;&gt;&lt;/a&gt;链表节点定义&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E06从尾到头打印链表</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/E06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/E06从尾到头打印链表/</id>
    <published>2018-04-07T14:22:43.000Z</published>
    <updated>2018-04-08T03:42:33.738Z</updated>
    
    <content type="html"><![CDATA[<p>很多人第一反应是从头到尾输出将会比较简单，于是自然想到把链表中连接结点的指针反转过来，改变链表的方向即可。但该方法会改变原来链表的结构，是否允许在打印链表的时候修改链表的结构，这点取决于面试官的需求。 </p><p>通常打印是一个只读操作，我们不希望打印时修改内容。 </p><p>第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出，这就是典型的“后进先出”！我们用栈来实现这种结构。 </p><p>既然用栈来实现，而递归本质上就是一个栈的结构，自然也可以用递归来实现。基于递归的代码看起来很简洁，但当链表非常长的时候，就会导致函数调用的层数很深，从而有可能导致函数调用栈溢出。 </p><p>显然用栈基于循环实现的代码的鲁棒性要好一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintListReverse</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非递归的方式，鲁棒性好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListReverse</span><span class="params">(ListNode headNode)</span></span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(headNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(headNode);</span><br><span class="line">            headNode=headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(stack.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归方式，递归在本质上就是一个栈结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListReverse_recursively</span><span class="params">(ListNode headNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(headNode.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                printListReverse_recursively(headNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(headNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode node2 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode node3 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        node1.val=<span class="number">1</span>;</span><br><span class="line">        node2.val=<span class="number">2</span>;</span><br><span class="line">        node3.val=<span class="number">3</span>;</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        PrintListReverse plr = <span class="keyword">new</span> PrintListReverse();</span><br><span class="line">        plr.printListReverse(node1);</span><br><span class="line">        plr.printListReverse_recursively(node1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多人第一反应是从头到尾输出将会比较简单，于是自然想到把链表中连接结点的指针反转过来，改变链表的方向即可。但该方法会改变原来链表的结构，是否允许在打印链表的时候修改链表的结构，这点取决于面试官的需求。 &lt;/p&gt;
&lt;p&gt;通常打印是一个只读操作，我们不希望打印时修改内容。 &lt;/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>E05替换空格</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/E05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/07/E05替换空格/</id>
    <published>2018-04-07T13:07:41.000Z</published>
    <updated>2018-04-07T13:10:34.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h1 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;str.length(); k++)&#123;</span><br><span class="line">        <span class="keyword">char</span> index = str.charAt(k);</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="string">' '</span>)&#123;</span><br><span class="line">            str.replace(k, k+<span class="number">1</span>, <span class="string">"%20"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是<code>java.lang.StringBuilder.replace()</code>方法的声明</p><p><code>public StringBuilder replace(int start, int end, String str);</code></p><p><strong>参数</strong></p><ul><li>start – 这是开始索引(包括)。</li><li>end – end 索引(不包括)。</li><li>str – 这是字符串，它将取代以前的内容。</li></ul><h1 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h1><p>思路：从字符串的后面开始复制和替换，首先准备两个指针，p1和p2，p1指向原始字符串的末尾，p2指向替换后字符串的末尾，接下来，向前移动指针p1，逐个把它指向的字符复制到p2，碰到一个空格之后，把p1向前移动1格，在p2处插入字符串“20%”，由于“20%”长度为3，同时也要把p2向前移动3格。直到p1=p2，表明所有空格都已经替换完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceSpace</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str=scanner.nextLine();</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length=charArray.length;</span><br><span class="line">        <span class="keyword">int</span> spaceNumber=<span class="number">0</span>;<span class="comment">//获取空格数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : charArray) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">' '</span>) &#123;</span><br><span class="line">            spaceNumber++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newLength=length+spaceNumber*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span>[] tempArray=<span class="keyword">new</span> <span class="keyword">char</span>[newLength];<span class="comment">//新的数组的长度</span></span><br><span class="line">        <span class="comment">//将原来的数组拷贝到新长度的数组中</span></span><br><span class="line">        System.arraycopy(charArray, <span class="number">0</span>, tempArray, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> indexofOriginal = length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">int</span> indexofNew = newLength - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (indexofOriginal&gt;=<span class="number">0</span>&amp;&amp;indexofOriginal!=indexofNew) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempArray[indexofOriginal]==<span class="string">' '</span>) &#123;</span><br><span class="line">                tempArray[indexofNew--] = <span class="string">'0'</span>; </span><br><span class="line">                tempArray[indexofNew--] = <span class="string">'2'</span>;</span><br><span class="line">                tempArray[indexofNew--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tempArray[indexofNew--] = tempArray[indexofOriginal];</span><br><span class="line">            &#125;</span><br><span class="line">            indexofOriginal--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : tempArray) &#123;</span><br><span class="line">            System.out.print(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>WSL（Windows下Linux子系统）安装过程</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/WSL%EF%BC%88Windows%E4%B8%8BLinux%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%89%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/WSL（Windows下Linux子系统）安装过程/</id>
    <published>2018-04-06T14:23:52.000Z</published>
    <updated>2018-04-08T04:15:48.678Z</updated>
    
    <content type="html"><![CDATA[<p>WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，今天初步在自己的笔记本上尝试了一下，也遇到一些问题，现记录如下：</p><p><strong>安装步骤如下：</strong></p><p>1.控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选<strong>适用于Linux的Windows子系统</strong>，重启电脑</p><p>2.应用商店下搜索wsl，现已支持Ubuntu、openSUSE LEAP 42、SUSE Linux Enterprise、Debian、Kali Linux五个版本，直接安装即可</p><p>安装位置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc</span><br></pre></td></tr></table></figure><p>注：所有系统均只有命令行，没有桌面</p><p>3.根据提示设置账户名及密码</p><p>4.设置root账户密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p><strong>系统安装完成，下面为桌面安装过程</strong></p><p>5.在<strong>Ubuntu</strong>下我们可以通过 <strong>apt-get</strong> 命令很方便的安装/卸载软件，由于默认的软件包仓库是位于国外的，安装软件的时候就可能遇到各种网络问题或者下载到的一些资源不完整，因此就需要切换数据源为国内的镜像站点来改善</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.备份原来的数据源配置文件</span></span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br><span class="line"><span class="comment"># 2.编辑数据源配置文件</span></span><br><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>在这里我使用的是阿里云的数据源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 3.更新配置</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>6.下载软件</p><blockquote><p>可供选择安装的X-Windows有多个：VcXsrv Windows X Server、Xming、Cygwin X Server，本文选择第一个，因为比较容易，而且据说稳定；</p></blockquote><p>软件首页：<a href="https://sourceforge.net/projects/vcxsrv/" target="_blank" rel="noopener">https://sourceforge.net/projects/vcxsrv/</a> </p><p>下载软件，windows下安装好，启动Launcher，首次启动自动进入界面设置后：</p><p><strong>选择：“one large window”，Display number设置成0，其它默认即可：</strong></p><p>7.打开Bash，安装ubuntu-desktop, unity, and ccsm（下载桌面及解压花了很久很久）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</span><br></pre></td></tr></table></figure><p>若报错，则改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop unity compiz-core</span><br></pre></td></tr></table></figure><p><strong>需要提醒的是，需下载650M，解压后近2.4G ，均安装在C盘</strong></p><p>8.配置compiz窗口管理器</p><p>启动之前安装的X-Windows，在Bash中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span>  DISPLAY=localhost:0</span><br><span class="line">sudo ccsm</span><br></pre></td></tr></table></figure><p>9.切换到<code>Ubuntu`</code>Bash<code>窗口，执行以下命令并切换回</code>VcXsrv`窗口查看效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo compiz</span><br></pre></td></tr></table></figure><p>附加：</p><p><strong>安装中文支持并配置profile文件</strong></p><p>在桌面环境打开一个<code>终端</code>，执行以下命令安装中文支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install language-pack-zh-hans</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br></pre></td></tr></table></figure><p>将以下环境变量添加到<code>/etc/profile</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=localhost:0</span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANGUAGE=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">export</span> LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure><p>重新加载<code>profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>重新生成<code>locale</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><p><strong>卸载子系统</strong></p><p>设置&gt;应用&gt;应用和功能，找到Ubuntu卸载即可</p><p>安装过程参考自：</p><p><a href="https://www.jianshu.com/p/bc38ed12da1d" target="_blank" rel="noopener">https://www.jianshu.com/p/bc38ed12da1d</a></p><p><a href="https://blog.csdn.net/u011138447/article/details/78262369" target="_blank" rel="noopener">https://blog.csdn.net/u011138447/article/details/78262369</a></p><p><a href="https://zhuanlan.zhihu.com/p/34884285/" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34884285/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，今天初步在自己的笔记本上尝试了一下，也遇到一些问题，现记录如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.控制面板-&amp;gt;程
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"/>
    
      <category term="项目问题" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SQL必知必会</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/SQL必知必会/</id>
    <published>2018-04-06T13:24:54.000Z</published>
    <updated>2018-04-06T13:35:34.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h1><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>插入检索出来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</p><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h1 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>= &lt; &gt;</td><td>等于 小于 大于</td></tr><tr><td>&lt;&gt; !=</td><td>不等于</td></tr><tr><td>&lt;= !&gt;</td><td>小于等于</td></tr><tr><td>&gt;= !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为NULL值</td></tr></tbody></table><p>应该注意到，NULL 与 0 、空字符串都不同。</p><p><strong>AND OR</strong> 用于连接多个过滤条件。优先处理 AND，因此当一个过滤表达式涉及到多个 AND 和 OR 时，应当使用 () 来决定优先级。</p><p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong> 操作符用于否定一个条件。</p><h1 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li></ul><p>使用 Like 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span> <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1*col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">' ('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>)</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure><h1 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h1><p>各个 DBMS 的函数都是不相同的，因此不可移植。</p><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT() RIGHT()</td><td>左边或者右边的字符</td></tr><tr><td>LOWER() UPPER()</td><td>转换为小写或者大写</td></tr><tr><td>LTRIM() RTIM()</td><td>去除左边或者右边的空格</td></tr><tr><td>LENGTH()</td><td>长度</td></tr><tr><td>SUNDEX()</td><td>转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong> 是将一个字符串转换为描述其语音表示的字母数字模式的算法，它是根据发音而不是字母比较。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure><h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br><span class="line">        -&gt; '2017-06-28 14:01:52'</span><br></pre></td></tr></table></figure><h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure><h1 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也可以按该字段进行排序，例如按 col 字段排序并分组数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>GROUP BY 是按照分组字段进行排序，ORDER BY 也可以以汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p>WHERE 过滤行，HAVING 过滤分组。行过滤应当先与分组过滤；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ol><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ol><h1 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h1><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b, c</span><br><span class="line"><span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B</span><br><span class="line"><span class="keyword">on</span> A.key = B.key</span><br></pre></td></tr></table></figure><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b, c</span><br><span class="line"><span class="keyword">from</span> A, B</span><br><span class="line"><span class="keyword">where</span> A.key = B.key</span><br></pre></td></tr></table></figure><p>在没有条件语句的情况下返回笛卡尔积。</p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> employee</span><br><span class="line"><span class="keyword">where</span> department = (</span><br><span class="line">      <span class="keyword">select</span> department</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e2.name</span><br><span class="line"><span class="keyword">from</span> employee <span class="keyword">as</span> e1, employee <span class="keyword">as</span> e2</span><br><span class="line"><span class="keyword">where</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">and</span> e1.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><p>连接一般比子查询的效率高。</p><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> employee <span class="keyword">natural</span> <span class="keyword">join</span> department;</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">from</span> Customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> Orders</span><br><span class="line"><span class="keyword">on</span> Customers.cust_id = Orders.curt_id;</span><br></pre></td></tr></table></figure><p>如果需要统计顾客的订单数，使用聚集函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Customers.cust_id,</span><br><span class="line">       <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">as</span> num_ord</span><br><span class="line"><span class="keyword">from</span> Customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> Orders</span><br><span class="line"><span class="keyword">on</span> Customers.cust_id = Orders.curt_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Customers.cust_id;</span><br></pre></td></tr></table></figure><h1 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h1><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果为 M+N 行。</p><p>每个查询必须包含相同的列、表达式或者聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ol><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> count_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h1 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理；</p><h2 id="使用存储过程的好处"><a href="#使用存储过程的好处" class="headerlink" title="使用存储过程的好处"></a>使用存储过程的好处</h2><ol><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ol><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(@ret);</span><br><span class="line"><span class="keyword">select</span> @ret;</span><br></pre></td></tr></table></figure><h1 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span><br><span class="line">        <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h1 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.col;</span><br></pre></td></tr></table></figure><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。</p><p>可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p><p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p><h1 id="二十一、事务处理"><a href="#二十一、事务处理" class="headerlink" title="二十一、事务处理"></a>二十一、事务处理</h1><p>基本术语：</p><ol><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，也就是每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h1 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h1><p>基本术语：</p><ol><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ol><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(<span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">col</span> <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h1 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p>新创建的账户没有任何权限。</p><h2 id="修改账户名"><a href="#修改账户名" class="headerlink" title="修改账户名"></a>修改账户名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><h2 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><h2 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><h2 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><p>必须使用 Password() 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'newpassword'</span>);</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;p&gt;模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。&lt;/p&gt;
&lt;p&gt;主键的值不允许修改，也不
      
    
    </summary>
    
      <category term="数据库" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java的序列化</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/Java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/Java的序列化/</id>
    <published>2018-04-06T12:39:33.000Z</published>
    <updated>2018-04-17T06:31:07.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。</strong></p><h1 id="为什么需要序列化？"><a href="#为什么需要序列化？" class="headerlink" title="为什么需要序列化？"></a>为什么需要序列化？</h1><p>第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。</p><p>第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。</p><h1 id="如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？"><a href="#如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？" class="headerlink" title="如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？"></a>如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？</h1><p>答：如果父类有默认构造函数的话，即使没有实现Serializable接口也不会有问题，反序列化的时候会调用默认构造函数进行初始化，否则的话反序列化的时候会抛出.InvalidClassException:异常，异常原因为no validconstructor。</p><h1 id="实现序列化方法"><a href="#实现序列化方法" class="headerlink" title="实现序列化方法"></a>实现序列化方法</h1><ul><li>实现Serializable接口 </li></ul><p>1.该接口只是一个可序列化的标志，并没有包含实际的属性和方法。 </p><p>2.如果不在改方法中添加readObject()和writeObject()方法，则采取默认的序列化机制。如果添加了这两个方法之后还想利用Java默认的序列化机制，则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()两个方法。 </p><p>3.为了保证安全性，可以使用transient关键字进行修饰不必序列化的属性。因为在反序列化时，private修饰的属性也能发查看到。 </p><ul><li>实现ExternalSerializable方法 </li></ul><p>自己对要序列化的内容进行控制，控制哪些属性能被序列化，哪些不能被序列化。 </p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><ul><li>实现Serializable接口的对象在反序列化时不需要调用对象所在类的构造方法，完全基于字节。 </li><li>实现externalSerializable接口的方法在反序列化时会调用构造方法。 </li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>被static修饰的属性不会被序列化 </li><li>对象的类名、属性都会被序列化，方法不会被序列化 </li><li>要保证序列化对象所在类的属性也是可以被序列化的 </li><li>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象。 </li><li>反序列化时必须有序列化对象时的class文件 </li><li>最好显示的声明serializableID，因为在不同的JVM之间，默认生成serializableID 可能不同，会造成反序列化失败。 </li></ul><h3 id="常见的序列化协议有哪些"><a href="#常见的序列化协议有哪些" class="headerlink" title="常见的序列化协议有哪些"></a>常见的序列化协议有哪些</h3><ul><li>COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大。 </li></ul><ul><li><p>CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。 </p></li><li><p>XML&amp;SOAP </p><p>XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 </p><p>SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。 </p></li></ul><ul><li><p>JSON（JavascriptObject Notation） </p><p>这种Associativearray格式非常符合工程师对对象的理解。它保持了XML的人眼可读（Human-readable）的优点。相对于XML而言，序列化后的数据更加简洁。它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。</p><p>与XML相比，其协议比较简单，解析速度比较快。松散的Associativearray使得其具有良好的可扩展性和兼容性。 </p></li></ul><ul><li>Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用 </li><li>Protobuf具备了优秀的序列化协议的所需的众多典型特征标准的IDL和IDL编译器，这使得其对工程师非常友好。序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。解析速度非常快，比对应的XML快约20-100倍。提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景 </li></ul><ul><li>Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于ApacheHadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。适合于高性能的序列化服务。 </li></ul><h3 id="几种协议的对比"><a href="#几种协议的对比" class="headerlink" title="几种协议的对比"></a>几种协议的对比</h3><ul><li>XML序列化（Xstream）无论在性能和简洁性上比较差； </li><li>Thrift与Protobuf相比在时空开销方面都有一定的劣势； </li><li>Protobuf和Avro在两方面表现都非常优越。 </li></ul><p>本文转载自：<a href="http://www.importnew.com/17964.html" target="_blank" rel="noopener">http://www.importnew.com/17964.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。&lt;/s
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/%E6%AD%BB%E9%94%81/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/06/死锁/</id>
    <published>2018-04-06T10:01:38.000Z</published>
    <updated>2018-04-06T13:41:01.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h1><p>是指两个或两个以上的进程在执行过程中，<strong>由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</strong>，若无外力作用，它们都将无法推进下去。</p><h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p>活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><h1 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h1><p><strong>互斥条件：一个资源一次只能被一个进程使用</strong><br><strong>请求保持条件：一个进程因请求资源而阻塞时，对已经获得资源保持不放</strong><br><strong>不可抢占条件：进程已获得的资源在未使用完之前不能强行剥夺</strong><br><strong>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系</strong></p><h1 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h1><p>两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:</p><p>1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来</p><p>2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求</p><p> 如果第二步返回真,表示出现了死锁</p><h1 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h1><p>在有些情况下死锁是可以避免的。三种用于避免死锁的技术：</p><ol><li><strong>加锁顺序（线程按照一定的顺序加锁）</strong></li><li><strong>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</strong></li><li><strong>死锁检测</strong></li></ol><p>那么当检测出死锁时，这些线程该做些什么呢？</p><p>给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p><p><strong>银行家算法</strong>：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p><h1 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h1><p>一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。 死锁解除的主要方法有：</p><p>1) <strong>资源剥夺法</strong>。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p><p>2) <strong>撤销进程法</strong>。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p><p>3) <strong>进程回退法</strong>。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p><h1 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h1><p><strong>死锁检测算法</strong> 死锁检测的基本思想是，如果一个进程所请求的资源能够被满足，那么就让它执行，否则释放它拥有的所有资源，然后让其它能满足条件的进程执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;死锁定义&quot;&gt;&lt;a href=&quot;#死锁定义&quot; class=&quot;headerlink&quot; title=&quot;死锁定义&quot;&gt;&lt;/a&gt;死锁定义&lt;/h1&gt;&lt;p&gt;是指两个或两个以上的进程在执行过程中，&lt;strong&gt;由于竞争资源或者由于彼此通信而造成的一种阻塞的现象&lt;/strong&gt;，
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程和进程的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/线程和进程的区别/</id>
    <published>2018-04-05T14:27:48.000Z</published>
    <updated>2018-04-07T13:21:54.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入进程之前–多道程序设计"><a href="#引入进程之前–多道程序设计" class="headerlink" title="引入进程之前–多道程序设计"></a>引入进程之前–多道程序设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>多道程序设计技术</strong>是操作系统最早引入的技术，它的设计思想是允多个程序<strong>同时</strong>进入内存并运行，其目的是为了CPU的利用率，进而提高系统效率。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>多道程序设计技术引入之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。而多道程序设计技术允许多个程序同时进入内存并运行，那就要每个程序分配程序计数器。如果内存中有四个程序在并发执行，那就需要四个程序计数器。</p><h2 id="新技术带来的问题"><a href="#新技术带来的问题" class="headerlink" title="新技术带来的问题"></a>新技术带来的问题</h2><p>一个技术、一个机制的引入，一方面解决了以前棘手的问题，但同时，往往带来新的问题。多道程序设计技术也是如此。</p><blockquote><p>多道程序设计技术允许多个程序同时进入内存并运行，在这样的并发环境下，如何描述、刻画这样执行的程序呢？因此引入了“进程”。</p></blockquote><h1 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程是具有独立功能的程序关于<strong>某个数据集合上</strong>的<strong>一次运行活动</strong>，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。</li><li>进程是是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象。（虚拟技术的支持，将一个CPU变幻为多个虚拟的CPU）</li><li>系统资源（如内存、文件）以进程为单位分配。</li><li><strong>操作系统为每个进程分配了独立的地址空间</strong></li><li>操作系统通过“调度”把控制权交给进程。</li></ul><blockquote><p>为什么引入线程 有了进程这概念之后 应用程序可以并发地去执行了 那么为什么要在进程当中再派生出线程呢？ </p></blockquote><h2 id="为什么引入线程？"><a href="#为什么引入线程？" class="headerlink" title="为什么引入线程？"></a>为什么引入线程？</h2><p>首先我们引入了进程这个概念，虽然进程<strong>有利于资源的管理和保护</strong>。然而在实际应用中，进程有这样的问题： </p><ol><li>进程切换的代价、开销比较大； </li><li>在一个进程内也需要并行执行多个程序，实现不同的功能。 </li><li>进程有时候性能比较低。</li></ol><blockquote><p>引入线程有以下三个方面的考虑</p></blockquote><ol><li><strong>应用的需要</strong>。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。</li><li><strong>开销的考虑</strong>。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件）</li><li><strong>性能的考虑</strong>。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。 </li></ol><h1 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程(Thread)"></a>线程(Thread)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>有标识符ID</li><li>有状态及状态转换，所以需要提供一些状态转换操作</li><li>不运行时需要保存上下文环境，所以需要程序计数器等寄存器</li><li>有自己的栈和栈指针</li><li>共享所在进程的地址空间和其它资源</li></ul><h1 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h1><p><strong>1.定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程）</strong></p><p><strong>2.角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位。</strong></p><p>​    总线程数&lt;= CPU数量：并行运行 </p><p>​    总线程数&gt; CPU数量：并发运行 </p><p><strong>3.资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。</strong></p><p><strong>4.独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。</strong></p><p><strong>5.开销方面。进程切换的开销较大。线程相对较小。（前面也提到过，引入线程也出于了开销的考虑。）</strong></p><p>线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><h1 id="Read-more"><a href="#Read-more" class="headerlink" title="Read more"></a>Read more</h1><p><a href="https://discuss.leetcode.com/topic/90877/process-vs-thread" target="_blank" rel="noopener">Process Vs Thread</a></p><p><a href="http://www.differencebetween.info/difference-between-process-and-thread" target="_blank" rel="noopener">Difference between Process and Thread</a> </p><p><a href="http://www.java67.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="noopener">what is different between thread and process</a></p><p><a href="http://www.cnblogs.com/zl1991/p/6867985.html" target="_blank" rel="noopener">理解Android进程创建流程（转）</a></p><p>本文转载整理自：</p><p><a href="http://blog.csdn.net/zheng548/article/details/54669908" target="_blank" rel="noopener">http://blog.csdn.net/zheng548/article/details/54669908</a></p><p><a href="https://blog.csdn.net/robbyo/article/details/8549904" target="_blank" rel="noopener">https://blog.csdn.net/robbyo/article/details/8549904</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入进程之前–多道程序设计&quot;&gt;&lt;a href=&quot;#引入进程之前–多道程序设计&quot; class=&quot;headerlink&quot; title=&quot;引入进程之前–多道程序设计&quot;&gt;&lt;/a&gt;引入进程之前–多道程序设计&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java后端技术</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java后端技术/</id>
    <published>2018-04-05T13:57:36.000Z</published>
    <updated>2018-04-05T15:41:53.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>后端主要的技术：</strong></p><p><strong>服务框架：Dubbo，zookeeper，Rest服务</strong><br><strong>缓存：redis，ehcache</strong><br><strong>消息中间件：ActiveMQ，kafka</strong><br><strong>负责均衡：Nginx</strong><br><strong>分布式文件：FastDFS</strong><br><strong>安全框架：Apache shiro</strong><br><strong>任务调度：quartz</strong><br><strong>持久层框架：mybatis</strong><br><strong>日志：log4j</strong><br><strong>项目基础搭建。spring，springmvc</strong><br><strong>环境搭建：linux下</strong><br><strong>开发工具：eclipse，idea等</strong><br><strong>服务器：tomcat，jetty等</strong></p><p><strong>目前系统主流搭建：Nginx+tomcat+mybatis+redis。</strong><br>针对不同的业务需求，我们会引用不同的技术。</p><p>这些主要定位于互联网企业架构</p><p>框架简介：</p><p>企业信息化系统基础功能和高效的代码生成工具，包括:</p><p>系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、</p><p>平台简介：</p><p>是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。</p><p>本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。</p><p>使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。</p><p>以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。</p><p>前端集成bootstrap 框架。响应式</p><p>目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务）</p><p>提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。</p><p>内置功能(只列了一部分功能)</p><p>1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。</p><p>2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。</p><p>3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。</p><p>4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。</p><p>5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。</p><p>6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。</p><p>7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。</p><p>8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。</p><p>9.工作流引擎：实现业务工单流转、在线流程设计器。</p><p>开发工具</p><p>1.Eclipse IDE：采用Maven项目管理，模块化。</p><p>2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。</p><p>技术选型（只列了一部分技术）</p><p>1、后端</p><p>服务框架：Dubbo、zookeeper、Rest服务</p><p>缓存：Redis、ehcache</p><p>消息中间件：ActiveMQ</p><p>负载均衡：Nginx</p><p>分布式文件：FastDFS</p><p>数据库连接池：Alibaba Druid 1.0</p><p>核心框架：Spring framework</p><p>安全框架：Apache Shiro 1.2</p><p>视图框架：Spring MVC 4.0</p><p>服务端验证：Hibernate Validator 5.1</p><p>布局框架：SiteMesh 2.4</p><p>工作流引擎：Activiti 5.15</p><p>任务调度：quartz 1.8.5</p><p>持久层框架：MyBatis 3.2</p><p>日志管理：SLF4J 1.7、Log4j</p><p>工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI</p><p>2、前端</p><p>JS框架：JQuery 1.9。</p><p>CSS框架： Bootstrap 4 metronic</p><p>客户端验证：JQuery Validation Plugin。</p><p>富文本：CKEcitor</p><p>文件管理：CKFinder</p><p>动态页签：Jerichotab</p><p>数据表格：jqGrid</p><p>对话框：jQuery jBox</p><p>树结构控件：jQuery zTree</p><p>其他组件：Bootstrap 4 metronic</p><p>3、支持</p><p>服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8</p><p>数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等</p><p>支持开发环境：Eclipse、MyEclipse、Ras、Idea等。</p><p>本文转载自网络</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;后端主要的技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务框架：Dubbo，zookeeper，Rest服务&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;缓存：redis，ehcache&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;消息中间件：Activ
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>字符和字节的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E8%8A%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/字符和字节的区别/</id>
    <published>2018-04-05T13:42:35.000Z</published>
    <updated>2018-04-05T13:50:43.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“字节”的定义"><a href="#“字节”的定义" class="headerlink" title="“字节”的定义"></a>“字节”的定义</h1><p>字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。</p><h1 id="“字符”的定义"><a href="#“字符”的定义" class="headerlink" title="“字符”的定义"></a>“字符”的定义</h1><p>字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。</p><h1 id="“字节”与“字符”"><a href="#“字节”与“字符”" class="headerlink" title="“字节”与“字符”"></a>“字节”与“字符”</h1><p>它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同：</p><p>①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。</p><p>②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。</p><p>③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。<br>符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。</p><p>④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。</p><p>⑤UTF-32编码中，世界上任何字符的存储都需要4个字节</p><p>⑥通常在读取非文本文件时（如图片，声音，可执行文件）需要用字节数组来保存文件的内容，在下载文件时，也是用byte数组作临时的缓冲器接收文件内容。所以说byte在文件操作时是必不可少的。不管是对文件写入还是读取都要用到。byte在java中是一种是数据类型，代表一个字节，一个字节包含8个位，所以，byte类型的取值范围是-128到127。在某些程序中（尤其是和硬件有关的程序）会将某些数据存储到字节类型的变量中，比如00110010,其中每个位都代表一个参数，然后以位运算的方式对参数进行取值和赋值操作。</p><p>机器只知道字节，而字符却是语义上的单位，它是有编码的，一个字符可能编码成1个2个甚至3个4个字节。这跟字符集编码有关系，英文字母和数字是单字节，但汉字这些自然语言中的字符是多字节的。一个字节只能表示255个字符，不可能用于全球那么多种自然语言的处理，因此肯定需要多字节的存储方式。而InputStream, OutputStream它们是处理字节流的，就是说假设所有东西都是二进制的字节，而 Reader, Writer 则是字符流，它涉及到字符集的问题；按照ANSI编码标准，标点符号、数字、大小写字母都占一个字节，汉字占2个字节。按照UNICODE标准所有字符都占2个字节。</p><p>本文整理转载自网络</p><p>​                    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“字节”的定义&quot;&gt;&lt;a href=&quot;#“字节”的定义&quot; class=&quot;headerlink&quot; title=&quot;“字节”的定义&quot;&gt;&lt;/a&gt;“字节”的定义&lt;/h1&gt;&lt;p&gt;字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中基本类型的取值范围</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java中基本类型的取值范围/</id>
    <published>2018-04-05T13:03:09.000Z</published>
    <updated>2018-04-05T13:27:44.605Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">占内存大小</th><th style="text-align:center">取值范围</th><th style="text-align:center">数值范围</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1个字节 (8bit)</td><td style="text-align:center">-2<sup>7</sup>~2<sup>7</sup>-1</td><td style="text-align:center">-128~127</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2个字节 (16bit)</td><td style="text-align:center">-2<sup>15</sup>~2<sup>15</sup>-1</td><td style="text-align:center">-32768~32767</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>int</strong></td><td style="text-align:center"><strong>4个字节 (32bit) </strong></td><td style="text-align:center"><strong> -2<sup>31</sup>~2<sup>31</sup>-1</strong></td><td style="text-align:center"><strong>-2147483648~2147483647</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8个字节 (64bit)</td><td style="text-align:center">-2<sup>63</sup>~2<sup>63</sup>-1</td><td style="text-align:center">-9223372036854774808~9223372036854774807</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1个字节 (8bit)</td><td style="text-align:center">ture，false</td><td style="text-align:center"></td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2个字节 (16bit)</td><td style="text-align:center">0~2<sup>16</sup>-1</td><td style="text-align:center"></td><td style="text-align:center">‘\u0000’</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4个字节 (32bit)</td><td style="text-align:center">2<sup>-149</sup>~2<sup>128</sup>-1</td><td style="text-align:center">1.4013E-45~3.4028E+38</td><td style="text-align:center">0.0F</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8个字节 (64bit)</td><td style="text-align:center">2<sup>-1074</sup>~2<sup>1024</sup>-1</td><td style="text-align:center">4.9E-324~1.7977E+308</td><td style="text-align:center">0.0D</td></tr></tbody></table><p>int包装类为：java.lang.Integer。其余类型类似，均为类型大写首字母</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;占内存大小&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;取值范围&lt;/th&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/悲观锁与乐观锁/</id>
    <published>2018-04-04T13:34:13.000Z</published>
    <updated>2018-04-04T13:42:58.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。</p><p>2.乐观锁：即很乐观，查询数据的时候总觉得不会有人更改数据，等到更新的时候再判断这个数据有没有被人更改，有人更改了则本次更新失败。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h2><p>悲观锁的实现采用的数据库内部的锁机制，一个典型的倚赖数据库的悲观锁调用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"张三"</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>  这条sql 语句锁定了account 表中所有符合检索条件（name=”张三”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。也就是我们可以在查询数据的时候先用for update把这条数据锁住，然后更改完这条数据再提交。这样别的线程没法更新这条数据，也就保证了不会丢失更新。</p><p>悲观锁带来的性能问题。我们试想一个场景：如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果？所以我们这个时候可以使用乐观锁。</p><p><strong>优点与不足</strong></p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p><h2 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h2><p>乐观锁的实现可以通过在表里面加一个版本号的形式，每个人更新的时候都会判断当前的版本号是否跟我查询出来得到的版本号是否一致，不一致就更新失败，一致就更新这条记录并更改版本号。</p><p><strong>优点与不足</strong></p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。
      
    
    </summary>
    
      <category term="数据库" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>synchronized与Lock的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/synchronized与Lock的区别/</id>
    <published>2018-04-04T13:07:54.000Z</published>
    <updated>2018-04-17T06:51:36.029Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">synchronized</th><th style="text-align:center">Lock</th></tr></thead><tbody><tr><td style="text-align:center">存在层次</td><td style="text-align:center">Java的关键字，在jvm层面上</td><td style="text-align:center">是一个类</td></tr><tr><td style="text-align:center">锁的释放</td><td style="text-align:center">1、已获取锁的线程执行完同步代码会释放锁  2、线程执行发生异常，jvm会让线程释放锁</td><td style="text-align:center">需在finally中手工释放锁（unlock()方法释放锁），不然容易造成线程死锁</td></tr><tr><td style="text-align:center">锁的获取</td><td style="text-align:center">假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td><td style="text-align:center">分情况而定，如果尝试获取不到锁，线程可以不用一直等待</td></tr><tr><td style="text-align:center">锁状态</td><td style="text-align:center">无法判断是否获取到锁</td><td style="text-align:center">可以判断是否获取到锁</td></tr><tr><td style="text-align:center">锁类型</td><td style="text-align:center">可重入 不可中断  非公平</td><td style="text-align:center">可重入 可中断 可公平（两者皆可）</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">适合代码少量的同步问题</td><td style="text-align:center">适合代码大量的同步问题</td></tr></tbody></table><p>  <strong>synchronized与lock的区别 </strong></p><ul><li>（用法）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 </li><li>（用法）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。 </li><li>（性能）synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。 </li><li>（机制）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compareand Swap）。</li></ul><p><strong>synchronized底层如何实现的？用在代码块和方法上有什么区别？</strong></p><ul><li>synchronized用在代码块锁的是调用该方法的对象（this），也可以选择锁住任何一个对象。 </li><li>synchronized用在方法上锁的是调用该方法的对象， </li><li>synchronized用在代码块可以减小锁的粒度，从而提高并发性能。 </li><li>无论用在代码块上还是用在方法上，都是获取对象的锁；每一个对象只有一个锁与之相关联；实现同步需要很大的系统开销作为代价，甚至可能造成死锁，所以尽量避免无谓的同步控制。 </li></ul><p> <strong>两种锁的底层实现方式： </strong></p><p> <strong>synchronized：</strong></p><p>我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。 </p><p>其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。</p><p><strong>那有两个monitorexit呀？</strong>synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。</p><p><strong>Lock：</strong></p><p>Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。</p><p><strong>尽可能去使用synchronized而不要去使用LOCK</strong></p><p><strong>synchronized与static synchronized的区别 </strong></p><ul><li>synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized块，同一个类的两个不同实例就没有这种约束了。 </li><li>那么static synchronized恰好就是要控制类的所有实例的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。 </li></ul><p>CAS（Compareand Swap）原理：CAS有三个操作数，即内存值v,旧的预期值a,新的操作数b。当我们需要更新v值为b时，首先我们判断v值是否和我们之前的所见值a相同，若相同则将v赋值为b，若不同，则什么都不做。是一种非阻塞算法（non-blocking algorithm）。</p><p>非阻塞算法（nonblocking algorithms）:一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;synchronized&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Loc
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>List接口的实现类--ArrayList、LinkedList、Vector之间的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB-ArrayList%E3%80%81LinkedList%E3%80%81Vector%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/List接口的实现类-ArrayList、LinkedList、Vector之间的区别/</id>
    <published>2018-04-04T11:54:20.000Z</published>
    <updated>2018-04-04T12:27:02.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set</p><p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长。</p><p>ArrayList不是线程安全的，只能用在单线程环境下。</p><p>允许元素为null</p><p>实现了Serializable接口，因此它支持序列化，能够通过序列化传输；</p><p>实现了RandomAccess接口，支持快速随机访问，可以以O(1)的时间复杂度去根据下标访问元素，实际上就是通过下标序号进行快速访问；</p><p>实现了Cloneable接口，能被克隆。</p><p>因其底层数据结构是数组，它<strong>占据了一块连续的内存空间</strong>（容量就是数组的length），所以它也有数组的缺点，<strong>空间效率不高</strong>。</p><p>由于数组的内存连续，可以根据下标以O(1)的时间<strong>读写(改查)</strong>元素，因此<strong>时间效率很高</strong>。</p><p><strong>初始化</strong></p><p>首先有三种方式来初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>默认的构造器，将会以默认的大小来初始化内部的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure><p>用一个ICollection对象来构造，并将该集合的元素添加到ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br></pre></td></tr></table></figure><h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>使用无参构造方法时系统会默认提供默认参数10，而使用有参构造函数时我们会指定大小。在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组（通常为原数组的1.5倍）（当第一次插入元素时分配10个对象空间。假如有20个数据需要添加，那么会分别在第一次的时候，将ArrayList的容量变为10；之后扩容会按照1.5倍增长。也就是当添加第11个数据的时候，Arraylist继续扩容变为10 <em> 1.5=15，当添加第16个数据时，继续扩容变为15 </em> 1.5 =22个），旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组指向了新的数组。</p><p>扩容操作也是ArrayList 的一个性能消耗比较大的地方，所以若<strong>我们可以提前预知数据的规模</strong>，应该通过public ArrayList(int initialCapacity) {}构造方法，指定集合的大小，去构建ArrayList实例<strong>，以减少扩容次数，提高效率</strong>。</p><p>或者在需要扩容的时候，手动调用public void ensureCapacity(intminCapacity) {}方法扩容。 </p><p>不过该方法是ArrayList的API，不是List接口里的，所以使用时需要强转: </p><p>((ArrayList)list).ensureCapacity(30);</p><h1 id="ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）"><a href="#ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）" class="headerlink" title="ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）"></a>ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）</h1><p>1.List是接口类，ArrayList和LinkedList是List的实现类。</p><p>2.ArrayList是动态数组（顺序表）的数据结构。顺序表的存储地址是连续的，所以在查找比较快，但是在插入和删除时，由于需要把其它的元素顺序向后移动（或向前移动），所以比较耗时。</p><p>3.LinkedList是链表的数据结构。链表的存储地址是不连续的，每个存储地址通过指针指向，在查找时需要进行通过指针遍历元素，所以在查找时比较慢。由于链表插入时不需移动其它元素，所以在插入和删除时比较快。</p><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p><p>在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。</p><h1 id="ArrayList和LinkedList的时间复杂度"><a href="#ArrayList和LinkedList的时间复杂度" class="headerlink" title="ArrayList和LinkedList的时间复杂度"></a>ArrayList和LinkedList的时间复杂度</h1><p>ArrayList 是线性表（数组）</p><p>get()：直接读取第几个下标，复杂度 O(1)</p><p>add(E) ：添加元素，直接在后面添加，复杂度O（1）</p><p>add(index, E) ：添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）</p><p>remove（）：删除元素，后面的元素需要逐个移动，复杂度O（n）</p><p>LinkedList 是链表的操作</p><p>get()：获取第几个元素，依次遍历，复杂度O(n)</p><p>add(E) ：添加到末尾，复杂度O(1)</p><p>add(index, E) ：添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)</p><p>remove（）：删除元素，直接指针指向操作，复杂度O(1)</p><h1 id="如何复制某个ArrayList到另一个ArrayList中去？"><a href="#如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="如何复制某个ArrayList到另一个ArrayList中去？"></a>如何复制某个ArrayList到另一个ArrayList中去？</h1><p>1.使用clone()方法，比如ArrayList newArray = oldArray.clone();</p><p>2.使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject);</p><p>3.使用Collections的copy方法。</p><p>注意1和2是浅拷贝(shallowcopy)。</p><h1 id="ArrayList为什么是线程不安全的？"><a href="#ArrayList为什么是线程不安全的？" class="headerlink" title="ArrayList为什么是线程不安全的？"></a>ArrayList为什么是线程不安全的？</h1><p>ArrayList在添加一个元素的时候，它可能会有两步来完成：</p><ol><li>在 Items[Size] 的位置存放此元素；</li><li>增大 Size 的值。</li></ol><p>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p><p>用Collections.synchronizedList可以把一个普通ArrayList包装成一个线程安全版本的数组容器，原理同Vector是一样的，就是给所有的方法套上一层synchronized。</p><h1 id="ArrayList和Vector的区别？"><a href="#ArrayList和Vector的区别？" class="headerlink" title="ArrayList和Vector的区别？"></a>ArrayList和Vector的区别？</h1><p>ArrayList和Vector都实现了list接口，都是数组实现；</p><p>区别在于Vector在API上都加了synchronized所以它是线程安全的，以及Vector扩容时，是扩容100%，而ArrayList是扩容50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p> Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Collection&lt;br&gt;├List&lt;br&gt;│├LinkedList&lt;br&gt;│├ArrayList&lt;br&gt;│└Vector&lt;br&gt;│　└S
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java代码执行顺序</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/Java代码执行顺序/</id>
    <published>2018-04-04T08:41:44.000Z</published>
    <updated>2018-04-04T08:56:57.835Z</updated>
    
    <content type="html"><![CDATA[<p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person构造方法"</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Student静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Student构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        System.out.println(<span class="string">"执行Student构造方法"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"执行Student无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsStaticConstruct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"ABC"</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">执行Person静态代码块</span><br><span class="line">执行Student静态代码块</span><br><span class="line">执行Person构造代码块</span><br><span class="line">执行Person构造方法ABC</span><br><span class="line">执行Student构造代码块</span><br><span class="line">执行Student构造方法ABC</span><br><span class="line">--------------------</span><br><span class="line">执行Person构造代码块</span><br><span class="line">执行Person无参构造方法</span><br><span class="line">执行Student构造代码块</span><br><span class="line">执行Student无参构造方法</span><br></pre></td></tr></table></figure><p>说明：<br>一般的类里面包含：<br>1、静态代码块（静态区、静态变量等）<br>2、构造代码块（{ }中间的内容）<br>3、构造方法</p><p>其执行顺序也是1、2、3先后执行，这里需要注意的是：考虑继承特性。<br>子类与父类的执行顺序是：<br>1、先执行父类的静态代码块（父1）<br>2、子类的静态代码块（子1）<br>3、父类构造代码块（父2）<br>4、父类构造方法（父3）<br>5、子类构造代码块（子2）<br>6、子类构造方法（子3）</p><p>当一个类从被JVM装载开始，各种代码的执行顺序大致如下：</p><p>被JVM装载-&gt;<br>执行父类的相关代码-&gt;<br>如果有静态初始化，先执行静态初始化，且只执行一次，以后即使有该类实例化，也不会再执行-&gt;<br>如果有静态代码块，以与静态初始化一样的方式执行-&gt;<br>如果有new语句带来的实例化，先为成员变量分配空间，并绑定参数列表，隐式或显式执行super()，即父类的构造方法-&gt;<br>执行非静态代码块-&gt;<br>执行本类的构造函数-&gt;<br>执行其他代码。</p><p>这里的执行顺序同子类构造中有一个默认的父类构造super()无关，不是执行到隐藏的super()才开始初始化父类的，类的初始化是分层初始化，即先初始化父类，再初始化子类，初始化每个类的过程中，进行类的初始化工作，先进性成员变量的初始化，成员变量的初始化顺序是：默认初始化，即int为0这种－&gt;显示初始化，例如给int型显示初始化了值－&gt;构造方法初始化，所以是这里执行到了构造方法。</p><p>但是一定要注意，父类初始化选择的构造方法却和子类中super 选择的构造相关。</p><p>转载自：<a href="https://blog.csdn.net/wuhaiwei002/article/details/55226155" target="_blank" rel="noopener">https://blog.csdn.net/wuhaiwei002/article/details/55226155</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashTable、HashMap和ConCurrentHashMap区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/HashTable%E3%80%81HashMap%E5%92%8CConCurrentHashMap%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/HashTable、HashMap和ConCurrentHashMap区别/</id>
    <published>2018-04-04T08:19:04.000Z</published>
    <updated>2018-04-15T07:37:24.304Z</updated>
    
    <content type="html"><![CDATA[<p>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p><h1 id="HashMap和HashTable的对比"><a href="#HashMap和HashTable的对比" class="headerlink" title="HashMap和HashTable的对比"></a>HashMap和HashTable的对比</h1><p> <strong>1.HashMap是非线程安全的，HashTable是线程安全的。</strong></p><p>Hashtable中的线程安全是Synchronize的（sychronized意味着在一次仅有一个线程能够更改Hashtable，就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable）；而HashMap中的方法在缺省情况下是非Synchronize的。所以在单线程环境下Hashtable比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</p><p>在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理：</p><p>Map m =Collections.synchronizedMap(new HashMap(…))。</p><p><strong>2.HashMap的键和值都允许有null存在，而HashTable则都不行。</strong></p><p><strong>3.因为线程安全、哈希效率的问题，HashMap效率比HashTable的要高。</strong></p><p><strong>4.哈希值的使用不同</strong></p><p>HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><p><strong>5.内部实现使用的数组初始化和扩容方式不同</strong></p><p>HashMap默认初始化数组的大小为16，要求底层数组的容量一定要为2的整数次幂，HashTable为11。HashMap扩容时乘2，使用位运算取得哈希，效率高于取模。而HashTable为乘2加1，都是素数和奇数，这样取模哈希结果更均匀。</p><p>6.继承的父类不同</p><p>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。</p><p>7.两个遍历方式的内部实现上不同</p><p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。</p><p>8.是否提供contains方法</p><p>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。</p><p>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。</p><h1 id="HashTable和ConCurrentHashMap的对比"><a href="#HashTable和ConCurrentHashMap的对比" class="headerlink" title="HashTable和ConCurrentHashMap的对比"></a>HashTable和ConCurrentHashMap的对比</h1><p>ConcurrentHashMap引入了分割(Segment)，把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。</p><h1 id="HashMap和ConCurrentHashMap的对比"><a href="#HashMap和ConCurrentHashMap的对比" class="headerlink" title="HashMap和ConCurrentHashMap的对比"></a>HashMap和ConCurrentHashMap的对比</h1><p>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。</p><p>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p><h1 id="Concurrent-HashMap-线程安全吗，-Concurrent-HashMap如何保证-线程安全？"><a href="#Concurrent-HashMap-线程安全吗，-Concurrent-HashMap如何保证-线程安全？" class="headerlink" title="Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？"></a>Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</h1><ul><li>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 </li><li>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读。get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。 </li><li>Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Map&lt;br&gt;├Hashtable&lt;br&gt;├HashMap&lt;br&gt;└WeakHashMap&lt;/p&gt;
&lt;h1 id=&quot;HashMap和HashTable的对比&quot;&gt;&lt;a href=&quot;#HashMap和HashTable的对比&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/排序算法/</id>
    <published>2018-04-03T13:18:20.000Z</published>
    <updated>2018-04-04T06:58:22.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p><strong>内排序有可以分为以下几类：</strong></p><p>(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。<br>(2)、选择排序：简单选择排序、堆排序。<br>(3)、交换排序：冒泡排序、快速排序。<br>(4)、归并排序<br>(5)、基数排序</p><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">平均情况</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">shell排序</td><td style="text-align:center">O(n<sup>1.3</sup>)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(d(r+n))</td><td style="text-align:center">O(d(r+rd))</td><td style="text-align:center">O(d(r+n))</td><td style="text-align:center">O(rd+n)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">注：基数排序</td><td style="text-align:center">r表示关键字的基数</td><td style="text-align:center">d代表长度</td><td style="text-align:center">n代表关键字的个数</td><td style="text-align:center"></td><td style="text-align:center">-</td></tr></tbody></table><h1 id="O（n2）排序"><a href="#O（n2）排序" class="headerlink" title="O（n2）排序"></a>O（n<sup>2</sup>）排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>基本思想：</strong>比较数组相邻的两个值，把大的像泡泡一样“冒”到数组后面去，一共要执行N的平方除以2这么多次的比较和交换的操作（N为数组元素），其复杂度为Ο(n²)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外层循环控制排序趟数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;<span class="comment">//内层循环控制每一趟排序多少次</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;<span class="comment">//初始下标为i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[index])&#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != i)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">           arr[index] = arr[i];</span><br><span class="line">           arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>基本思想：</strong>每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;<span class="comment">// 从数组的第二个元素开始循环将数组中的元素插入</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];<span class="comment">// 设置数组中的第2个元素为第一次循环要插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">               a[j + <span class="number">1</span>] = a[j];<span class="comment">// 如果要插入的元素小于第j个元素,就将第j个元素向后移动</span></span><br><span class="line">               j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = temp;<span class="comment">// 直到要插入的元素不小于第j个元素,将temp插入到数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><p><strong>基本思想：</strong>本质是插入排序，通过将数组数组的方式来将增加排序的速度，分组的方式第一次将数组的长度/2,第二次/4,当结果等于1的时候，那么将这个数组进行插入排序就完成了排序，当然分组时也是需要排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 将数组分组  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> temp = a.length / <span class="number">2</span>; temp &gt;= <span class="number">1</span>; temp /= <span class="number">2</span>) &#123;  </span><br><span class="line">        <span class="comment">// 这里的思路和插入排序的思路相同，通过找到前一个的数大于或者小于来进行插入  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp; i &lt; a.length; i += temp) &#123;  </span><br><span class="line">            <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">            <span class="keyword">int</span> j = i - temp;  </span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;  </span><br><span class="line">                a[j + temp] = a[j];  </span><br><span class="line">                j -= temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            a[j + temp] = temp; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="O（nlog2n）排序"><a href="#O（nlog2n）排序" class="headerlink" title="O（nlog2n）排序"></a>O（nlog<sub>2</sub>n）排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high,temp = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>( arr[j] &gt;= temp &amp;&amp; i &lt; j)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt;= temp &amp;&amp; i &lt; j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">    quickSort(arr,low,j-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,j+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>（1）稳定性：</strong>归并排序是一种稳定的排序。<br><strong>（2）存储结构要求：</strong>可用顺序存储结构。也易于在链表上实现。<br><strong>（3）时间复杂度：</strong>对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。<br><strong>（4）空间复杂度：</strong>需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。</p><p><strong>注意：</strong>若用单链表做存储结构，很容易给出就地的归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">            <span class="comment">//左右归并</span></span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i= low;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把左边剩余的数移入数组 </span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] = temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">        <span class="comment">//循环建堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//建堆</span></span><br><span class="line">            buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">            <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">            swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对data数组从0到lastIndex建大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//k保存正在判断的节点</span></span><br><span class="line">            <span class="keyword">int</span> k=i;</span><br><span class="line">            <span class="comment">//如果当前k节点的子节点存在</span></span><br><span class="line">            <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">                <span class="comment">//k节点的左子节点的索引</span></span><br><span class="line">                <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span></span><br><span class="line">                <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                    <span class="comment">//若果右子节点的值较大</span></span><br><span class="line">                    <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="comment">//biggerIndex总是记录较大子节点的索引</span></span><br><span class="line">                        biggerIndex++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果k节点的值小于其较大的子节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                    <span class="comment">//交换他们</span></span><br><span class="line">                    swap(data,k,biggerIndex);</span><br><span class="line">     <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span></span><br><span class="line">                    k=biggerIndex;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">        data[i]=data[j];</span><br><span class="line">        data[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"><span class="comment">// 各位装通法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = n;</span><br><span class="line">        <span class="keyword">int</span> divisor = <span class="number">1</span>;<span class="comment">// 定义每一轮的除数，1,10,100...</span></span><br><span class="line">        <span class="comment">//定义了10个桶，以防每一位都一样全部放入一个桶中</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">// 统计每个桶中实际存放的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> digit;<span class="comment">// 获取元素中对应位上的数字，即装入那个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;<span class="comment">// 经过4次装通操作，排序完成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> temp : A) &#123;<span class="comment">// 计算入桶</span></span><br><span class="line">                digit = (temp / divisor) % <span class="number">10</span>;</span><br><span class="line">                bucket[digit][count[digit]++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// 被排序数组的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">10</span>; b++) &#123;<span class="comment">// 从0到9号桶按照顺序取出</span></span><br><span class="line">                <span class="keyword">if</span> (count[b] == <span class="number">0</span>)<span class="comment">// 如果这个桶中没有元素放入，那么跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; count[b]; w++) &#123;</span><br><span class="line">                    A[k++] = bucket[b][w];</span><br><span class="line">                &#125;</span><br><span class="line">                count[b] = <span class="number">0</span>;<span class="comment">// 桶中的元素已经全部取出，计数器归零</span></span><br><span class="line">            &#125;</span><br><span class="line">            divisor *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1.若n较小(如n≤50)，可采用直接插入或直接选择排序。<br>    　当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。<br>2.若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；<br>3.若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。<br>4.快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>5.堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。<br>6.若要求排序稳定，则可选用归并排序。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;内排序有可以分为以下几类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。&lt;br
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的工作原理</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/HashMap的工作原理/</id>
    <published>2018-04-03T10:28:28.000Z</published>
    <updated>2018-04-03T13:03:58.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”"><a href="#“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”" class="headerlink" title="“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”"></a>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</h1><p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p><h1 id="“你知道HashMap的工作原理吗？”-“你知道HashMap的get-方法的工作原理吗？”"><a href="#“你知道HashMap的工作原理吗？”-“你知道HashMap的get-方法的工作原理吗？”" class="headerlink" title="“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”"></a>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</h1><p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p><h1 id="“当两个对象的hashcode相同会发生什么？”"><a href="#“当两个对象的hashcode相同会发生什么？”" class="headerlink" title="“当两个对象的hashcode相同会发生什么？”"></a>“当两个对象的hashcode相同会发生什么？”</h1><p> 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。</p><h1 id="“如果两个键的hashcode相同，你如何获取值对象？”"><a href="#“如果两个键的hashcode相同，你如何获取值对象？”" class="headerlink" title="“如果两个键的hashcode相同，你如何获取值对象？”"></a>“如果两个键的hashcode相同，你如何获取值对象？”</h1><p>面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p><p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p><p>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><h1 id="“如果HashMap的大小超过了负载因子-loadfactor-定义的容量，怎么办？”"><a href="#“如果HashMap的大小超过了负载因子-loadfactor-定义的容量，怎么办？”" class="headerlink" title="“如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”"></a>“如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”</h1><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p><p>散列表的hash算法是根据移位来进行计算的，只能是进行＊2或者／2。因此，扩容的大小要符合这个标准，否则会造成没必要的浪费甚至错误。扩容的成本并不低，因为需要遍历一个时间复杂度为O(n)的数组，并且为其中的每个enrty进行hash计算。加入到新数组中，所以最好的情况是能够合理的使用HashMap的构造方法创建合适大小的HashMap，使得在不浪费内存的情况下，尽量减少扩容，这个就要根据业务来决定了。</p><h1 id="“你了解重新调整HashMap大小存在什么问题吗？”"><a href="#“你了解重新调整HashMap大小存在什么问题吗？”" class="headerlink" title="“你了解重新调整HashMap大小存在什么问题吗？”"></a>“你了解重新调整HashMap大小存在什么问题吗？”</h1><p>你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(racecondition)。</p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？</p><p>热心的读者贡献了更多的关于HashMap的问题：</p><ol><li><strong>为什么String,Interger这样的wrapper类适合作为键？</strong> String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</li><li><strong>我们可以使用自定义的对象作为键吗？</strong> 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</li><li><strong>我们可以使用CocurrentHashMap来代替Hashtable吗？</strong>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</li></ol><p>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p><ul><li><strong>hashing的概念</strong></li><li><strong>HashMap中解决碰撞的方法</strong></li><li><strong>equals()和hashCode()的应用，以及它们在HashMap中的重要性</strong></li><li><strong>不可变对象的好处</strong></li><li><strong>HashMap多线程的条件竞争</strong></li><li><strong>重新调整HashMap的大小</strong></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p><strong>1. 什么时候会使用HashMap？它有什么特点？</strong></p><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><p><strong>2.HashMap的工作原理 </strong> </p><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将Key传给get()方法，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap在每个链表节点中储存键值对对象。</p><p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？HashMap中解决碰撞的方法</strong></p><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。</p><p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。</p><p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法计算index，把节点再放到新的bucket中。</p><p><strong>6.当两个不同的键对象的hashcode相同时会发生什么？</strong> </p><p>它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p><p>转载自：<a href="http://www.importnew.com/10620.html" target="_blank" rel="noopener">http://www.importnew.com/10620.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”&quot;&gt;&lt;a href=&quot;#“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”&quot; class=&quot;headerlink&quot; title=&quot;“你用过HashMap吗？” “什么是H
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello,My Blog</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/02/Hello-My-Blog/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/02/Hello-My-Blog/</id>
    <published>2018-04-02T13:17:30.000Z</published>
    <updated>2018-04-02T13:49:41.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><b>纵有疾风起，人生不言弃<b></b></b></p></blockquote><a id="more"></a><p>花了一天半的时间终于开通了自己的博客。参照网上教程从下载Node.js、Hexo到下载博客模板、调试、配置成自己想要的样子，以及学这个Markdown语法，中间也遇到了一些小小的Bug，有些百度出来了，有的自己解决了，有的还没解决就只能小小的掩盖一下，以后慢慢学习，不断进步，慢慢解决吧。</p><p>虽然是借用了Hexo的模板，并挂在Github上的免费博客，但还是希望自己以后能坚持写下去，能将学习过程中的点点滴滴都能记录下来！纵有疾风起，人生不言弃！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;b&gt;纵有疾风起，人生不言弃&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/01/hello-world/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/01/hello-world/</id>
    <published>2018-04-01T15:50:22.104Z</published>
    <updated>2018-04-01T15:50:22.104Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
