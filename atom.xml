<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bameirilyo&#39;s Blog</title>
  
  <subtitle>纵有疾风起，人生不言弃</subtitle>
  <link href="/BameirilyoBlog/atom.xml" rel="self"/>
  
  <link href="https://bameirilyo.github.io/BameirilyoBlog/"/>
  <updated>2018-04-05T14:47:44.235Z</updated>
  <id>https://bameirilyo.github.io/BameirilyoBlog/</id>
  
  <author>
    <name>豆腐小铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程和进程的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/线程和进程的区别/</id>
    <published>2018-04-05T14:27:48.000Z</published>
    <updated>2018-04-05T14:47:44.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入进程之前–多道程序设计"><a href="#引入进程之前–多道程序设计" class="headerlink" title="引入进程之前–多道程序设计"></a>引入进程之前–多道程序设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>多道程序设计技术</strong>是操作系统最早引入的技术，它的设计思想是允多个程序<strong>同时</strong>进入内存并运行，其目的是为了CPU的利用率，进而提高系统效率。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>多道程序设计技术引入之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。而多道程序设计技术允许多个程序同时进入内存并运行，那就要每个程序分配程序计数器。如果内存中有四个程序在并发执行，那就需要四个程序计数器。</p><h2 id="新技术带来的问题"><a href="#新技术带来的问题" class="headerlink" title="新技术带来的问题"></a>新技术带来的问题</h2><p>一个技术、一个机制的引入，一方面解决了以前棘手的问题，但同时，往往带来新的问题。多道程序设计技术也是如此。</p><blockquote><p>多道程序设计技术允许多个程序同时进入内存并运行，在这样的并发环境下，如何描述、刻画这样执行的程序呢？因此引入了“进程”。</p></blockquote><h1 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程是具有独立功能的程序关于<strong>某个数据集合上</strong>的<strong>一次运行活动</strong>，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。</li><li>进程是是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象。（虚拟技术的支持，将一个CPU变幻为多个虚拟的CPU）</li><li>系统资源（如内存、文件）以进程为单位分配。</li><li><strong>操作系统为每个进程分配了独立的地址空间</strong></li><li>操作系统通过“调度”把控制权交给进程。</li></ul><blockquote><p>为什么引入线程 有了进程这概念之后 应用程序可以并发地去执行了 那么为什么要在进程当中再派生出线程呢？ </p></blockquote><h2 id="为什么引入线程？"><a href="#为什么引入线程？" class="headerlink" title="为什么引入线程？"></a>为什么引入线程？</h2><p>首先我们引入了进程这个概念，虽然进程<strong>有利于资源的管理和保护</strong>。然而在实际应用中，进程有这样的问题： </p><ol><li>进程切换的代价、开销比较大； </li><li>在一个进程内也需要并行执行多个程序，实现不同的功能。 </li><li>进程有时候性能比较低。</li></ol><blockquote><p>引入线程有以下三个方面的考虑</p></blockquote><ol><li><strong>应用的需要</strong>。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。</li><li><strong>开销的考虑</strong>。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件）</li><li><strong>性能的考虑</strong>。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。 </li></ol><h1 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程(Thread)"></a>线程(Thread)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>有标识符ID</li><li>有状态及状态转换，所以需要提供一些状态转换操作</li><li>不运行时需要保存上下文环境，所以需要程序计数器等寄存器</li><li>有自己的栈和栈指针</li><li>共享所在进程的地址空间和其它资源</li></ul><h1 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h1><p><strong>1.定义方面：进程是程序在某个数据集合上的一次运行活动，有独立的地址空间；线程是进程中的一个执行路径。（进程可以创建多个线程）</strong></p><p><strong>2.角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位。</strong></p><p>​    总线程数&lt;= CPU数量：并行运行 </p><p>​    总线程数&gt; CPU数量：并发运行 </p><p><strong>3.资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。</strong></p><p><strong>4.独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。</strong></p><p><strong>5.开销方面。进程切换的开销较大。线程相对较小。（前面也提到过，引入线程也出于了开销的考虑。）</strong></p><p>线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><h1 id="Read-more"><a href="#Read-more" class="headerlink" title="Read more"></a>Read more</h1><p><a href="https://discuss.leetcode.com/topic/90877/process-vs-thread" target="_blank" rel="noopener">Process Vs Thread</a></p><p><a href="http://www.differencebetween.info/difference-between-process-and-thread" target="_blank" rel="noopener">Difference between Process and Thread</a> </p><p><a href="http://www.java67.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="noopener">what is different between thread and process</a></p><p><a href="http://www.cnblogs.com/zl1991/p/6867985.html" target="_blank" rel="noopener">理解Android进程创建流程（转）</a></p><p>本文转载整理自：</p><p><a href="http://blog.csdn.net/zheng548/article/details/54669908" target="_blank" rel="noopener">http://blog.csdn.net/zheng548/article/details/54669908</a></p><p><a href="https://blog.csdn.net/robbyo/article/details/8549904" target="_blank" rel="noopener">https://blog.csdn.net/robbyo/article/details/8549904</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入进程之前–多道程序设计&quot;&gt;&lt;a href=&quot;#引入进程之前–多道程序设计&quot; class=&quot;headerlink&quot; title=&quot;引入进程之前–多道程序设计&quot;&gt;&lt;/a&gt;引入进程之前–多道程序设计&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java后端技术</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java后端技术/</id>
    <published>2018-04-05T13:57:36.000Z</published>
    <updated>2018-04-05T15:41:53.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>后端主要的技术：</strong></p><p><strong>服务框架：Dubbo，zookeeper，Rest服务</strong><br><strong>缓存：redis，ehcache</strong><br><strong>消息中间件：ActiveMQ，kafka</strong><br><strong>负责均衡：Nginx</strong><br><strong>分布式文件：FastDFS</strong><br><strong>安全框架：Apache shiro</strong><br><strong>任务调度：quartz</strong><br><strong>持久层框架：mybatis</strong><br><strong>日志：log4j</strong><br><strong>项目基础搭建。spring，springmvc</strong><br><strong>环境搭建：linux下</strong><br><strong>开发工具：eclipse，idea等</strong><br><strong>服务器：tomcat，jetty等</strong></p><p><strong>目前系统主流搭建：Nginx+tomcat+mybatis+redis。</strong><br>针对不同的业务需求，我们会引用不同的技术。</p><p>这些主要定位于互联网企业架构</p><p>框架简介：</p><p>企业信息化系统基础功能和高效的代码生成工具，包括:</p><p>系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、</p><p>平台简介：</p><p>是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。</p><p>本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。</p><p>使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。</p><p>以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。</p><p>前端集成bootstrap 框架。响应式</p><p>目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务）</p><p>提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。</p><p>内置功能(只列了一部分功能)</p><p>1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。</p><p>2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。</p><p>3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。</p><p>4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。</p><p>5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。</p><p>6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。</p><p>7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。</p><p>8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。</p><p>9.工作流引擎：实现业务工单流转、在线流程设计器。</p><p>开发工具</p><p>1.Eclipse IDE：采用Maven项目管理，模块化。</p><p>2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。</p><p>技术选型（只列了一部分技术）</p><p>1、后端</p><p>服务框架：Dubbo、zookeeper、Rest服务</p><p>缓存：Redis、ehcache</p><p>消息中间件：ActiveMQ</p><p>负载均衡：Nginx</p><p>分布式文件：FastDFS</p><p>数据库连接池：Alibaba Druid 1.0</p><p>核心框架：Spring framework</p><p>安全框架：Apache Shiro 1.2</p><p>视图框架：Spring MVC 4.0</p><p>服务端验证：Hibernate Validator 5.1</p><p>布局框架：SiteMesh 2.4</p><p>工作流引擎：Activiti 5.15</p><p>任务调度：quartz 1.8.5</p><p>持久层框架：MyBatis 3.2</p><p>日志管理：SLF4J 1.7、Log4j</p><p>工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI</p><p>2、前端</p><p>JS框架：JQuery 1.9。</p><p>CSS框架： Bootstrap 4 metronic</p><p>客户端验证：JQuery Validation Plugin。</p><p>富文本：CKEcitor</p><p>文件管理：CKFinder</p><p>动态页签：Jerichotab</p><p>数据表格：jqGrid</p><p>对话框：jQuery jBox</p><p>树结构控件：jQuery zTree</p><p>其他组件：Bootstrap 4 metronic</p><p>3、支持</p><p>服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8</p><p>数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等</p><p>支持开发环境：Eclipse、MyEclipse、Ras、Idea等。</p><p>本文转载自网络</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;后端主要的技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务框架：Dubbo，zookeeper，Rest服务&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;缓存：redis，ehcache&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;消息中间件：Activ
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>字符和字节的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E8%8A%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/字符和字节的区别/</id>
    <published>2018-04-05T13:42:35.000Z</published>
    <updated>2018-04-05T13:50:43.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“字节”的定义"><a href="#“字节”的定义" class="headerlink" title="“字节”的定义"></a>“字节”的定义</h1><p>字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。</p><h1 id="“字符”的定义"><a href="#“字符”的定义" class="headerlink" title="“字符”的定义"></a>“字符”的定义</h1><p>字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。</p><h1 id="“字节”与“字符”"><a href="#“字节”与“字符”" class="headerlink" title="“字节”与“字符”"></a>“字节”与“字符”</h1><p>它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同：</p><p>①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。</p><p>②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。</p><p>③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。<br>符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。</p><p>④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。</p><p>⑤UTF-32编码中，世界上任何字符的存储都需要4个字节</p><p>⑥通常在读取非文本文件时（如图片，声音，可执行文件）需要用字节数组来保存文件的内容，在下载文件时，也是用byte数组作临时的缓冲器接收文件内容。所以说byte在文件操作时是必不可少的。不管是对文件写入还是读取都要用到。byte在java中是一种是数据类型，代表一个字节，一个字节包含8个位，所以，byte类型的取值范围是-128到127。在某些程序中（尤其是和硬件有关的程序）会将某些数据存储到字节类型的变量中，比如00110010,其中每个位都代表一个参数，然后以位运算的方式对参数进行取值和赋值操作。</p><p>机器只知道字节，而字符却是语义上的单位，它是有编码的，一个字符可能编码成1个2个甚至3个4个字节。这跟字符集编码有关系，英文字母和数字是单字节，但汉字这些自然语言中的字符是多字节的。一个字节只能表示255个字符，不可能用于全球那么多种自然语言的处理，因此肯定需要多字节的存储方式。而InputStream, OutputStream它们是处理字节流的，就是说假设所有东西都是二进制的字节，而 Reader, Writer 则是字符流，它涉及到字符集的问题；按照ANSI编码标准，标点符号、数字、大小写字母都占一个字节，汉字占2个字节。按照UNICODE标准所有字符都占2个字节。</p><p>本文整理转载自网络</p><p>​                    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“字节”的定义&quot;&gt;&lt;a href=&quot;#“字节”的定义&quot; class=&quot;headerlink&quot; title=&quot;“字节”的定义&quot;&gt;&lt;/a&gt;“字节”的定义&lt;/h1&gt;&lt;p&gt;字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中基本类型的取值范围</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/05/Java中基本类型的取值范围/</id>
    <published>2018-04-05T13:03:09.000Z</published>
    <updated>2018-04-05T13:27:44.605Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">占内存大小</th><th style="text-align:center">取值范围</th><th style="text-align:center">数值范围</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1个字节 (8bit)</td><td style="text-align:center">-2<sup>7</sup>~2<sup>7</sup>-1</td><td style="text-align:center">-128~127</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2个字节 (16bit)</td><td style="text-align:center">-2<sup>15</sup>~2<sup>15</sup>-1</td><td style="text-align:center">-32768~32767</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>int</strong></td><td style="text-align:center"><strong>4个字节 (32bit) </strong></td><td style="text-align:center"><strong> -2<sup>31</sup>~2<sup>31</sup>-1</strong></td><td style="text-align:center"><strong>-2147483648~2147483647</strong></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8个字节 (64bit)</td><td style="text-align:center">-2<sup>63</sup>~2<sup>63</sup>-1</td><td style="text-align:center">-9223372036854774808~9223372036854774807</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1个字节 (8bit)</td><td style="text-align:center">ture，false</td><td style="text-align:center"></td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2个字节 (16bit)</td><td style="text-align:center">0~2<sup>16</sup>-1</td><td style="text-align:center"></td><td style="text-align:center">‘\u0000’</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4个字节 (32bit)</td><td style="text-align:center">2<sup>-149</sup>~2<sup>128</sup>-1</td><td style="text-align:center">1.4013E-45~3.4028E+38</td><td style="text-align:center">0.0F</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8个字节 (64bit)</td><td style="text-align:center">2<sup>-1074</sup>~2<sup>1024</sup>-1</td><td style="text-align:center">4.9E-324~1.7977E+308</td><td style="text-align:center">0.0D</td></tr></tbody></table><p>int包装类为：java.lang.Integer。其余类型类似，均为类型大写首字母</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;占内存大小&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;取值范围&lt;/th&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/悲观锁与乐观锁/</id>
    <published>2018-04-04T13:34:13.000Z</published>
    <updated>2018-04-04T13:42:58.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。</p><p>2.乐观锁：即很乐观，查询数据的时候总觉得不会有人更改数据，等到更新的时候再判断这个数据有没有被人更改，有人更改了则本次更新失败。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h2><p>悲观锁的实现采用的数据库内部的锁机制，一个典型的倚赖数据库的悲观锁调用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"张三"</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>  这条sql 语句锁定了account 表中所有符合检索条件（name=”张三”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。也就是我们可以在查询数据的时候先用for update把这条数据锁住，然后更改完这条数据再提交。这样别的线程没法更新这条数据，也就保证了不会丢失更新。</p><p>悲观锁带来的性能问题。我们试想一个场景：如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果？所以我们这个时候可以使用乐观锁。</p><p><strong>优点与不足</strong></p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p><h2 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h2><p>乐观锁的实现可以通过在表里面加一个版本号的形式，每个人更新的时候都会判断当前的版本号是否跟我查询出来得到的版本号是否一致，不一致就更新失败，一致就更新这条记录并更改版本号。</p><p><strong>优点与不足</strong></p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。
      
    
    </summary>
    
      <category term="数据库" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>synchronized与Lock的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/synchronized与Lock的区别/</id>
    <published>2018-04-04T13:07:54.000Z</published>
    <updated>2018-04-04T13:23:03.108Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">synchronized</th><th style="text-align:center">Lock</th></tr></thead><tbody><tr><td style="text-align:center">存在层次</td><td style="text-align:center">Java的关键字，在jvm层面上</td><td style="text-align:center">是一个类</td></tr><tr><td style="text-align:center">锁的释放</td><td style="text-align:center">1、已获取锁的线程执行完同步代码会释放锁  2、线程执行发生异常，jvm会让线程释放锁</td><td style="text-align:center">需在finally中手工释放锁（unlock()方法释放锁），不然容易造成线程死锁</td></tr><tr><td style="text-align:center">锁的获取</td><td style="text-align:center">假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td><td style="text-align:center">分情况而定，如果尝试获取不到锁，线程可以不用一直等待</td></tr><tr><td style="text-align:center">锁状态</td><td style="text-align:center">无法判断是否获取到锁</td><td style="text-align:center">可以判断是否获取到锁</td></tr><tr><td style="text-align:center">锁类型</td><td style="text-align:center">可重入 不可中断  非公平</td><td style="text-align:center">可重入 可判断 可公平（两者皆可）</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">适合代码少量的同步问题</td><td style="text-align:center">适合代码大量的同步问题</td></tr></tbody></table><p><strong>两种锁的底层实现方式： </strong></p><p> <strong>synchronized：</strong></p><p>我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。 </p><p>其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。</p><p><strong>那有两个monitorexit呀？</strong>synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。</p><p><strong>Lock：</strong></p><p>Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。</p><p><strong>尽可能去使用synchronized而不要去使用LOCK</strong></p><p>转载自：<a href="https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;synchronized&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Loc
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>List接口的实现类--ArrayList、LinkedList、Vector之间的区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB-ArrayList%E3%80%81LinkedList%E3%80%81Vector%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/List接口的实现类-ArrayList、LinkedList、Vector之间的区别/</id>
    <published>2018-04-04T11:54:20.000Z</published>
    <updated>2018-04-04T12:27:02.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set</p><p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长。</p><p>ArrayList不是线程安全的，只能用在单线程环境下。</p><p>允许元素为null</p><p>实现了Serializable接口，因此它支持序列化，能够通过序列化传输；</p><p>实现了RandomAccess接口，支持快速随机访问，可以以O(1)的时间复杂度去根据下标访问元素，实际上就是通过下标序号进行快速访问；</p><p>实现了Cloneable接口，能被克隆。</p><p>因其底层数据结构是数组，它<strong>占据了一块连续的内存空间</strong>（容量就是数组的length），所以它也有数组的缺点，<strong>空间效率不高</strong>。</p><p>由于数组的内存连续，可以根据下标以O(1)的时间<strong>读写(改查)</strong>元素，因此<strong>时间效率很高</strong>。</p><p><strong>初始化</strong></p><p>首先有三种方式来初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>默认的构造器，将会以默认的大小来初始化内部的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure><p>用一个ICollection对象来构造，并将该集合的元素添加到ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br></pre></td></tr></table></figure><h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>使用无参构造方法时系统会默认提供默认参数10，而使用有参构造函数时我们会指定大小。在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组（通常为原数组的1.5倍）（当第一次插入元素时分配10个对象空间。假如有20个数据需要添加，那么会分别在第一次的时候，将ArrayList的容量变为10；之后扩容会按照1.5倍增长。也就是当添加第11个数据的时候，Arraylist继续扩容变为10 <em> 1.5=15，当添加第16个数据时，继续扩容变为15 </em> 1.5 =22个），旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组指向了新的数组。</p><p>扩容操作也是ArrayList 的一个性能消耗比较大的地方，所以若<strong>我们可以提前预知数据的规模</strong>，应该通过public ArrayList(int initialCapacity) {}构造方法，指定集合的大小，去构建ArrayList实例<strong>，以减少扩容次数，提高效率</strong>。</p><p>或者在需要扩容的时候，手动调用public void ensureCapacity(intminCapacity) {}方法扩容。 </p><p>不过该方法是ArrayList的API，不是List接口里的，所以使用时需要强转: </p><p>((ArrayList)list).ensureCapacity(30);</p><h1 id="ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）"><a href="#ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）" class="headerlink" title="ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）"></a>ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）</h1><p>1.List是接口类，ArrayList和LinkedList是List的实现类。</p><p>2.ArrayList是动态数组（顺序表）的数据结构。顺序表的存储地址是连续的，所以在查找比较快，但是在插入和删除时，由于需要把其它的元素顺序向后移动（或向前移动），所以比较耗时。</p><p>3.LinkedList是链表的数据结构。链表的存储地址是不连续的，每个存储地址通过指针指向，在查找时需要进行通过指针遍历元素，所以在查找时比较慢。由于链表插入时不需移动其它元素，所以在插入和删除时比较快。</p><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p><p>在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。</p><h1 id="ArrayList和LinkedList的时间复杂度"><a href="#ArrayList和LinkedList的时间复杂度" class="headerlink" title="ArrayList和LinkedList的时间复杂度"></a>ArrayList和LinkedList的时间复杂度</h1><p>ArrayList 是线性表（数组）</p><p>get()：直接读取第几个下标，复杂度 O(1)</p><p>add(E) ：添加元素，直接在后面添加，复杂度O（1）</p><p>add(index, E) ：添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）</p><p>remove（）：删除元素，后面的元素需要逐个移动，复杂度O（n）</p><p>LinkedList 是链表的操作</p><p>get()：获取第几个元素，依次遍历，复杂度O(n)</p><p>add(E) ：添加到末尾，复杂度O(1)</p><p>add(index, E) ：添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)</p><p>remove（）：删除元素，直接指针指向操作，复杂度O(1)</p><h1 id="如何复制某个ArrayList到另一个ArrayList中去？"><a href="#如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="如何复制某个ArrayList到另一个ArrayList中去？"></a>如何复制某个ArrayList到另一个ArrayList中去？</h1><p>1.使用clone()方法，比如ArrayList newArray = oldArray.clone();</p><p>2.使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject);</p><p>3.使用Collections的copy方法。</p><p>注意1和2是浅拷贝(shallowcopy)。</p><h1 id="ArrayList为什么是线程不安全的？"><a href="#ArrayList为什么是线程不安全的？" class="headerlink" title="ArrayList为什么是线程不安全的？"></a>ArrayList为什么是线程不安全的？</h1><p>ArrayList在添加一个元素的时候，它可能会有两步来完成：</p><ol><li>在 Items[Size] 的位置存放此元素；</li><li>增大 Size 的值。</li></ol><p>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p><p>用Collections.synchronizedList可以把一个普通ArrayList包装成一个线程安全版本的数组容器，原理同Vector是一样的，就是给所有的方法套上一层synchronized。</p><h1 id="ArrayList和Vector的区别？"><a href="#ArrayList和Vector的区别？" class="headerlink" title="ArrayList和Vector的区别？"></a>ArrayList和Vector的区别？</h1><p>ArrayList和Vector都实现了list接口，都是数组实现；</p><p>区别在于Vector在API上都加了synchronized所以它是线程安全的，以及Vector扩容时，是扩容100%，而ArrayList是扩容50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p> Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Collection&lt;br&gt;├List&lt;br&gt;│├LinkedList&lt;br&gt;│├ArrayList&lt;br&gt;│└Vector&lt;br&gt;│　└S
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java代码执行顺序</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/Java代码执行顺序/</id>
    <published>2018-04-04T08:41:44.000Z</published>
    <updated>2018-04-04T08:56:57.835Z</updated>
    
    <content type="html"><![CDATA[<p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Person构造方法"</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Student静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行Student构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        System.out.println(<span class="string">"执行Student构造方法"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"执行Student无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsStaticConstruct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"ABC"</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">执行Person静态代码块</span><br><span class="line">执行Student静态代码块</span><br><span class="line">执行Person构造代码块</span><br><span class="line">执行Person构造方法ABC</span><br><span class="line">执行Student构造代码块</span><br><span class="line">执行Student构造方法ABC</span><br><span class="line">--------------------</span><br><span class="line">执行Person构造代码块</span><br><span class="line">执行Person无参构造方法</span><br><span class="line">执行Student构造代码块</span><br><span class="line">执行Student无参构造方法</span><br></pre></td></tr></table></figure><p>说明：<br>一般的类里面包含：<br>1、静态代码块（静态区、静态变量等）<br>2、构造代码块（{ }中间的内容）<br>3、构造方法</p><p>其执行顺序也是1、2、3先后执行，这里需要注意的是：考虑继承特性。<br>子类与父类的执行顺序是：<br>1、先执行父类的静态代码块（父1）<br>2、子类的静态代码块（子1）<br>3、父类构造代码块（父2）<br>4、父类构造方法（父3）<br>5、子类构造代码块（子2）<br>6、子类构造方法（子3）</p><p>当一个类从被JVM装载开始，各种代码的执行顺序大致如下：</p><p>被JVM装载-&gt;<br>执行父类的相关代码-&gt;<br>如果有静态初始化，先执行静态初始化，且只执行一次，以后即使有该类实例化，也不会再执行-&gt;<br>如果有静态代码块，以与静态初始化一样的方式执行-&gt;<br>如果有new语句带来的实例化，先为成员变量分配空间，并绑定参数列表，隐式或显式执行super()，即父类的构造方法-&gt;<br>执行非静态代码块-&gt;<br>执行本类的构造函数-&gt;<br>执行其他代码。</p><p>这里的执行顺序同子类构造中有一个默认的父类构造super()无关，不是执行到隐藏的super()才开始初始化父类的，类的初始化是分层初始化，即先初始化父类，再初始化子类，初始化每个类的过程中，进行类的初始化工作，先进性成员变量的初始化，成员变量的初始化顺序是：默认初始化，即int为0这种－&gt;显示初始化，例如给int型显示初始化了值－&gt;构造方法初始化，所以是这里执行到了构造方法。</p><p>但是一定要注意，父类初始化选择的构造方法却和子类中super 选择的构造相关。</p><p>转载自：<a href="https://blog.csdn.net/wuhaiwei002/article/details/55226155" target="_blank" rel="noopener">https://blog.csdn.net/wuhaiwei002/article/details/55226155</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashTable、HashMap和ConCurrentHashMap区别</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/HashTable%E3%80%81HashMap%E5%92%8CConCurrentHashMap%E5%8C%BA%E5%88%AB/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/04/HashTable、HashMap和ConCurrentHashMap区别/</id>
    <published>2018-04-04T08:19:04.000Z</published>
    <updated>2018-04-04T12:27:49.017Z</updated>
    
    <content type="html"><![CDATA[<p>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p><h1 id="HashMap和HashTable的对比"><a href="#HashMap和HashTable的对比" class="headerlink" title="HashMap和HashTable的对比"></a>HashMap和HashTable的对比</h1><p> <strong>1.HashMap是非线程安全的，HashTable是线程安全的。</strong></p><p>Hashtable中的线程安全是Synchronize的（sychronized意味着在一次仅有一个线程能够更改Hashtable，就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable）；而HashMap中的方法在缺省情况下是非Synchronize的。所以在单线程环境下Hashtable比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</p><p>在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理：</p><p>Map m =Collections.synchronizedMap(new HashMap(…))。</p><p><strong>2.HashMap的键和值都允许有null存在，而HashTable则都不行。</strong></p><p><strong>3.因为线程安全、哈希效率的问题，HashMap效率比HashTable的要高。</strong></p><p><strong>4.哈希值的使用不同</strong></p><p>HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><p><strong>5.内部实现使用的数组初始化和扩容方式不同</strong></p><p>HashMap默认初始化数组的大小为16，要求底层数组的容量一定要为2的整数次幂，HashTable为11。HashMap扩容时乘2，使用位运算取得哈希，效率高于取模。而HashTable为乘2加1，都是素数和奇数，这样取模哈希结果更均匀。</p><p>6.继承的父类不同</p><p>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。</p><p>7.两个遍历方式的内部实现上不同</p><p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。</p><p>8.是否提供contains方法</p><p>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。</p><p>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。</p><h1 id="HashTable和ConCurrentHashMap的对比"><a href="#HashTable和ConCurrentHashMap的对比" class="headerlink" title="HashTable和ConCurrentHashMap的对比"></a>HashTable和ConCurrentHashMap的对比</h1><p>ConcurrentHashMap引入了分割(Segment)，把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。</p><h1 id="HashMap和ConCurrentHashMap的对比"><a href="#HashMap和ConCurrentHashMap的对比" class="headerlink" title="HashMap和ConCurrentHashMap的对比"></a>HashMap和ConCurrentHashMap的对比</h1><p>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。</p><p>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Map&lt;br&gt;├Hashtable&lt;br&gt;├HashMap&lt;br&gt;└WeakHashMap&lt;/p&gt;
&lt;h1 id=&quot;HashMap和HashTable的对比&quot;&gt;&lt;a href=&quot;#HashMap和HashTable的对比&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/排序算法/</id>
    <published>2018-04-03T13:18:20.000Z</published>
    <updated>2018-04-04T06:58:22.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p><strong>内排序有可以分为以下几类：</strong></p><p>(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。<br>(2)、选择排序：简单选择排序、堆排序。<br>(3)、交换排序：冒泡排序、快速排序。<br>(4)、归并排序<br>(5)、基数排序</p><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">平均情况</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">shell排序</td><td style="text-align:center">O(n<sup>1.3</sup>)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(nlog<sub>2</sub>n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(d(r+n))</td><td style="text-align:center">O(d(r+rd))</td><td style="text-align:center">O(d(r+n))</td><td style="text-align:center">O(rd+n)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">注：基数排序</td><td style="text-align:center">r表示关键字的基数</td><td style="text-align:center">d代表长度</td><td style="text-align:center">n代表关键字的个数</td><td style="text-align:center"></td><td style="text-align:center">-</td></tr></tbody></table><h1 id="O（n2）排序"><a href="#O（n2）排序" class="headerlink" title="O（n2）排序"></a>O（n<sup>2</sup>）排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>基本思想：</strong>比较数组相邻的两个值，把大的像泡泡一样“冒”到数组后面去，一共要执行N的平方除以2这么多次的比较和交换的操作（N为数组元素），其复杂度为Ο(n²)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外层循环控制排序趟数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;<span class="comment">//内层循环控制每一趟排序多少次</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;<span class="comment">//初始下标为i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[index])&#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != i)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">           arr[index] = arr[i];</span><br><span class="line">           arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>基本思想：</strong>每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;<span class="comment">// 从数组的第二个元素开始循环将数组中的元素插入</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];<span class="comment">// 设置数组中的第2个元素为第一次循环要插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">               a[j + <span class="number">1</span>] = a[j];<span class="comment">// 如果要插入的元素小于第j个元素,就将第j个元素向后移动</span></span><br><span class="line">               j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = temp;<span class="comment">// 直到要插入的元素不小于第j个元素,将temp插入到数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><p><strong>基本思想：</strong>本质是插入排序，通过将数组数组的方式来将增加排序的速度，分组的方式第一次将数组的长度/2,第二次/4,当结果等于1的时候，那么将这个数组进行插入排序就完成了排序，当然分组时也是需要排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 将数组分组  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> temp = a.length / <span class="number">2</span>; temp &gt;= <span class="number">1</span>; temp /= <span class="number">2</span>) &#123;  </span><br><span class="line">        <span class="comment">// 这里的思路和插入排序的思路相同，通过找到前一个的数大于或者小于来进行插入  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp; i &lt; a.length; i += temp) &#123;  </span><br><span class="line">            <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">            <span class="keyword">int</span> j = i - temp;  </span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;  </span><br><span class="line">                a[j + temp] = a[j];  </span><br><span class="line">                j -= temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            a[j + temp] = temp; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="O（nlog2n）排序"><a href="#O（nlog2n）排序" class="headerlink" title="O（nlog2n）排序"></a>O（nlog<sub>2</sub>n）排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high,temp = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>( arr[j] &gt;= temp &amp;&amp; i &lt; j)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt;= temp &amp;&amp; i &lt; j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">    quickSort(arr,low,j-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,j+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>（1）稳定性：</strong>归并排序是一种稳定的排序。<br><strong>（2）存储结构要求：</strong>可用顺序存储结构。也易于在链表上实现。<br><strong>（3）时间复杂度：</strong>对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。<br><strong>（4）空间复杂度：</strong>需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。</p><p><strong>注意：</strong>若用单链表做存储结构，很容易给出就地的归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">            <span class="comment">//左右归并</span></span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i= low;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把左边剩余的数移入数组 </span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] = temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">        <span class="comment">//循环建堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//建堆</span></span><br><span class="line">            buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">            <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">            swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对data数组从0到lastIndex建大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//k保存正在判断的节点</span></span><br><span class="line">            <span class="keyword">int</span> k=i;</span><br><span class="line">            <span class="comment">//如果当前k节点的子节点存在</span></span><br><span class="line">            <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">                <span class="comment">//k节点的左子节点的索引</span></span><br><span class="line">                <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span></span><br><span class="line">                <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                    <span class="comment">//若果右子节点的值较大</span></span><br><span class="line">                    <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="comment">//biggerIndex总是记录较大子节点的索引</span></span><br><span class="line">                        biggerIndex++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果k节点的值小于其较大的子节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                    <span class="comment">//交换他们</span></span><br><span class="line">                    swap(data,k,biggerIndex);</span><br><span class="line">     <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span></span><br><span class="line">                    k=biggerIndex;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">        data[i]=data[j];</span><br><span class="line">        data[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"><span class="comment">// 各位装通法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = n;</span><br><span class="line">        <span class="keyword">int</span> divisor = <span class="number">1</span>;<span class="comment">// 定义每一轮的除数，1,10,100...</span></span><br><span class="line">        <span class="comment">//定义了10个桶，以防每一位都一样全部放入一个桶中</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">// 统计每个桶中实际存放的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> digit;<span class="comment">// 获取元素中对应位上的数字，即装入那个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;<span class="comment">// 经过4次装通操作，排序完成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> temp : A) &#123;<span class="comment">// 计算入桶</span></span><br><span class="line">                digit = (temp / divisor) % <span class="number">10</span>;</span><br><span class="line">                bucket[digit][count[digit]++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// 被排序数组的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">10</span>; b++) &#123;<span class="comment">// 从0到9号桶按照顺序取出</span></span><br><span class="line">                <span class="keyword">if</span> (count[b] == <span class="number">0</span>)<span class="comment">// 如果这个桶中没有元素放入，那么跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; count[b]; w++) &#123;</span><br><span class="line">                    A[k++] = bucket[b][w];</span><br><span class="line">                &#125;</span><br><span class="line">                count[b] = <span class="number">0</span>;<span class="comment">// 桶中的元素已经全部取出，计数器归零</span></span><br><span class="line">            &#125;</span><br><span class="line">            divisor *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1.若n较小(如n≤50)，可采用直接插入或直接选择排序。<br>    　当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。<br>2.若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；<br>3.若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。<br>4.快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>5.堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。<br>6.若要求排序稳定，则可选用归并排序。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;内排序有可以分为以下几类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。&lt;br
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的工作原理</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/03/HashMap的工作原理/</id>
    <published>2018-04-03T10:28:28.000Z</published>
    <updated>2018-04-03T13:03:58.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”"><a href="#“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”" class="headerlink" title="“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”"></a>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</h1><p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p><h1 id="“你知道HashMap的工作原理吗？”-“你知道HashMap的get-方法的工作原理吗？”"><a href="#“你知道HashMap的工作原理吗？”-“你知道HashMap的get-方法的工作原理吗？”" class="headerlink" title="“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”"></a>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</h1><p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p><h1 id="“当两个对象的hashcode相同会发生什么？”"><a href="#“当两个对象的hashcode相同会发生什么？”" class="headerlink" title="“当两个对象的hashcode相同会发生什么？”"></a>“当两个对象的hashcode相同会发生什么？”</h1><p> 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。</p><h1 id="“如果两个键的hashcode相同，你如何获取值对象？”"><a href="#“如果两个键的hashcode相同，你如何获取值对象？”" class="headerlink" title="“如果两个键的hashcode相同，你如何获取值对象？”"></a>“如果两个键的hashcode相同，你如何获取值对象？”</h1><p>面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p><p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p><p>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><h1 id="“如果HashMap的大小超过了负载因子-loadfactor-定义的容量，怎么办？”"><a href="#“如果HashMap的大小超过了负载因子-loadfactor-定义的容量，怎么办？”" class="headerlink" title="“如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”"></a>“如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”</h1><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p><p>散列表的hash算法是根据移位来进行计算的，只能是进行＊2或者／2。因此，扩容的大小要符合这个标准，否则会造成没必要的浪费甚至错误。扩容的成本并不低，因为需要遍历一个时间复杂度为O(n)的数组，并且为其中的每个enrty进行hash计算。加入到新数组中，所以最好的情况是能够合理的使用HashMap的构造方法创建合适大小的HashMap，使得在不浪费内存的情况下，尽量减少扩容，这个就要根据业务来决定了。</p><h1 id="“你了解重新调整HashMap大小存在什么问题吗？”"><a href="#“你了解重新调整HashMap大小存在什么问题吗？”" class="headerlink" title="“你了解重新调整HashMap大小存在什么问题吗？”"></a>“你了解重新调整HashMap大小存在什么问题吗？”</h1><p>你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(racecondition)。</p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？</p><p>热心的读者贡献了更多的关于HashMap的问题：</p><ol><li><strong>为什么String,Interger这样的wrapper类适合作为键？</strong> String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</li><li><strong>我们可以使用自定义的对象作为键吗？</strong> 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</li><li><strong>我们可以使用CocurrentHashMap来代替Hashtable吗？</strong>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</li></ol><p>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p><ul><li><strong>hashing的概念</strong></li><li><strong>HashMap中解决碰撞的方法</strong></li><li><strong>equals()和hashCode()的应用，以及它们在HashMap中的重要性</strong></li><li><strong>不可变对象的好处</strong></li><li><strong>HashMap多线程的条件竞争</strong></li><li><strong>重新调整HashMap的大小</strong></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p><strong>1. 什么时候会使用HashMap？它有什么特点？</strong></p><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><p><strong>2.HashMap的工作原理 </strong> </p><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将Key传给get()方法，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap在每个链表节点中储存键值对对象。</p><p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？HashMap中解决碰撞的方法</strong></p><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。</p><p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。</p><p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法计算index，把节点再放到新的bucket中。</p><p><strong>6.当两个不同的键对象的hashcode相同时会发生什么？</strong> </p><p>它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p><p>转载自：<a href="http://www.importnew.com/10620.html" target="_blank" rel="noopener">http://www.importnew.com/10620.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”&quot;&gt;&lt;a href=&quot;#“你用过HashMap吗？”-“什么是HashMap？你为什么用到它？”&quot; class=&quot;headerlink&quot; title=&quot;“你用过HashMap吗？” “什么是H
      
    
    </summary>
    
      <category term="Java" scheme="https://bameirilyo.github.io/BameirilyoBlog/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://bameirilyo.github.io/BameirilyoBlog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello,My Blog</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/02/Hello-My-Blog/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/02/Hello-My-Blog/</id>
    <published>2018-04-02T13:17:30.000Z</published>
    <updated>2018-04-02T13:49:41.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><b>纵有疾风起，人生不言弃<b></b></b></p></blockquote><a id="more"></a><p>花了一天半的时间终于开通了自己的博客。参照网上教程从下载Node.js、Hexo到下载博客模板、调试、配置成自己想要的样子，以及学这个Markdown语法，中间也遇到了一些小小的Bug，有些百度出来了，有的自己解决了，有的还没解决就只能小小的掩盖一下，以后慢慢学习，不断进步，慢慢解决吧。</p><p>虽然是借用了Hexo的模板，并挂在Github上的免费博客，但还是希望自己以后能坚持写下去，能将学习过程中的点点滴滴都能记录下来！纵有疾风起，人生不言弃！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;b&gt;纵有疾风起，人生不言弃&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bameirilyo.github.io/BameirilyoBlog/2018/04/01/hello-world/"/>
    <id>https://bameirilyo.github.io/BameirilyoBlog/2018/04/01/hello-world/</id>
    <published>2018-04-01T15:50:22.104Z</published>
    <updated>2018-04-01T15:50:22.104Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
