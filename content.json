[{"title":"从一个字符串中找出字典序最大子序列","date":"2018-04-19T14:15:47.000Z","path":"2018/04/19/从一个字符串中找出字典序最大子序列/","text":"说明： 字典序最大(不是递增)，例如 tt&gt;t、sa&gt;s、xe&gt;xba 例： 字符串test的字典序最大子序列为tt 字符串abcde的字典序最大子序列为e 思路： 从后向前找，最后一个字符肯定包含在内，前面的字符大于后面的字符才能保证字典序最大；所以，从后往前找时，遇到比最后一个大的字符，留下当作倒数第二个字符，继续找到比倒数第二个字符大的当作第三个字符。。。。。。 代码实现： 1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String str = sc.next(); char[] ch = str.toCharArray(); char[] chars = new char[50]; for(int i = 0; i&lt;ch.length;i++)&#123; int max = 0; int id = 50; for(i=ch.length-1;i&gt;=0;i--) &#123; if(ch[i] &gt;= max) &#123; chars[--id] = ch[i]; max = ch[i]; &#125; &#125; for(i=id;i&lt;50;i++) &#123; System.out.print(chars[i]); &#125; &#125; &#125;&#125;","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"Deepin下使用IDEA完成项目过程中报错com.intellij.javaee.oss.admin.jmx.JmxAdminException","date":"2018-04-18T16:08:57.000Z","path":"2018/04/19/Deepin下使用IDEA完成项目过程中报错com-intellij-javaee-oss-admin-jmx-JmxAdminException/","text":"详细报错信息为： 123Artifact unnamed: Artifact is being deployed, please wait...Artifact unnamed: Error during artifact deployment. See server log for details.Artifact unnamed: com.intellij.javaee.oss.admin.jmx.JmxAdminException: com.intellij.execution.ExecutionException: /home/bameirilyo/IdeaProjects/mmall/out/artifacts/unnamed/unnamed.war not found for the web module. 解决方法为： 1.点击idea右上角Project Structur按钮 2.选择Modules 3.鼠标右键 +Add ，选择Web 4.Artifacts模块中点击“+”号，“Web Application：Exploded”中出现From Modules选择即可。 可参考本人CSDN博客：https://blog.csdn.net/bameirilyo/article/details/79998409","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"Idea内初始化git","date":"2018-04-18T16:07:10.000Z","path":"2018/04/19/Idea内初始化git/","text":"利用模板创建完最原始的web项目后就可以在idea内初始化git了，并使用idea的控制台控制git 1234567891011121314151617181920212223#初始化git$ git init#查看状态$ git status#查看分支$ git branch#增加所有文件$ git add . $ git status#提交到本地仓库，双引号内为注释$ git commit -am \"first commit init project\"#设置github中项目仓库的ssh地址$ git remote set-url origin git@github.com:xxxx/xxxx.git#将远程仓库中的内容pull到本地$ git pull #推送到远程仓库（此步报错，原因为本地仓库内容落后于远程仓库）$ git push -u origin master #强制推送到远程仓库（-f）$ git push -u -f origin master#以master为基础新建并切换到该分支$ git checkout -b xxx origin/master#将此分支推送到远程仓库$ git push origin HEAD -u","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"网络基础知识小集","date":"2018-04-17T09:01:48.000Z","path":"2018/04/17/网络基础知识小集/","text":"Http和https的区别 http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"输出比当前数大的最近的4的倍数","date":"2018-04-17T05:12:23.000Z","path":"2018/04/17/输出比当前数大的最近的4的倍数/","text":"题目： 输入1.2.3.4中任意数则输出4；输入5.6.7.8中任意数则输出8；不使用语法关键字 解法： 1((x-1)/4+1)*4;","tags":[{"name":"数学题","slug":"数学题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数学题/"}]},{"title":"Deepin下vsftpd虚拟用户配置","date":"2018-04-16T15:17:02.000Z","path":"2018/04/16/Deepin下vsftpd虚拟用户配置/","text":"安装vsftpd和db-util12sudo apt-get -y install vsftpdsudo apt-get install db-util 查看下vsftpd都安装了那些文件 1dpkg -L vsftpd |tac 建立本地虚拟用户 12sudo useradd -m -d /home/vsftpd vsftpd #指定目录为/home/vsftpdsudo cat /etc/passwd |grep vsftpd #查看家目录 注意：创建的用户vsftpd现在是无法登录到系统的，因为没有给该用户设置密码。在此，我们也无需让vsftpd登录到系统，这样相对来说比较安全。 用户创建完毕后，我们来创建对应的目录并修改其所属用户，如下： 1sudo chown -R vsftpd:vsftpd /home/vsftpd/ 建立虚拟用户数据库12sudo mkdir /etc/vsftpdsudo vim /etc/vsftpd/login.txt 将下面的内容填到login.txt文件内： 123456norco1norcoarm1norco2norcoarm2norco3norcoarm3 注：login.txt为登录vsftpd的用户与密码文件。奇数行为用户名，偶数行为密码。 。如下： 1234#使用db_load对loginx.txt进行加密sudo db_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/login.db#修改权限（此步可不做，未发现问题）chmod 600 /etc/vsftpd/vsftpd_login.db 生成数据库文件之后建议删除 loginuser.txt PAM验证配置vsftpd的PAM验证，在此没有使用vsftpd安装时所生成的/etc/pam.d/vsftpd文件。 因为经过多次的测试，发现如果使用该文件进行验证的话，无法验证通过。猜想有可能是vsftpd的一个BUG。 创建验证文件，如下： 123sudo vim /etc/pam.d/vsftpd.virtualauth required pam_userdb.so db=/etc/vsftpd/loginaccount required pam_userdb.so db=/etc/vsftpd/login 其中/etc/vsftpd/login对应/etc/vsftpd/login.db文件 vsftp权限配置现在正式配置vsftpd，vsftpd的几乎所有配置项都在/etc/vsftpd.conf文件中进行。 先备份。 根据业务要求vsftpd.conf配置内容如下： 12345678910111213141516171819202122232425listen=YESlisten_ipv6=NOanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_file=/var/log/vsftpd.logxferlog_std_format=YESchroot_local_user=YESchroot_list_enable=NOallow_writeable_chroot=YESsecure_chroot_dir=/var/run/vsftpd/emptyrsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NOguest_enable=YESpam_service_name=vsftpd.virtualuser_config_dir=/etc/vsftpd/vupasv_enable=YESpasv_min_port=30000pasv_max_port=31000 在以上配置文件中，有几点需要重点指出。 local_enable=YES write_enable=YES local_umask=022 这两项是启用系统用户的写权限。特别是write_enable=YES项一定要启用，否则vsftpd虚拟用户将无法登录vsftpd。 为什么会是这样？因为虚拟用户依赖与系统用户。 chroot_local_user=YES chroot_list_enable=NO allow_writeable_chroot=YES 这三项是配置vsftpd用户禁止切换上级目录的权限。 guest_enable=YES pam_service_name=vsftpd.virtual user_config_dir=/etc/vsftpd/vu 这三项是启用vsftpd虚拟用以及虚拟用户账号配置目录。 pasv_enable=YES pasv_min_port=30000 pasv_max_port=31000 这三项是启用vsftpd被动模式及相关端口。 虚拟用户相关配置vsftpd配置文件修改文件后，现在开始配置虚拟用户的相关权限。如下： 123456sudo mkdir /etc/vsftpd/vusudo vim /etc/vsftpd/vu/ailanniguest_username=ftpilannilocal_root=/www/virtual_use_local_privs=YESanon_umask=133 以上配置参数，其中guest_username=ftpilanni表示的是设置FTP对应的系统用户为ftpilanni local_root=/www/表示使用本地用户登录到ftp时的默认目录。 virtual_use_local_privs=YES虚拟用户和本地用户有相同的权限。 anon_umask表示文件上传的默认掩码。计算方式是777减去anon_umask就是上传文件的权限。在此我们设置的是133，也就是说上传后文件的权限是644。即上传的文件对所属用户来说只有读写权限，没有执行权限。 若需配置多个用户时如下设置用户权限 在该文件夹下依次建立与login.txt对应的帐号名称相同的文件内容可以参考下面： 123456789101112131415161718192021#vim norco1#[norco1]只允许下载anon_world_readable_only=NOlocal_root=/opt/ftp/norco1#vim norco2 #[norco2]允许建立，修改，但是不允许删除anon_world_readable_only=NOwrite_enable=YESanon_mkdir_write_enable=YESanon_upload_enable=YESlocal_root=/opt/ftp/norco2#vim norco3#[norco3]全部权限anon_world_readable_only=NOwrite_enable=YESanon_mkdir_write_enable=YESanon_upload_enable=YESanon_other_write_enable=YESlocal_root=/opt/ftp/norco3","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"线程池","date":"2018-04-15T15:50:48.000Z","path":"2018/04/15/线程池/","text":"什么是线程池？线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 设计一个动态大小的线程池，如何设计，应该有哪些方法 ？ 一个线程池包括以下四个基本组成部分： 线程管理器(ThreadPool)：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务； 工作线程(PoolWorker)：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 任务接口(Task)：每个任务必须实现的接口，以供工作线程调度任务的执行。它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 任务队列(TaskQueue)：用于存放没有处理的任务。提供一种缓冲机制； 所包含的方法 1.privateThreadPool() 创建线程池 2.public static ThreadPoolgetThreadPool() 获得一个默认线程个数的线程池 3.public voidexecute(Runnable task) 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 4.public voidexecute(Runnable[] task) 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 5.public void destroy() 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁 6.public intgetWorkThreadNumber() 返回工作线程的个数 7.public intgetFinishedTasknumber() 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成 8.public voidaddThread() 在保证线程池中所有线程正在执行，并且要执行线程的个数大于某一值时。增加线程池中线程的个数 9.public voidreduceThread() 在保证线程池中有很大一部分线程处于空闲状态，并且空闲状态的线程在小于某一值时，减少线程池中线程的个数","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java实现多线程的方式及三种方式的区别","date":"2018-04-15T07:38:02.000Z","path":"2018/04/15/Java实现多线程的方式及三种方式的区别 - 副本/","text":"实现多线程的方式 继承Thread类，重写run函数。 实现Runnable接口 使用ExecutorService、Callable、Future实现有返回结果的多线程 三种方式的区别 实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。 继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。 实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java基础知识小集","date":"2018-04-14T14:05:13.000Z","path":"2018/04/14/Java基础知识小集/","text":"局部变量能否和成员变量重名？局部变量可以和成员变量重名，不加“this”修饰时，优先使用最近的变量。 java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。在实例方法中出现变量名相同时，可以使用this关键字来调用。如果成员变量用static修饰了呢，也能用this调用吗？不能了，这个时候可以通过类名来调用，因为静态成员是属于类的。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"操作系统知识小集","date":"2018-04-14T12:50:06.000Z","path":"2018/04/14/操作系统知识小集/","text":"进程状态变化","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"找东西背后的概率问题","date":"2018-04-14T12:44:16.000Z","path":"2018/04/14/找东西背后的概率问题/","text":"来自于《思考的乐趣-Matrix67数学笔记》第一部分第2节的一条小题 题目： 我的书桌有8个抽屉，分别用数字1到8编号。每次拿到一份文件后，我都会把这份文件随机的放在一个抽屉中。但是我非常粗心，有1/5的概率会忘了把文件放进抽屉里，最终把文件搞丢。 现在我要找一份非常重要的文件。我将按顺序打开每一个抽屉，直到找到这份文件为止（或者很悲剧的发现，翻遍了所有抽屉都没能找到这份文件）。考虑下面三个问题。(1) 假如我打开了第一个抽屉，发现里面没有我要的文件。这份文件在其余的7个抽屉里的概率是多少？(2) 假如我翻遍了前4个抽屉，里面都没有我要的文件。这份文件在剩下的4个抽屉里的概率是多少？(3) 假如我翻遍了前7个抽屉，里面都没有我要的文件。这份文件在最后一个抽屉里的概率是多少？ 解： M牛在书中给出的一个巧妙解法是这样的: 注意到，平均每10份文件就有两份被搞丢，其余8份平均地分给了8个抽屉。假如我把所有搞丢了的文件都找了回来，那么它们应该还占2个抽屉。这让我们想到了这样一个有趣的思路：在这8个抽屉后加上2个虚拟抽屉——抽屉9和抽屉10，这两个抽屉专门用来装我丢掉的文件。我们甚至可以把题目等价地变为：随机把文件放在10个抽屉里，但找文件时不允许打开最后2个抽屉。当我已经找过n个抽屉但仍没找到我想要的文件时，文件只能在剩下的10-n个抽屉里，但是我只能打开剩下的8-n个抽屉，因此所有的概率是(8 - n)/(10 - n)。当n分别等于1、4、7时，这个概率值分别是7/9、2/3和1/3。 从基本的解法中可发现，对于此题中的事件A、B，有P(A|B)恒等于1。因此，实际上当文件不在前n个抽屉中时，文件在后(抽屉总数-n)个抽屉中的概率就为(文件在后(抽屉总数 - n)个抽屉中的概率 除以 文件不在前n个抽屉中的概率) 考虑文件不在前n个抽屉中的概率，可得P(文件不在前n个抽屉中) = 1 - P(文件不丢失)·(n / 抽屉总数) 考虑文件在后(抽屉总数 - n)个抽屉中的概率，可得P(文件在后(抽屉总数 - n)个抽屉中) = P(文件不丢失)·(抽屉总数 - n) / 抽屉总数 则总体概率为P(B|A) = P(文件不丢失)·(抽屉总数 - n) / (抽屉总数 - P(文件不丢失)·n) 代入P(文件不丢失) = 4/5， 抽屉总数 = 8，可得 总体概率P = (4/5)·(8 - n) / (8 - 4·n / 5) = (8 - n) / (10 - n) 转载自网络","tags":[{"name":"数学题","slug":"数学题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数学题/"}]},{"title":"Deepin用终端查看已安装的软件列表及软件卸载","date":"2018-04-13T05:04:56.000Z","path":"2018/04/13/Deepin用终端查看已安装的软件列表及软件卸载/","text":"查看已经安装的软件包： 1dpkg -l 卸载命令： 1sudo apt-get autoremove --purge 软件包名称 用于清理下载文件的存档 ： 1sudo apt-get clean 只清理过时的包 1sudo apt-get autoclean","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"Java访问权限修饰词的作用域","date":"2018-04-12T14:46:16.000Z","path":"2018/04/12/Java访问权限修饰词的作用域/","text":"作用域（可见） 当前类 同包 子孙类 其他包 public √ √ √ √ protected √ √ √ × default(friendly) √ √ × × private √ × × ×","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"String、StringBuffer、StringBuilder以及对String不变性的理解","date":"2018-04-12T14:40:27.000Z","path":"2018/04/12/String、StringBuffer、StringBuilder以及对String不变性的理解/","text":"String、StringBuffer、StringBuilder 都是 final 类, 都不允许被继承; String 长度是不可变的,StringBuffer、StringBuilder 长度是可变的; StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer在StringBuilder的方法之上添加了synchronized修饰，保证线程安全。 StringBuilder比StringBuffer拥有更好的性能。 如果一个String类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时String的速度比StringBuffer和StringBuilder的性能好的多。 String不变性的理解 String 类是被final进行修饰的，不能被继承。 在用+号链接字符串的时候会创建新的字符串。 String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有“Hello world”字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有“Hello world”对象，则堆上和静态区中都需要创建对象。 在 java 中, 通过使用 “+” 符号来串联字符串的时候, 实际上底层会转成通过 StringBuilder 实例的 append() 方法来实现。 String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？String有重写Object的hashcode和toString吗？ String重写了Object类的hashcode和toString方法。 当equals方法被重写时，通常有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相对等的两个对象必须有相同的hashCode object1.euqal(object2) 为true时，object1.hashCode() == object2.hashCode() 为true object1.hashCode() == object2.hashCode() 为false时，object1.euqal(object2)必定为false object1.hashCode() == object2.hashCode() 为true时，但object1.euqal(object2)不一定为true 重写equals不重写hashcode会出现什么问题 在存储散列集合时(如Set类)，如果原对象.equals(新对象)，但没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写equals方法时，必须重写hashCode方法。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"TCP与UDP（传输层协议）","date":"2018-04-12T14:37:51.000Z","path":"2018/04/12/TCP与UDP（传输层协议）/","text":"区别 TCP 提供面向连接、可靠的数据流传输，而UDP 提供的是非面向连接的、不可靠的数据流传输。 TCP 传输单位称为TCP 报文段，UDP 传输单位称为用户数据报。 TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。 TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。 TCP首部开销20字节；UDP的首部开销小，只有8个字节。 TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。 为什么UDP有时比TCP更有优势?UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。 （1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。 （2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。 采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 关于tcp中time_wait状态的4个问题time_wait是个常问的问题，tcp网络编程中最不容易理解的也是它的time_wait状态，这也说明了tcp/ip四次挥手中time_wait状态的重要性。 1.time_wait状态是什么 简单来说：time_wait状态是四次挥手中服务器向客户端发送FIN终止连接后进入的状态。 下图为tcp四次挥手过程 可以看到time_wait状态存在于客户端收到服务器Fin并返回ack包时的状态 当处于time_wait状态时，我们无法创建新的连接，因为端口被占用。 2.为什么会有time_wait状态time_wait存在的原因有两点 1.可靠的终止TCP连接。 2.保证让迟来的TCP报文段有足够的时间被识别并丢弃。 1.可靠的终止TCP连接，若处于time_wait的客户端发送给服务器确认报文段丢失的话，服务器将在此重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait而不是close状态。 2.保证迟来的TCP报文段有足够的时间被识别并丢弃，linux中一个TCP端口不能打开两次或两次以上，当客户端处于time_wait状态时我们将无法使用此端口建立新连接，如果不存在time_wait状态，新连接可能会收到旧连接的数据。time_wait持续的时间是2MSL，保证旧的数据可以丢弃，因为网络中的数据最大存在MSL(maxinum segment lifetime)。 3.哪一方会有time_wait状态time_wait状态是一般有客户端的状态。而且会占用端口有时产生在服务器端，因为服务器主动断开连接或者发生异常 4.如何避免time_wait状态占用资源如果是客户端，我们一般不用担心，因为客户端一般选用临时端口，再次创建连接会新分配一个端口。除非指定客户端使用某端口，不过一般不需要这么做。 如果是服务器主动关闭连接后异常终止，则因为它总是使用用一个知名服务器端口号，所以连接的time_wait状态将导致它不能重启，不过我们可以通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口。通过socksetopt设置后，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用。 此外也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而是tcp连接根本不进入time_wait状态，进而允许应用程序立即重用本地的socket地址。 close_wait状态出现的原因某一方在网络连接断开后，对等方没有检测到这个错误（对方断开）而没有调用 closesocket，导致了这个状态的出现. 为什么TCP连接需要三次握手，两次不可以吗，为什么为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 例子 ： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"查找算法","date":"2018-04-11T11:14:34.000Z","path":"2018/04/11/查找算法/","text":"目前查找方法主要：顺序查找、有序查找（分为：折半查找即二分查找、差值查找和斐波那契查找方法）、线性索引查找、二叉排序树、平衡二叉树（AVL树）以及多路查找树（B树）、散列表查找（哈希表）等查找方法 ​ 【1】顺序查找：是最简单的查找方法，其时间复杂度为O(n)，是通过构造一个线性表，采用遍历的方法，将记录与关键字一个一个的对比，若相等则查找成功，若全都不相等，则查找失败即记录不存在； ​ 【2】有序查找：顺序表的记录一般是无序，而有序表的记录是有序的；使用有序表查找方法时，前提条件是待查找的记录必须是已经排好序的。 有序查找分为：二分查找、插值查找和斐波那契查找方法 二分查找算法思想：又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。时间复杂度为 O(logN)。 实现： 1.非递归代码 12345678910111213141516public static int binarySearch(int []array,int a)&#123; int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi)&#123; mid=(lo+hi)/2; if(array[mid]==a)&#123; return mid+1; &#125;else if(array[mid]&lt;a)&#123; lo=mid+1; &#125;else&#123; hi=mid-1; &#125; &#125; return -1; &#125; 2.递归实现 12345678910111213public static int binarySearch(int []array,int a,int lo,int hi)&#123; if(lo&lt;=hi)&#123; int mid=(lo+hi)/2; if(a==array[mid])&#123; return mid; &#125;else if(a&gt;array[mid])&#123; return binarySearch(array,a,mid+1,hi); &#125;else&#123; return binarySearch(array,a,lo,mid-1); &#125; &#125; return -1;&#125; 插值查找对二分法查找进行改进，将要查找的关键字key与查找表中的最大最小值记录进行比较后，再确定查找的范围。在二分法查找中，是以中间记录作为查找分区的，即将表一分为二，分为上下两个查找分区： 而插值查找采用插值公式的方法，来确定查找分区。可简单这样理解，比如有100个数其值在0~1000范围之间从小到大排序，你要查找关键字为5的位置下标，若采用二分法，则大概在500的地方往下查找，但采用插值的方法，可以通过插值计算出5这个关键字应该在靠近0的地方，因此查找时从50往下开始查找，从而提高效率： ​ 因此插值查找只需要在折半查找算法的代码中简单修改一下即可： 12345678910111213141516171819202122232425262728public class JavaTest1 &#123; public static void main(String[] args) &#123; int[] num = &#123; 1, 2, 3, 4, 5, 6 &#125;;//必须有序 int index = Insert_Search(num, 5); System.out.print(index); &#125; /* *num：有序表（由小到大排列） key：要查找的关键字 *return：还回查找到关键字的下标，没有找到则还回-1 */ private static int Insert_Search(int[] num, int key) &#123; int low, high, mid; low = 0; high = num.length - 1; while (low &lt;= high) &#123; // mid = (low + high) / 2;//二分查找 mid = low + (high - low) * (key - num[low])/ (num[high] - num[low]);//插值查找 if (key &lt; num[mid]) high = mid - 1; else if (key &gt; num[mid]) low = mid + 1; else // 如果等于则直接还回下标值 return mid; &#125; return -1; &#125;&#125; 斐波那契查找​ 斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。 ​ 斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 斐波那契数列 */static int[] f = &#123; 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 &#125;;/** * 斐波那契查找(黄金分割原理) * @param a 待查询数组 * @param key 待查找关键字 * @return 返回关键字在a数组中的下标，返回-1表示数组中不存在此关键字 */public static int fibonaciSearch(int[] a, int key) &#123; int low, mid, high, k; low = 0; high = a.length - 1; // 斐波那契数列下标 k = 0; // 获取斐波那契分割值下标 while (high &gt; f[k] - 1) k++; // 利用Java工具类Arrays构造长度为f[k]的新数组并指向引用a a = Arrays.copyOf(a, f[k]); // 对新数组后面多余的元素赋值最大的元素 for (int i = high + 1; i &lt; f[k]; i++) &#123; a[i] = a[high];//当key是是最大值时候，防止角标越界异常 &#125; while (low &lt;= high) &#123; // 前半部分有f[k-1]个元素，由于下标从0开始 // 减去 1 获取 分割位置元素的下标 mid = low + f[k - 1] - 1; if (key &lt; a[mid]) &#123;//关键字小于分割位置元素，则继续查找前半部分，高位指针移动 high = mid - 1; // (全部元素) = (前半部分)+(后半部分) // f[k] = f[k-1] + f[k-2] // 因为前半部分有f[k-1]个元素， 则继续拆分f[k-1] = f[k-2] + f[k-3]成立 // 即在f[k-1]个元素的前半部分f[k-2]中继续查找，所以k = k - 1, // 则下次循环mid = low + f[k - 1 - 1] - 1; k = k - 1; &#125; else if (key &gt; a[mid])&#123;//关键字大于分割位置元素，则查找后半部分，低位指针移动 low = mid + 1; // (全部元素) = (前半部分)+(后半部分) // f[k] = f[k-1] + f[k-2] // 因为后半部分有f[k-2]个元素， 则继续拆分f[k-2] = f[k-3] + f[k-4]成立 // 即在f[k-2]个元素的前半部分f[k-3]继续查找，所以k = k - 2, // 则下次循环mid = low + f[k - 2 - 1] - 1; k = k - 2; &#125; else &#123; // 当条件成立的时候，则找到元素 if (mid &lt;= high) return mid; else // 出现这种情况是查找到补充的元素 // 而补充的元素与high位置的元素一样 return high; &#125; &#125; return -1;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E05_2数组B合并到A数组","date":"2018-04-10T14:49:46.000Z","path":"2018/04/10/E05-2数组B合并到A数组/","text":"E05_2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。题目： 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。 给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。 方法一：直接暴力解法，把B直接添加到A中，然后再排序，快排时间复杂度为nlog(n); 方法二：新建已个数组（这个题可以不需要建立数组），把A和B 的元素都添加到新数组中去，时间复杂度为O（M+N）;空间复杂度增加了O（M）； 方法三：在A的左边和B比较，然后将B插入到A中去，但是移动的次数过多，移动一次时间复杂度为O（M）,那么时间复杂就为O（M*N）; 方法四：先计算A和B的长度，由于数组的后面的元素是空的，所以可以从后面复杂数组元素。时间复杂度为O（M+N），空间复杂度为O（1）； 下列是解法： 把A看成有序的，然后把B中的数据插入到A中，再利用插入排序算法对A进行排序。假设A = {1, 4, 5}，B = ｛2, 3｝初始状态如下：此时A[0 ~ 2]是有序的，利用插入排序向A中插入2，插入后如下图所示A中的 4 和 5 向后移动了，接着向A[0 ~ 3]中插入3后此时4 和 5又向后移动了。再合并的时候，我们是从左向右合并的，结果造成了一些数据的多次移动，导致效率不理想。如果考虑从右向左合并呢？这时我们需要先断定合并后的从长度：k=lenA + lenB-1令i=lenA-1, j=lenB-1比较A[i]和B[j]，如果A[i]&gt;B[j]，A[k–]=A[i–];如果A[i]&lt;B[j]，A[k–]=B[j–];如此循环，直到 i&lt;0 或 j&lt;0最后再判断j是否为0，不为0就继续A[k–]=B[j–]按上面的流程执行，结果如下图所示代码： 123456789101112131415public static void mergeAB(int[] A,int n,int[] B,int m) &#123; int i=n-1 ; int j=m-1 ; int k=m+n-1 ; while(i&gt;=0 &amp;&amp; j &gt;= 0)&#123; if(A[i] &gt;= B[j])&#123; A[k--] = A[i--]; &#125;else&#123; A[k--] = B[j--]; &#125; &#125; while(j &gt;= 0)&#123; A[k--]=B[j--]; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"数组","slug":"数组","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数组/"}]},{"title":"E04二维数组中的查找","date":"2018-04-10T14:44:17.000Z","path":"2018/04/10/E04二维数组中的查找/","text":"题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617181920public boolean Find(int target, int [][] array) &#123; int rows = array.length; int columns = array[0].length; boolean flag = false; int i = 0; int j = columns -1; if(array != null &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0 )&#123; while(i &lt; rows &amp;&amp; j &gt;= 0)&#123; if(array [i][j] == target)&#123; flag = true; break; &#125;else if(array[i][j] &gt; target)&#123; j--; &#125;else &#123; i++; &#125; &#125; &#125; return flag;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"数组","slug":"数组","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数组/"}]},{"title":"E28对称的二叉树","date":"2018-04-09T13:52:17.000Z","path":"2018/04/09/E28对称的二叉树/","text":"题目: 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路： 首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同 左子树的右子树和右子树的左子树相同即可，采用递归 非递归也可，采用栈或队列存取各级子树根节点​ 123456789101112131415public class Solution &#123; boolean isSymmetrical(TreeNode pRoot)&#123; if(pRoot == null)&#123; return true; &#125; return comRoot(pRoot.left, pRoot.right); &#125; private boolean comRoot(TreeNode left, TreeNode right) &#123; if(left == null) return right==null;//此为\"等于\"的判断，不是赋值 if(right == null) return false; if(left.val != right.val) return false; return comRoot(left.right, right.left) &amp;&amp; comRoot(left.left, right.right); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E27二叉树的镜像","date":"2018-04-09T13:32:59.000Z","path":"2018/04/09/E27二叉树的镜像/","text":"题目： 操作给定的二叉树，将其变换为源二叉树的镜像。 思路： 先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像 123456789101112131415161718192021222324252627/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) return; TreeNode pTemp = root.left; root.left = root.right; root.right = pTemp; if(root.left != null) Mirror(root.left); if(root.right != null) Mirror(root.right); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E26树的子结构","date":"2018-04-09T12:41:58.000Z","path":"2018/04/09/E26树的子结构/","text":"题目： 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路： (1)在树A中找到和数B的根节点相同的节点； 可以利用前序遍历A树中的节点，找到和B树的根节点相同的节点。 (2)在树A中找到和树B根节点相同的节点设为R； 再对比节点R在树B中的左孩子和右孩子是否和树B中的节点相同。 如果R节点的值和树B中的节点的值不同，则不是子结构，如果相同，递归去判断他们的各自的左孩子和右孩子是否相同。 递归的出口是到达树A或者树B的叶节点。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public static boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if (root2 != null &amp;&amp; root1 != null) &#123; //如果找到了对应Tree2的根节点的点 if(root1.val == root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result = doesTree1HaveTree2(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125; public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2)&#123; //如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) &#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; //如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right); &#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E08二叉树的下一个结点","date":"2018-04-09T11:32:59.000Z","path":"2018/04/09/E08二叉树的下一个结点/","text":"题目： 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 12345678910111213141516171819202122232425262728/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; TreeLinkNode GetNext(TreeLinkNode node)&#123; if(node==null) return null; if(node.right!=null)&#123; //如果有右子树，则找右子树的最左节点 node = node.right; while(node.left!=null) node = node.left; return node; &#125; while(node.next!=null)&#123;//没右子树，则找第一个当前节点是父节点左孩子的节点 if(node.next.left==node) return node.next; node = node.next; &#125; return null; //退到了根节点仍没找到，则返回null &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E07重建二叉树","date":"2018-04-09T08:25:27.000Z","path":"2018/04/09/E07重建二叉树/","text":"题目： 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路： 根据先序遍历数组，可以得到树的根节点，根据得到的根节点，去中序数组中找到相应的根节点，因为中序的遍历顺序是左–根–右，可以得到根节点的左子树和右子树的中序遍历数组，这样树的左子树中节点的个数和右子树上节点的个数就确定了。在先序数组中，左子树的先序和左子树的先序也可以确定了。 参数： 先序遍历数组，子树在先序数组中的开始位置，结束位置。 中序遍历数组，子树在中序数组中的开始位置，结束位置。 可以根据先序和中序数组得到子树的先序和中序数组，所以此问题可以用递归解决。 123456789101112131415161718192021222324252627public static TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre == null || in ==null) &#123; return null; &#125; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root;&#125;//前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;private static TreeNode reConstructBinaryTree( int[] pre,int startPre,int endPre,int[] in,int startIn,int endIn) &#123; if(startPre &gt; endPre || startIn &gt; endIn) return null; TreeNode root=new TreeNode(pre[startPre]); for(int i = startIn;i &lt;= endIn;i++)&#123; if(in[i] == pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn, in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre, in,i+1,endIn); break; &#125; &#125; return root;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"二叉树的遍历","date":"2018-04-09T08:05:11.000Z","path":"2018/04/09/二叉树的遍历/","text":"创建一棵树： 1234567891011121314151617181920212223242526272829public class Node &#123; private int data; private Node leftNode; private Node rightNode; public Node(int data, Node leftNode, Node rightNode)&#123; this.data = data; this.leftNode = leftNode; this.rightNode = rightNode; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getLeftNode() &#123; return leftNode; &#125; public void setLeftNode(Node leftNode) &#123; this.leftNode = leftNode; &#125; public Node getRightNode() &#123; return rightNode; &#125; public void setRightNode(Node rightNode) &#123; this.rightNode = rightNode; &#125; &#125; 简版： 1234567891011class TreeNode&#123; int data; TreeNode left; TreeNode right; public TreeNode(int data) &#123; this.data = data; this.left = null; this.right = null; &#125;&#125; 遍历时先判断二叉树是否为空的情况 递归： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class BinaryTree &#123; //二叉树的先序中序后序排序 public Node init() &#123;//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 Node J = new Node(8, null, null); Node H = new Node(4, null, null); Node G = new Node(2, null, null); Node F = new Node(7, null, J); Node E = new Node(5, H, null); Node D = new Node(1, null, G); Node C = new Node(9, F, null); Node B = new Node(3, D, E); Node A = new Node(6, B, C); return A; //返回根节点 &#125; public void printNode(Node node)&#123;//打印 System.out.print(node.getData()); &#125; public void theFirstTraversal(Node root) &#123; //先序遍历 printNode(root); if (root.getLeftNode() != null) &#123; //使用递归进行遍历左孩子 theFirstTraversal(root.getLeftNode()); &#125; if (root.getRightNode() != null) &#123; //递归遍历右孩子 theFirstTraversal(root.getRightNode()); &#125; &#125; public void theInOrderTraversal(Node root) &#123; //中序遍历 if (root.getLeftNode() != null) &#123; theInOrderTraversal(root.getLeftNode()); &#125; printNode(root); if (root.getRightNode() != null) &#123; theInOrderTraversal(root.getRightNode()); &#125; &#125; public void thePostOrderTraversal(Node root) &#123; //后序遍历 if (root.getLeftNode() != null) &#123; thePostOrderTraversal(root.getLeftNode()); &#125; if(root.getRightNode() != null) &#123; thePostOrderTraversal(root.getRightNode()); &#125; printNode(root); &#125; public static void main(String[] args) &#123; BinaryTree tree = new BinaryTree(); Node root = tree.init(); System.out.println(\"先序遍历\"); tree.theFirstTraversal(root); System.out.println(\"\"); System.out.println(\"中序遍历\"); tree.theInOrderTraversal(root); System.out.println(\"\"); System.out.println(\"后序遍历\"); tree.thePostOrderTraversal(root); System.out.println(\"\"); &#125; &#125; 非递归： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class BinaryTree1 &#123; public Node init() &#123;//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 Node J = new Node(8, null, null); Node H = new Node(4, null, null); Node G = new Node(2, null, null); Node F = new Node(7, null, J); Node E = new Node(5, H, null); Node D = new Node(1, null, G); Node C = new Node(9, F, null); Node B = new Node(3, D, E); Node A = new Node(6, B, C); return A; //返回根节点 &#125; public void printNode(Node node)&#123; System.out.print(node.getData()); &#125; public void theFirstTraversal_Stack(Node root) &#123; //先序遍历 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node node = root; while (node != null || stack.size() &gt; 0) &#123; //将所有左孩子压栈 if (node != null) &#123; //压栈之前先访问 printNode(node); stack.push(node); node = node.getLeftNode(); &#125; else &#123; node = stack.pop(); node = node.getRightNode(); &#125; &#125; &#125; public void theInOrderTraversal_Stack(Node root) &#123; //中序遍历 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node node = root; while (node != null || stack.size() &gt; 0) &#123; if (node != null) &#123; stack.push(node); //直接压栈 node = node.getLeftNode(); &#125; else &#123; node = stack.pop(); //出栈并访问 printNode(node); node = node.getRightNode(); &#125; &#125; &#125; public void thePostOrderTraversal_Stack(Node root) &#123; //后序遍历 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; output = new Stack&lt;Node&gt;();//构造一个中间栈来存储逆后序遍历的结果 Node node = root; while (node != null || stack.size() &gt; 0) &#123; if (node != null) &#123; output.push(node); stack.push(node); node = node.getRightNode(); &#125; else &#123; node = stack.pop(); node = node.getLeftNode(); &#125; &#125; System.out.println(output.size()); while (output.size() &gt; 0) &#123; printNode(output.pop()); &#125; &#125; public static void main(String[] args) &#123; BinaryTree1 tree = new BinaryTree1(); Node root = tree.init(); System.out.println(\"先序遍历\"); tree.theFirstTraversal_Stack(root); System.out.println(\"\"); System.out.println(\"中序遍历\"); tree.theInOrderTraversal_Stack(root); System.out.println(\"\"); System.out.println(\"后序遍历\"); tree.thePostOrderTraversal_Stack(root); System.out.println(\"\"); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"栈","date":"2018-04-08T12:34:18.000Z","path":"2018/04/08/栈/","text":"定义： 栈是一种只能在一端进行插入或删除操作的线性表。（先进后出表） java中的Stack继承Vector 实例化 1Stack stack = new Stack(); 基本使用 序号 方法描述 1 boolean empty() 测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 示例： 123456789101112131415161718public class StackTest &#123; public static void main(String[] args) &#123; Stack stack=new Stack(); //1.empty()栈是否为空 System.out.println(stack.empty()); //2.peek()栈顶值 //3.进栈push() stack.push(new Integer(1)); stack.push(\"b\"); System.out.println(stack.peek()); //4.pop()出栈 stack.pop(); System.out.println(stack.peek()); System.out.println(stack.empty()); //5.search（）搜索位置 System.out.println(stack.search(1)); &#125;&#125; 运行结果： 12345trueb1false1","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"栈","slug":"栈","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/栈/"}]},{"title":"E52两个链表的第一个公共节点","date":"2018-04-08T11:47:10.000Z","path":"2018/04/08/E52两个链表的第一个公共节点/","text":"思路： 首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。 123456789101112131415161718192021222324252627282930313233public static ListNode findFirstCommonNode(ListNode head1, ListNode head2) &#123; int len1 = getListLength(head1); int len2 = getListLength(head2); ListNode longListNode = head1; ListNode shortListNode = head2; int dif = len1 - len2; if (len2 &gt; len1) &#123; longListNode = head2; shortListNode = head1; dif = len2 - len1; &#125; for (int i = 0; i &lt; dif; i++) &#123; longListNode = longListNode.nextNode; &#125; while (longListNode != null &amp;&amp; shortListNode != null &amp;&amp; longListNode != shortListNode) &#123; longListNode = longListNode.nextNode; shortListNode = shortListNode.nextNode; &#125; return longListNode;&#125;private static int getListLength(ListNode head1) &#123; int result = 0; if (head1 == null) return result; ListNode point = head1; while (point != null) &#123; point = point.nextNode; result++; &#125; return result;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E18_2删除链表中重复的节点","date":"2018-04-08T11:20:15.000Z","path":"2018/04/08/E18-2删除链表中重复的节点/","text":"题目： 在一个排序的链表中，如何删除重复的节点？ 样例输入： 1 2 3 3 4 4 5 样例输出： 1 2 5 解法一： 12345678910111213141516public static ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; // 只有0个或1个结点，则返回 return pHead; &#125; if (pHead.val == pHead.next.val) &#123; // 当前结点是重复结点 ListNode pNode = pHead.next; while (pNode != null &amp;&amp; pNode.val == pHead.val) &#123; // 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点 pNode = pNode.next; &#125; return deleteDuplication(pNode); // 从第一个与当前结点不同的结点开始递归 &#125; else &#123; // 当前结点不是重复结点 pHead.next = deleteDuplication(pHead.next); //保留当前结点，从下一个结点开始递归 return pHead; &#125;&#125; 解法二： 123456789101112131415161718192021public ListNode deleteDuplication(ListNode pHead)&#123; if(pHead == null || pHead.next == null) return pHead; ListNode helper = new ListNode(-1); helper.next = pHead; ListNode prev = helper, curr = pHead, next = pHead.next; while(curr != null &amp;&amp; next != null)&#123; if(next.val != curr.val)&#123; prev = curr; curr = next; next = next.next; &#125;else&#123; while(next != null &amp;&amp; next.val == curr.val) next = next.next; curr = prev.next = next; if(next != null) next = next.next; &#125; &#125; return helper.next;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E18_1删除链表的节点","date":"2018-04-08T09:05:55.000Z","path":"2018/04/08/E18-1删除链表的节点/","text":"题目： 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。 思路： 由于给定的是单向链表，正常删除链表的时间复杂度是查找链表的时间复杂度即O(n),如果要求在O(1)时间复杂度内删除节点，通过遍历链表找到该节点的上一节点和下一节点的方法是行不通了。所以实现的思路是，根据给定的要删除的节点，可以直接找到其后年的节点，把后面的节点的内容复制到当前节点处，同时将当前节点指向其后面节点的后面节点保证链表不断开，再把下一节点删掉就相当于把给定的节点删除了。 需要考虑到的一点是，如果要删除的节点是链表的尾节点的话，那还是需要从头结点按照顺序遍历到尾节点的前一节点，然后删除尾节点，总的平均时间复杂度就是[(n-1)*1+O(n)]/n,结果还是O(1)。 代码实现： BUG：链表只有一个头节点的情况下，该代码无法删除，网上未找到有效代码 123456789101112131415161718public static void deleteNode(ListNode head,ListNode node)&#123; //删除尾节点，采用顺序查找找到尾节点的前一节点 if(node.next==null)&#123; while(head.next!=node)&#123; head=head.next; &#125; head.next=null; &#125; //要删除的节点是头结点 else if(head==node)&#123; head=null; &#125; //要删除的节点是中间普通节点 else&#123; node.data=node.next.data; node.next=node.next.next; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E23链表中环的入口节点(判断链表是否有环)","date":"2018-04-08T07:51:00.000Z","path":"2018/04/08/E23链表中环的入口节点(判断链表是否有环)/","text":"题目一个链表中包含环，请找出该链表的环的入口结点。 思路如果链表中有环，那么先获取环中节点个数n，设置两个指针指向pHead 快指针向前移动n次，然后进行循环，快慢指针同时向后移动，直到指向的节点相同，即环入口节点 获取环中节点个数：设置两个指针：p1和p2。p1一次移动一次，p2一次移动两次 当p2等于p1，说明存在环。返回该节点 通过该节点很容易能获得环中节点个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class 链表中环的入口结点 &#123; //找到一快一慢指针相遇处的节点，相遇的节点一定是在环中 //此方法可用作判断链表是否有环 public static ListNode meetingNode(ListNode head) &#123; if(head == null) return null; ListNode slow = head.next; if(slow == null) return null; ListNode fast = slow.next; while (slow != null &amp;&amp; fast != null) &#123; if(slow == fast)&#123; return fast; &#125; slow=slow.next; fast=fast.next; if(fast!=null)&#123; fast=fast.next; &#125; &#125; return null; &#125; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode meetingNode = meetingNode(pHead); if(meetingNode == null) return null;// 得到环中的节点个数 int nodesInLoop = 1; ListNode p1 = meetingNode; while(p1.next != meetingNode)&#123; p1=p1.next; ++nodesInLoop; &#125;// 移动p1，次数为环中节点数目 p1 = pHead; for(int i = 0;i &lt; nodesInLoop; i++)&#123; p1 = p1.next; &#125;// 再移动p1，p2 ListNode p2 = pHead; while(p1!= p2)&#123; p1 = p1.next; p2 = p2.next; &#125; return p1; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"求链表的中间节点","date":"2018-04-08T07:35:36.000Z","path":"2018/04/08/求链表的中间节点/","text":"题目： 求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数为偶数，返回中间两个结点的任意一个。 思路： 设置两个指针fast和slow，两个指针同时向前走，fast指针每次走两步，slow指针每次走一步，直到fast指针走到最后一个结点时，此时slow指针所指的结点就是中间结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度为O（n）。 1234567891011121314private static ListNode findMid(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head; ListNode fast = head; //每次移动时，让fast结点移动两位，slow结点移动一位 while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; &#125; //直到fast结点移动到null时，此时slow指针指向的位置就是中间结点的位置 return slow;&#125; 注：当n为偶数时，得到的中间结点是第n/2 + 1个结点。比如链表有6个节点时，得到的是第4个节点。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E25合并两个排序的链表","date":"2018-04-08T06:17:53.000Z","path":"2018/04/08/E25合并两个排序的链表/","text":"题目： 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 步骤： Step1.定义一个指向新链表的指针，暂且让它指向NULL； Step2.比较两个链表的头结点，让较小的头结点作为新链表的头结点； Step3.递归比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点； 递归解法： 12345678910111213141516public Node Merge(Node head1, Node head2)&#123; if (head1 == null)&#123; return head2; &#125;else if (head2 == null)&#123; return head1; &#125; Node newHead = null; if (head1.val &lt;= head2.val)&#123; newHead = head1; newHead.next = Merge(head1.next, head2); &#125;else &#123; newHead = head2; newHead.next = Merge(head1, head2.next); &#125; return newHead;&#125; 非递归解法： 12345678910111213141516171819202122232425262728293031323334public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null ) return list1; ListNode tmp1 = list1; ListNode tmp2 = list2; ListNode head = new ListNode(0);//这里不能把返回链表赋值为null，因为下一行马上就要把它赋值给另一链表，得让它在内存里有位置才行 ListNode headptr = head; while(tmp1 != null &amp;&amp; tmp2!=null)&#123; if(tmp1.val &lt;= tmp2.val) &#123; head.next=tmp1; head = head.next; tmp1 = tmp1.next; &#125;else&#123; head.next=tmp2; head = head.next; tmp2=tmp2.next; &#125; &#125; //其中一个链表已经跑到头之后，继续单链表的合并 while(tmp1 != null)&#123; head.next = tmp1; head = head.next; tmp1= tmp1.next; &#125; while(tmp2 != null)&#123; head.next = tmp2; head = head.next; tmp2= tmp2.next; &#125; head = headptr.next; return head;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E24反转链表","date":"2018-04-08T03:39:04.000Z","path":"2018/04/08/E24反转链表/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*定义链表*/class Node &#123; int val; Node next; public Node(int val) &#123; this.val = val; &#125;&#125;public class ReverseList &#123; /* 反转链表*/ public static Node reverseList(Node head) &#123; if (head == null || head.next == null)&#123; return head; &#125; Node reHead = null;// 定义新链表头结点 while (head != null) &#123; Node cur = head.next;// 记录下一个节点 head.next = reHead;// 将rehead节点连接到head节点上 reHead = head;// 让rehead指向head head = cur;// 将head指向下一个节点 &#125; return reHead; &#125; /**递归反转链表 */ public static Node reverseList2(Node head) &#123; if (head == null || head.next == null) return head; Node rehead = reverseList2(head.next); head.next.next = head;// 将头节点置于末端 head.next = null;// 防止链表循环 return rehead; &#125; /**打印链表 */ public static void printList(Node head) &#123; if (head == null) return; while (head != null) &#123; System.out.print(head.val + \" \"); head = head.next; &#125; &#125; public static void main(String[] args) &#123;/*测试*/ Node n1 = new Node(1); Node n2 = new Node(2); Node n3 = new Node(3); Node n4 = new Node(4); Node n5 = new Node(5); n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; // Node rehead = reverseList(n1); Node rehead = reverseList2(n1); printList(rehead); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"从链表中删除重复元素","date":"2018-04-07T15:25:02.000Z","path":"2018/04/07/从链表中删除重复元素/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;public class deleteDuplecate &#123; //法一：优点是时间复杂度低，但是需要额外的存储空间来保存遍历过的值。时间复杂度O(n) public void delete_v1(Node head)&#123; Hashtable&lt;Integer,Integer&gt; table=new Hashtable&lt;Integer,Integer&gt;(); Node temp=head; Node pre=null; //辅助链表的头节点 while(temp!=null)&#123; if(table.containsKey(temp.data)) pre.next=temp.next; else&#123; table.put(temp.data, 1); pre=temp; &#125; temp=temp.next; &#125; &#125; //法二：双重循环遍历链表,优点：不需要额外的存储空间.时间复杂度O(n^2) public void delete_v2(Node head)&#123; Node p=head; while(p!=null)&#123; Node q = p; while(q.next!=null)&#123; if(q.next.data==p.data)&#123; q.next=q.next.next; &#125;else q=q.next; &#125; p=p.next; &#125; &#125; //法三：外循环当前遍历的结点为p，内循环从表头开始遍历至p public void delete_v3(Node head)&#123; Node p=head; while(p!=null)&#123; Node q=head; while(q.next!=p &amp;&amp; q.next!=null)&#123; if(q.next.data==p.data)&#123; q.next=q.next.next; &#125;else q=q.next; &#125; p=p.next; &#125; &#125;&#125;class Node&#123; Node next=null; int data; public Node(int data)&#123; this.data=data; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E22求链表中倒数第k个节点","date":"2018-04-07T15:18:30.000Z","path":"2018/04/07/E22求链表中倒数第k个节点/","text":"为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。 如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。设计如下：依次对链表的每一个结点元素进行这样的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。此种方法将对同一批元素进行反复多次的遍历，对于链表的大部分元素而言，都要遍历k个元素，如果链表长度为n，则该算法时间复杂度为O(kn)级，效率太低。存在另一种更高效的方法。在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置。 12345678910111213141516171819public Node findElem(Node head,int k)&#123; if(k &lt; 1 || head == null)&#123; return null; &#125; Node p1 = head; Node p2 = head; for (int i = 0; i &lt; k - 1; i++) &#123; //前移k-1步 if(p1.next != null)&#123; p1 = p1.next; &#125;else &#123; return null; &#125; &#125; while (p1.next != null) &#123; p1 = p1.next; p2 = p2.next; &#125; return p2;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"链表基本代码实现","date":"2018-04-07T14:40:42.000Z","path":"2018/04/07/链表基本代码实现/","text":"链表节点定义123456789101112public class Node &#123; //为了方便，这两个变量都使用public，而不用private就不需要编写get、set方法了。 //存放数据的变量，简单点，直接为int型 public int data; //存放结点的变量,默认为null public Node next; //构造方法，在构造时就能够给data赋值 public Node(int data)&#123; this.data = data; &#125;&#125; 链表尾部增加节点12345678public void addNode(Node node)&#123; //链表中有结点，遍历到最后一个结点 Node temp = head; //一个移动的指针(把头结点看做一个指向结点的指针) while(temp.next != null)&#123; //遍历单链表，直到遍历到最后一个则跳出循环。 temp = temp.next; //往后移一个结点，指向下一个结点。 &#125; temp.next = node; //temp为最后一个结点或者是头结点，将其next指向新结点&#125; 插入结点到链表的指定位置123456789101112131415161718192021222324252627/** * insertNodeByIndex:在链表的指定位置插入结点。 * 插入操作需要知道1个结点即可，当前位置的前一个结点 * index:插入链表的位置，从1开始 * node:插入的结点 */ public void insertNodeByIndex(int index,Node node)&#123; //首先需要判断指定位置是否合法， if(index&lt;1||index&gt;length()+1)&#123; System.out.println(\"插入位置不合法。\"); return; &#125; int length = 1; //记录我们遍历到第几个结点了，也就是记录位置。 Node temp = head; //可移动的指针 while(temp.next != null)&#123;//遍历单链表 if(index == length++)&#123; //判断是否到达指定位置。 //注意，我们的temp代表的是当前位置的前一个结点。 //前一个结点 当前位置 后一个结点 //temp temp.next temp.next.next //插入操作。 node.next = temp.next; temp.next = node; return; &#125; temp = temp.next; &#125; &#125; 删除指定位置上的结点123456789101112131415161718192021222324/** * 通过index删除指定位置的结点,跟指定位置增加结点是一样的，先找到准确位置。然后进行删除操作。 * 删除操作需要知道1个结点即可：和当前位置的前一个结点。 * @param index：链表中的位置，从1开始 */ public void delNodeByIndex(int index)&#123; //判断index是否合理 if(index&lt;1 || index&gt;length())&#123; System.out.println(\"给定的位置不合理\"); return; &#125; //步骤跟insertNodeByIndex是一样的，只是操作不一样。 int length=1; Node temp = head; while(temp.next != null)&#123; if(index == length++)&#123; //删除操作。 temp.next = temp.next.next; return; &#125; temp = temp.next; &#125; &#125; 单链表进行选择排序12345678910111213141516171819202122232425/** *对链表中的结点进行排序，按照从小到大的顺序，使用选择排序。 *使用双层遍历。第一层遍历，正常遍历链表，第二层遍历，遍历第一层遍历时所用的结点后面所有结点并与之比较 */public void selectSortNode()&#123; //判断链表长度大于2，不然只有一个元素，就不用排序了。 if(length()&lt;2)&#123; System.out.println(\"无需排序\"); return; &#125; //选择排序 Node temp = head; //第一层遍历使用的移动指针，最处指向头结点，第一个结点用temp.next表示 while(temp.next != null)&#123;//第一层遍历链表，从第一个结点开始遍历 Node secondTemp = temp.next; //第二层遍历使用的移动指针，secondTemp指向第一个结点，我们需要用到是第二个结点开始，所以用secondNode.next while(secondTemp.next != null)&#123;//第二层遍历,从第二个结点开始遍历 if( temp.next.data &gt; secondTemp.next.data)&#123;//第二层中的所有结点依次与第一次遍历中选定的结点进行比较 int t = secondTemp.next.data; secondTemp.next.data = temp.next.data; temp.next.data = t; &#125; secondTemp = secondTemp.next; &#125; temp = temp.next; &#125;&#125; 计算单链表的长度12345678910111213/** * 计算单链表的长度，也就是有多少个结点 * @return 结点个数 */ public int length() &#123; int length=0; Node temp = head; while(temp.next != null)&#123; length++; temp = temp.next; &#125; return length; &#125; 遍历单链表，打印data1234567891011/** * 遍历单链表，打印所有data */ public void print()&#123; Node temp = head.next; while(temp != null)&#123; System.out.print(temp.data+\",\"); temp = temp.next; &#125; System.out.println(); &#125;","tags":[{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E06从尾到头打印链表","date":"2018-04-07T14:22:43.000Z","path":"2018/04/07/E06从尾到头打印链表/","text":"很多人第一反应是从头到尾输出将会比较简单，于是自然想到把链表中连接结点的指针反转过来，改变链表的方向即可。但该方法会改变原来链表的结构，是否允许在打印链表的时候修改链表的结构，这点取决于面试官的需求。 通常打印是一个只读操作，我们不希望打印时修改内容。 第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出，这就是典型的“后进先出”！我们用栈来实现这种结构。 既然用栈来实现，而递归本质上就是一个栈的结构，自然也可以用递归来实现。基于递归的代码看起来很简洁，但当链表非常长的时候，就会导致函数调用的层数很深，从而有可能导致函数调用栈溢出。 显然用栈基于循环实现的代码的鲁棒性要好一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Stack;public class PrintListReverse&#123; //非递归的方式，鲁棒性好 public void printListReverse(ListNode headNode)&#123; Stack&lt;ListNode&gt; stack=new Stack&lt;&gt;(); while(headNode!=null) &#123; stack.push(headNode); headNode=headNode.next; &#125; while(!stack.isEmpty()) &#123; System.out.println(stack.pop().val); &#125; &#125; //递归方式，递归在本质上就是一个栈结构 public void printListReverse_recursively(ListNode headNode)&#123; if(headNode!=null) &#123; if(headNode.next!=null) &#123; printListReverse_recursively(headNode.next); &#125; System.out.println(headNode.val); &#125; &#125; public static void main(String[] args) &#123; ListNode node1 = new ListNode(); ListNode node2 = new ListNode(); ListNode node3 = new ListNode(); node1.val=1; node2.val=2; node3.val=3; node1.next = node2; node2.next = node3; PrintListReverse plr = new PrintListReverse(); plr.printListReverse(node1); plr.printListReverse_recursively(node1); &#125;&#125;class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E05替换空格","date":"2018-04-07T13:07:41.000Z","path":"2018/04/07/E05替换空格/","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解法一：123456789public String replaceSpace(StringBuffer str) &#123; for(int k=0; k&lt;str.length(); k++)&#123; char index = str.charAt(k); if(index == ' ')&#123; str.replace(k, k+1, \"%20\"); &#125; &#125; return str.toString();&#125; 以下是java.lang.StringBuilder.replace()方法的声明 public StringBuilder replace(int start, int end, String str); 参数 start – 这是开始索引(包括)。 end – end 索引(不包括)。 str – 这是字符串，它将取代以前的内容。 解法二：思路：从字符串的后面开始复制和替换，首先准备两个指针，p1和p2，p1指向原始字符串的末尾，p2指向替换后字符串的末尾，接下来，向前移动指针p1，逐个把它指向的字符复制到p2，碰到一个空格之后，把p1向前移动1格，在p2处插入字符串“20%”，由于“20%”长度为3，同时也要把p2向前移动3格。直到p1=p2，表明所有空格都已经替换完毕。 1234567891011121314151617181920212223242526272829303132333435public class ReplaceSpace &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String str=scanner.nextLine(); scanner.close(); char[] charArray = str.toCharArray(); int length=charArray.length; int spaceNumber=0;//获取空格数量 for (char c : charArray) &#123; if(c==' ') &#123; spaceNumber++; &#125; &#125; int newLength=length+spaceNumber*2; char[] tempArray=new char[newLength];//新的数组的长度 //将原来的数组拷贝到新长度的数组中 System.arraycopy(charArray, 0, tempArray, 0, length); int indexofOriginal = length - 1; int indexofNew = newLength - 1; while (indexofOriginal&gt;=0&amp;&amp;indexofOriginal!=indexofNew) &#123; if (tempArray[indexofOriginal]==' ') &#123; tempArray[indexofNew--] = '0'; tempArray[indexofNew--] = '2'; tempArray[indexofNew--] = '%'; &#125;else &#123; tempArray[indexofNew--] = tempArray[indexofOriginal]; &#125; indexofOriginal--; &#125; for (char c : tempArray) &#123; System.out.print(c); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"WSL（Windows下Linux子系统）安装过程","date":"2018-04-06T14:23:52.000Z","path":"2018/04/06/WSL（Windows下Linux子系统）安装过程/","text":"WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，今天初步在自己的笔记本上尝试了一下，也遇到一些问题，现记录如下： 安装步骤如下： 1.控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选适用于Linux的Windows子系统，重启电脑 2.应用商店下搜索wsl，现已支持Ubuntu、openSUSE LEAP 42、SUSE Linux Enterprise、Debian、Kali Linux五个版本，直接安装即可 安装位置为： 1C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc 注：所有系统均只有命令行，没有桌面 3.根据提示设置账户名及密码 4.设置root账户密码 1sudo passwd root 系统安装完成，下面为桌面安装过程 5.在Ubuntu下我们可以通过 apt-get 命令很方便的安装/卸载软件，由于默认的软件包仓库是位于国外的，安装软件的时候就可能遇到各种网络问题或者下载到的一些资源不完整，因此就需要切换数据源为国内的镜像站点来改善 1234# 1.备份原来的数据源配置文件cp /etc/apt/sources.list /etc/apt/sources.list_backup# 2.编辑数据源配置文件vi /etc/apt/sources.list 在这里我使用的是阿里云的数据源： 12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 12# 3.更新配置apt-get update 6.下载软件 可供选择安装的X-Windows有多个：VcXsrv Windows X Server、Xming、Cygwin X Server，本文选择第一个，因为比较容易，而且据说稳定； 软件首页：https://sourceforge.net/projects/vcxsrv/ 下载软件，windows下安装好，启动Launcher，首次启动自动进入界面设置后： 选择：“one large window”，Display number设置成0，其它默认即可： 7.打开Bash，安装ubuntu-desktop, unity, and ccsm（下载桌面及解压花了很久很久） 1sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager 若报错，则改为 1sudo apt-get install ubuntu-desktop unity compiz-core 需要提醒的是，需下载650M，解压后近2.4G ，均安装在C盘 8.配置compiz窗口管理器 启动之前安装的X-Windows，在Bash中执行如下命令： 12export DISPLAY=localhost:0sudo ccsm 9.切换到Ubuntu`Bash窗口，执行以下命令并切换回VcXsrv`窗口查看效果。 1sudo compiz 附加： 安装中文支持并配置profile文件 在桌面环境打开一个终端，执行以下命令安装中文支持 1sudo apt-get -y install language-pack-zh-hans 1sudo vi /etc/profile 将以下环境变量添加到/etc/profile文件 1234export DISPLAY=localhost:0export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN.UTF-8export LC_ALL=zh_CN.UTF-8 重新加载profile 1source /etc/profile 重新生成locale 1locale-gen 卸载子系统 设置&gt;应用&gt;应用和功能，找到Ubuntu卸载即可 安装过程参考自： https://www.jianshu.com/p/bc38ed12da1d https://blog.csdn.net/u011138447/article/details/78262369 https://zhuanlan.zhihu.com/p/34884285/","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"SQL必知必会","date":"2018-04-06T13:24:54.000Z","path":"2018/04/06/SQL必知必会/","text":"一、基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 支持以下三种注释： 12345# 注释SELECT *FROM mytable; -- 注释/* 注释1 注释2 */ 二、创建表123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 三、修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 四、插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容插入到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 五、更新123UPDATE mytableSET col = valWHERE id = 1; 六、删除12DELETE FROM mytableWHERE id = 1; TRUNCATE TABLE 可以清空表，也就是删除所有行。 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 七、查询DISTINCT相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 八、排序 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 九、过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = &lt; &gt; 等于 小于 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为NULL值 应该注意到，NULL 与 0 、空字符串都不同。 AND OR 用于连接多个过滤条件。优先处理 AND，因此当一个过滤表达式涉及到多个 AND 和 OR 时，应当使用 () 来决定优先级。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 十、通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%' -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 十一、计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1*col2 AS aliasFROM mytable CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT CONCAT(TRIM(col1), ' (', TRIM(col2), ')')FROM mytable 十二、函数各个 DBMS 的函数都是不相同的，因此不可移植。 文本处理 函数 说明 LEFT() RIGHT() 左边或者右边的字符 LOWER() UPPER() 转换为小写或者大写 LTRIM() RTIM() 去除左边或者右边的空格 LENGTH() 长度 SUNDEX() 转换为语音值 其中， SOUNDEX() 是将一个字符串转换为描述其语音表示的字母数字模式的算法，它是根据发音而不是字母比较。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 12mysql&gt; SELECT NOW(); -&gt; '2017-06-28 14:01:52' 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 十三、分组分组就是把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能按该字段进行分组，也可以按该字段进行排序，例如按 col 字段排序并分组数据： 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; GROUP BY 是按照分组字段进行排序，ORDER BY 也可以以汇总字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; WHERE 过滤行，HAVING 过滤分组。行过滤应当先与分组过滤； 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING COUNT(*) &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 十四、子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 十五、连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123select a, b, cfrom A inner join Bon A.key = B.key 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123select a, b, cfrom A, Bwhere A.key = B.key 在没有条件语句的情况下返回笛卡尔积。 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456select namefrom employeewhere department = ( select department from employee where name = \"Jim\"); 自连接版本 1234select e2.namefrom employee as e1, employee as e2where e1.department = e2.department and e1.name = \"Jim\"; 连接一般比子查询的效率高。 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12select *from employee natural join department; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123select Customers.cust_id, Orders.order_numfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_id; 如果需要统计顾客的订单数，使用聚集函数。 12345select Customers.cust_id, COUNT(Orders.order_num) as num_ordfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_idgroup by Customers.cust_id; 十六、组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果为 M+N 行。 每个查询必须包含相同的列、表达式或者聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 十七、视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS count_colFROM mytableWHERE col5 = val; 十八、存储过程存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 创建存储过程命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 1234567891011delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 十九、游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 二十、触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。 INSERT 触发器包含一个名为 NEW 的虚拟表。 12CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col; DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 二十一、事务处理基本术语： 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，也就是每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 二十二、字符集基本术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 二十三、权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户1CREATE USER myuser IDENTIFIED BY 'mypassword'; 新创建的账户没有任何权限。 修改账户名1RENAME myuser TO newuser; 删除账户1DROP USER myuser; 查看权限1SHOW GRANTS FOR myuser; 授予权限1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 删除权限1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('newpassword'); 参考资料 BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"Java的序列化","date":"2018-04-06T12:39:33.000Z","path":"2018/04/06/Java的序列化/","text":"定义Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。 为什么需要序列化？第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。 第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。 如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？答：如果父类有默认构造函数的话，即使没有实现Serializable接口也不会有问题，反序列化的时候会调用默认构造函数进行初始化，否则的话反序列化的时候会抛出.InvalidClassException:异常，异常原因为no validconstructor。 实现序列化方法 实现Serializable接口 1.该接口只是一个可序列化的标志，并没有包含实际的属性和方法。 2.如果不在改方法中添加readObject()和writeObject()方法，则采取默认的序列化机制。如果添加了这两个方法之后还想利用Java默认的序列化机制，则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()两个方法。 3.为了保证安全性，可以使用transient关键字进行修饰不必序列化的属性。因为在反序列化时，private修饰的属性也能发查看到。 实现ExternalSerializable方法 自己对要序列化的内容进行控制，控制哪些属性能被序列化，哪些不能被序列化。 反序列化 实现Serializable接口的对象在反序列化时不需要调用对象所在类的构造方法，完全基于字节。 实现externalSerializable接口的方法在反序列化时会调用构造方法。 注意事项 被static修饰的属性不会被序列化 对象的类名、属性都会被序列化，方法不会被序列化 要保证序列化对象所在类的属性也是可以被序列化的 当通过网络、文件进行序列化时，必须按照写入的顺序读取对象。 反序列化时必须有序列化对象时的class文件 最好显示的声明serializableID，因为在不同的JVM之间，默认生成serializableID 可能不同，会造成反序列化失败。 常见的序列化协议有哪些 COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大。 CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。 XML&amp;SOAP XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。 JSON（JavascriptObject Notation） 这种Associativearray格式非常符合工程师对对象的理解。它保持了XML的人眼可读（Human-readable）的优点。相对于XML而言，序列化后的数据更加简洁。它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。 与XML相比，其协议比较简单，解析速度比较快。松散的Associativearray使得其具有良好的可扩展性和兼容性。 Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用 Protobuf具备了优秀的序列化协议的所需的众多典型特征标准的IDL和IDL编译器，这使得其对工程师非常友好。序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。解析速度非常快，比对应的XML快约20-100倍。提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景 Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于ApacheHadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。适合于高性能的序列化服务。 几种协议的对比 XML序列化（Xstream）无论在性能和简洁性上比较差； Thrift与Protobuf相比在时空开销方面都有一定的劣势； Protobuf和Avro在两方面表现都非常优越。 本文转载自：http://www.importnew.com/17964.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"死锁","date":"2018-04-06T10:01:38.000Z","path":"2018/04/06/死锁/","text":"死锁定义是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 活锁活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 产生条件互斥条件：一个资源一次只能被一个进程使用请求保持条件：一个进程因请求资源而阻塞时，对已经获得资源保持不放不可抢占条件：进程已获得的资源在未使用完之前不能强行剥夺循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系 检测方法两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测: 1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来 2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求 如果第二步返回真,表示出现了死锁 如何避免死锁在有些情况下死锁是可以避免的。三种用于避免死锁的技术： 加锁顺序（线程按照一定的顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 死锁检测 那么当检测出死锁时，这些线程该做些什么呢？ 给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。 银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。 死锁的解除一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。 死锁解除的主要方法有： 1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。 死锁检测与死锁恢复死锁检测算法 死锁检测的基本思想是，如果一个进程所请求的资源能够被满足，那么就让它执行，否则释放它拥有的所有资源，然后让其它能满足条件的进程执行。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"线程和进程的区别","date":"2018-04-05T14:27:48.000Z","path":"2018/04/05/线程和进程的区别/","text":"引入进程之前–多道程序设计概述多道程序设计技术是操作系统最早引入的技术，它的设计思想是允多个程序同时进入内存并运行，其目的是为了CPU的利用率，进而提高系统效率。 特点多道程序设计技术引入之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。而多道程序设计技术允许多个程序同时进入内存并运行，那就要每个程序分配程序计数器。如果内存中有四个程序在并发执行，那就需要四个程序计数器。 新技术带来的问题一个技术、一个机制的引入，一方面解决了以前棘手的问题，但同时，往往带来新的问题。多道程序设计技术也是如此。 多道程序设计技术允许多个程序同时进入内存并运行，在这样的并发环境下，如何描述、刻画这样执行的程序呢？因此引入了“进程”。 进程（Process）定义进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。 特点 进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。 进程是是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象。（虚拟技术的支持，将一个CPU变幻为多个虚拟的CPU） 系统资源（如内存、文件）以进程为单位分配。 操作系统为每个进程分配了独立的地址空间 操作系统通过“调度”把控制权交给进程。 为什么引入线程 有了进程这概念之后 应用程序可以并发地去执行了 那么为什么要在进程当中再派生出线程呢？ 为什么引入线程？首先我们引入了进程这个概念，虽然进程有利于资源的管理和保护。然而在实际应用中，进程有这样的问题： 进程切换的代价、开销比较大； 在一个进程内也需要并行执行多个程序，实现不同的功能。 进程有时候性能比较低。 引入线程有以下三个方面的考虑 应用的需要。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。 开销的考虑。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件） 性能的考虑。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。 线程(Thread)定义线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 属性 有标识符ID 有状态及状态转换，所以需要提供一些状态转换操作 不运行时需要保存上下文环境，所以需要程序计数器等寄存器 有自己的栈和栈指针 共享所在进程的地址空间和其它资源 进程与线程区别1.定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程） 2.角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位。 ​ 总线程数&lt;= CPU数量：并行运行 ​ 总线程数&gt; CPU数量：并发运行 3.资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。 4.独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。 5.开销方面。进程切换的开销较大。线程相对较小。（前面也提到过，引入线程也出于了开销的考虑。） 线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 Read moreProcess Vs Thread Difference between Process and Thread what is different between thread and process 理解Android进程创建流程（转） 本文转载整理自： http://blog.csdn.net/zheng548/article/details/54669908 https://blog.csdn.net/robbyo/article/details/8549904","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"Java后端技术","date":"2018-04-05T13:57:36.000Z","path":"2018/04/05/Java后端技术/","text":"后端主要的技术： 服务框架：Dubbo，zookeeper，Rest服务缓存：redis，ehcache消息中间件：ActiveMQ，kafka负责均衡：Nginx分布式文件：FastDFS安全框架：Apache shiro任务调度：quartz持久层框架：mybatis日志：log4j项目基础搭建。spring，springmvc环境搭建：linux下开发工具：eclipse，idea等服务器：tomcat，jetty等 目前系统主流搭建：Nginx+tomcat+mybatis+redis。针对不同的业务需求，我们会引用不同的技术。 这些主要定位于互联网企业架构 框架简介： 企业信息化系统基础功能和高效的代码生成工具，包括: 系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、 平台简介： 是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。 本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。 使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。 以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。 前端集成bootstrap 框架。响应式 目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务） 提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。 内置功能(只列了一部分功能) 1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。 2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。 3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。 4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。 5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。 6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。 7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。 8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。 9.工作流引擎：实现业务工单流转、在线流程设计器。 开发工具 1.Eclipse IDE：采用Maven项目管理，模块化。 2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。 技术选型（只列了一部分技术） 1、后端 服务框架：Dubbo、zookeeper、Rest服务 缓存：Redis、ehcache 消息中间件：ActiveMQ 负载均衡：Nginx 分布式文件：FastDFS 数据库连接池：Alibaba Druid 1.0 核心框架：Spring framework 安全框架：Apache Shiro 1.2 视图框架：Spring MVC 4.0 服务端验证：Hibernate Validator 5.1 布局框架：SiteMesh 2.4 工作流引擎：Activiti 5.15 任务调度：quartz 1.8.5 持久层框架：MyBatis 3.2 日志管理：SLF4J 1.7、Log4j 工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI 2、前端 JS框架：JQuery 1.9。 CSS框架： Bootstrap 4 metronic 客户端验证：JQuery Validation Plugin。 富文本：CKEcitor 文件管理：CKFinder 动态页签：Jerichotab 数据表格：jqGrid 对话框：jQuery jBox 树结构控件：jQuery zTree 其他组件：Bootstrap 4 metronic 3、支持 服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8 数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等 支持开发环境：Eclipse、MyEclipse、Ras、Idea等。 本文转载自网络","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"字符和字节的区别","date":"2018-04-05T13:42:35.000Z","path":"2018/04/05/字符和字节的区别/","text":"“字节”的定义字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。 “字符”的定义字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。 “字节”与“字符”它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同： ①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。 ②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 ③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。 ④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。 ⑤UTF-32编码中，世界上任何字符的存储都需要4个字节 ⑥通常在读取非文本文件时（如图片，声音，可执行文件）需要用字节数组来保存文件的内容，在下载文件时，也是用byte数组作临时的缓冲器接收文件内容。所以说byte在文件操作时是必不可少的。不管是对文件写入还是读取都要用到。byte在java中是一种是数据类型，代表一个字节，一个字节包含8个位，所以，byte类型的取值范围是-128到127。在某些程序中（尤其是和硬件有关的程序）会将某些数据存储到字节类型的变量中，比如00110010,其中每个位都代表一个参数，然后以位运算的方式对参数进行取值和赋值操作。 机器只知道字节，而字符却是语义上的单位，它是有编码的，一个字符可能编码成1个2个甚至3个4个字节。这跟字符集编码有关系，英文字母和数字是单字节，但汉字这些自然语言中的字符是多字节的。一个字节只能表示255个字符，不可能用于全球那么多种自然语言的处理，因此肯定需要多字节的存储方式。而InputStream, OutputStream它们是处理字节流的，就是说假设所有东西都是二进制的字节，而 Reader, Writer 则是字符流，它涉及到字符集的问题；按照ANSI编码标准，标点符号、数字、大小写字母都占一个字节，汉字占2个字节。按照UNICODE标准所有字符都占2个字节。 本文整理转载自网络 ​","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java中基本类型的取值范围","date":"2018-04-05T13:03:09.000Z","path":"2018/04/05/Java中基本类型的取值范围/","text":"类型 占内存大小 取值范围 数值范围 默认值 byte 1个字节 (8bit) -27~27-1 -128~127 0 short 2个字节 (16bit) -215~215-1 -32768~32767 0 int 4个字节 (32bit) -231~231-1 -2147483648~2147483647 0 long 8个字节 (64bit) -263~263-1 -9223372036854774808~9223372036854774807 0 boolean 1个字节 (8bit) ture，false false char 2个字节 (16bit) 0~216-1 ‘\\u0000’ float 4个字节 (32bit) 2-149~2128-1 1.4013E-45~3.4028E+38 0.0F double 8个字节 (64bit) 2-1074~21024-1 4.9E-324~1.7977E+308 0.0D int包装类为：java.lang.Integer。其余类型类似，均为类型大写首字母","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"悲观锁与乐观锁","date":"2018-04-04T13:34:13.000Z","path":"2018/04/04/悲观锁与乐观锁/","text":"定义1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。 2.乐观锁：即很乐观，查询数据的时候总觉得不会有人更改数据，等到更新的时候再判断这个数据有没有被人更改，有人更改了则本次更新失败。 实现过程悲观锁：悲观锁的实现采用的数据库内部的锁机制，一个典型的倚赖数据库的悲观锁调用： 1select * from account where name=\"张三\" for update; 这条sql 语句锁定了account 表中所有符合检索条件（name=”张三”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。也就是我们可以在查询数据的时候先用for update把这条数据锁住，然后更改完这条数据再提交。这样别的线程没法更新这条数据，也就保证了不会丢失更新。 悲观锁带来的性能问题。我们试想一个场景：如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果？所以我们这个时候可以使用乐观锁。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁：乐观锁的实现可以通过在表里面加一个版本号的形式，每个人更新的时候都会判断当前的版本号是否跟我查询出来得到的版本号是否一致，不一致就更新失败，一致就更新这条记录并更改版本号。 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 使用场景像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"synchronized与Lock的区别","date":"2018-04-04T13:07:54.000Z","path":"2018/04/04/synchronized与Lock的区别/","text":"类别 synchronized Lock 存在层次 Java的关键字，在jvm层面上 是一个类 锁的释放 1、已获取锁的线程执行完同步代码会释放锁 2、线程执行发生异常，jvm会让线程释放锁 需在finally中手工释放锁（unlock()方法释放锁），不然容易造成线程死锁 锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，如果尝试获取不到锁，线程可以不用一直等待 锁状态 无法判断是否获取到锁 可以判断是否获取到锁 锁类型 可重入 不可中断 非公平 可重入 可中断 可公平（两者皆可） 性能 适合代码少量的同步问题 适合代码大量的同步问题 synchronized与lock的区别 （用法）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 （用法）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。 （性能）synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。 （机制）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compareand Swap）。 synchronized底层如何实现的？用在代码块和方法上有什么区别？ synchronized用在代码块锁的是调用该方法的对象（this），也可以选择锁住任何一个对象。 synchronized用在方法上锁的是调用该方法的对象， synchronized用在代码块可以减小锁的粒度，从而提高并发性能。 无论用在代码块上还是用在方法上，都是获取对象的锁；每一个对象只有一个锁与之相关联；实现同步需要很大的系统开销作为代价，甚至可能造成死锁，所以尽量避免无谓的同步控制。 两种锁的底层实现方式： synchronized： 我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。 其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。 那有两个monitorexit呀？synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。 Lock： Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。 尽可能去使用synchronized而不要去使用LOCK synchronized与static synchronized的区别 synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized块，同一个类的两个不同实例就没有这种约束了。 那么static synchronized恰好就是要控制类的所有实例的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。 CAS（Compareand Swap）原理：CAS有三个操作数，即内存值v,旧的预期值a,新的操作数b。当我们需要更新v值为b时，首先我们判断v值是否和我们之前的所见值a相同，若相同则将v赋值为b，若不同，则什么都不做。是一种非阻塞算法（non-blocking algorithm）。 非阻塞算法（nonblocking algorithms）:一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"List接口的实现类--ArrayList、LinkedList、Vector之间的区别","date":"2018-04-04T11:54:20.000Z","path":"2018/04/04/List接口的实现类-ArrayList、LinkedList、Vector之间的区别/","text":"概述Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└Set ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长。 ArrayList不是线程安全的，只能用在单线程环境下。 允许元素为null 实现了Serializable接口，因此它支持序列化，能够通过序列化传输； 实现了RandomAccess接口，支持快速随机访问，可以以O(1)的时间复杂度去根据下标访问元素，实际上就是通过下标序号进行快速访问； 实现了Cloneable接口，能被克隆。 因其底层数据结构是数组，它占据了一块连续的内存空间（容量就是数组的length），所以它也有数组的缺点，空间效率不高。 由于数组的内存连续，可以根据下标以O(1)的时间读写(改查)元素，因此时间效率很高。 初始化 首先有三种方式来初始化： 1public ArrayList(); 默认的构造器，将会以默认的大小来初始化内部的数组 1public ArrayList(Collection&lt;? extends E&gt; c) 用一个ICollection对象来构造，并将该集合的元素添加到ArrayList 1public ArrayList(int initialCapacity) ArrayList的扩容机制使用无参构造方法时系统会默认提供默认参数10，而使用有参构造函数时我们会指定大小。在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组（通常为原数组的1.5倍）（当第一次插入元素时分配10个对象空间。假如有20个数据需要添加，那么会分别在第一次的时候，将ArrayList的容量变为10；之后扩容会按照1.5倍增长。也就是当添加第11个数据的时候，Arraylist继续扩容变为10 1.5=15，当添加第16个数据时，继续扩容变为15 1.5 =22个），旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组指向了新的数组。 扩容操作也是ArrayList 的一个性能消耗比较大的地方，所以若我们可以提前预知数据的规模，应该通过public ArrayList(int initialCapacity) {}构造方法，指定集合的大小，去构建ArrayList实例，以减少扩容次数，提高效率。 或者在需要扩容的时候，手动调用public void ensureCapacity(intminCapacity) {}方法扩容。 不过该方法是ArrayList的API，不是List接口里的，所以使用时需要强转: ((ArrayList)list).ensureCapacity(30); ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）1.List是接口类，ArrayList和LinkedList是List的实现类。 2.ArrayList是动态数组（顺序表）的数据结构。顺序表的存储地址是连续的，所以在查找比较快，但是在插入和删除时，由于需要把其它的元素顺序向后移动（或向前移动），所以比较耗时。 3.LinkedList是链表的数据结构。链表的存储地址是不连续的，每个存储地址通过指针指向，在查找时需要进行通过指针遍历元素，所以在查找时比较慢。由于链表插入时不需移动其它元素，所以在插入和删除时比较快。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。 ArrayList和LinkedList的时间复杂度ArrayList 是线性表（数组） get()：直接读取第几个下标，复杂度 O(1) add(E) ：添加元素，直接在后面添加，复杂度O（1） add(index, E) ：添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n） remove（）：删除元素，后面的元素需要逐个移动，复杂度O（n） LinkedList 是链表的操作 get()：获取第几个元素，依次遍历，复杂度O(n) add(E) ：添加到末尾，复杂度O(1) add(index, E) ：添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n) remove（）：删除元素，直接指针指向操作，复杂度O(1) 如何复制某个ArrayList到另一个ArrayList中去？1.使用clone()方法，比如ArrayList newArray = oldArray.clone(); 2.使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject); 3.使用Collections的copy方法。 注意1和2是浅拷贝(shallowcopy)。 ArrayList为什么是线程不安全的？ArrayList在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 用Collections.synchronizedList可以把一个普通ArrayList包装成一个线程安全版本的数组容器，原理同Vector是一样的，就是给所有的方法套上一层synchronized。 ArrayList和Vector的区别？ArrayList和Vector都实现了list接口，都是数组实现； 区别在于Vector在API上都加了synchronized所以它是线程安全的，以及Vector扩容时，是扩容100%，而ArrayList是扩容50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。 stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java代码执行顺序","date":"2018-04-04T08:41:44.000Z","path":"2018/04/04/Java代码执行顺序/","text":"实例： 123456789101112131415161718192021222324252627282930313233343536373839class Person&#123; static &#123; System.out.println(\"执行Person静态代码块\"); &#125; &#123; System.out.println(\"执行Person构造代码块\"); &#125; public Person()&#123; System.out.println(\"执行Person无参构造方法\"); &#125; public Person(String name)&#123; System.out.println(\"执行Person构造方法\"+ name); &#125;&#125;class Student extends Person&#123; static &#123; System.out.println(\"执行Student静态代码块\"); &#125; &#123; System.out.println(\"执行Student构造代码块\"); &#125; public Student(String name)&#123; super(name); System.out.println(\"执行Student构造方法\" + name); &#125; public Student()&#123; super(); System.out.println(\"执行Student无参构造方法\"); &#125;&#125;public class ExtendsStaticConstruct &#123; public static void main(String args[])&#123; Student student1 = new Student(\"ABC\"); System.out.println(\"--------------------\"); Student student2 = new Student(); &#125;&#125; 执行结果： 1234567891011执行Person静态代码块执行Student静态代码块执行Person构造代码块执行Person构造方法ABC执行Student构造代码块执行Student构造方法ABC--------------------执行Person构造代码块执行Person无参构造方法执行Student构造代码块执行Student无参构造方法 说明：一般的类里面包含：1、静态代码块（静态区、静态变量等）2、构造代码块（{ }中间的内容）3、构造方法 其执行顺序也是1、2、3先后执行，这里需要注意的是：考虑继承特性。子类与父类的执行顺序是：1、先执行父类的静态代码块（父1）2、子类的静态代码块（子1）3、父类构造代码块（父2）4、父类构造方法（父3）5、子类构造代码块（子2）6、子类构造方法（子3） 当一个类从被JVM装载开始，各种代码的执行顺序大致如下： 被JVM装载-&gt;执行父类的相关代码-&gt;如果有静态初始化，先执行静态初始化，且只执行一次，以后即使有该类实例化，也不会再执行-&gt;如果有静态代码块，以与静态初始化一样的方式执行-&gt;如果有new语句带来的实例化，先为成员变量分配空间，并绑定参数列表，隐式或显式执行super()，即父类的构造方法-&gt;执行非静态代码块-&gt;执行本类的构造函数-&gt;执行其他代码。 这里的执行顺序同子类构造中有一个默认的父类构造super()无关，不是执行到隐藏的super()才开始初始化父类的，类的初始化是分层初始化，即先初始化父类，再初始化子类，初始化每个类的过程中，进行类的初始化工作，先进性成员变量的初始化，成员变量的初始化顺序是：默认初始化，即int为0这种－&gt;显示初始化，例如给int型显示初始化了值－&gt;构造方法初始化，所以是这里执行到了构造方法。 但是一定要注意，父类初始化选择的构造方法却和子类中super 选择的构造相关。 转载自：https://blog.csdn.net/wuhaiwei002/article/details/55226155","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"HashTable、HashMap和ConCurrentHashMap区别","date":"2018-04-04T08:19:04.000Z","path":"2018/04/04/HashTable、HashMap和ConCurrentHashMap区别/","text":"Map├Hashtable├HashMap└WeakHashMap HashMap和HashTable的对比 1.HashMap是非线程安全的，HashTable是线程安全的。 Hashtable中的线程安全是Synchronize的（sychronized意味着在一次仅有一个线程能够更改Hashtable，就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable）；而HashMap中的方法在缺省情况下是非Synchronize的。所以在单线程环境下Hashtable比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理： Map m =Collections.synchronizedMap(new HashMap(…))。 2.HashMap的键和值都允许有null存在，而HashTable则都不行。 3.因为线程安全、哈希效率的问题，HashMap效率比HashTable的要高。 4.哈希值的使用不同 HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 5.内部实现使用的数组初始化和扩容方式不同 HashMap默认初始化数组的大小为16，要求底层数组的容量一定要为2的整数次幂，HashTable为11。HashMap扩容时乘2，使用位运算取得哈希，效率高于取模。而HashTable为乘2加1，都是素数和奇数，这样取模哈希结果更均匀。 6.继承的父类不同 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 7.两个遍历方式的内部实现上不同 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。 8.是否提供contains方法 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。 Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 HashTable和ConCurrentHashMap的对比ConcurrentHashMap引入了分割(Segment)，把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。 HashMap和ConCurrentHashMap的对比（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。 （2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。 Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？ HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读。get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。 Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"排序算法","date":"2018-04-03T13:18:20.000Z","path":"2018/04/03/排序算法/","text":"综述内排序有可以分为以下几类： (1)、插入排序：直接插入排序、二分法插入排序、希尔排序。(2)、选择排序：简单选择排序、堆排序。(3)、交换排序：冒泡排序、快速排序。(4)、归并排序(5)、基数排序 排序方法 平均情况 最好情况 最坏情况 空间复杂度 稳定性 插入排序 O(n2) O(n) O(n2) O(1) 稳定 shell排序 O(n1.3) O(n) O(n2) O(1) 不稳定 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 稳定 基数排序 O(d(r+n)) O(d(r+rd)) O(d(r+n)) O(rd+n) 稳定 注：基数排序 r表示关键字的基数 d代表长度 n代表关键字的个数 - O（n2）排序冒泡排序基本思想：比较数组相邻的两个值，把大的像泡泡一样“冒”到数组后面去，一共要执行N的平方除以2这么多次的比较和交换的操作（N为数组元素），其复杂度为Ο(n²)。 1234567891011public static void bubbleSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123;//外层循环控制排序趟数 for(int j=0;j&lt;arr.length-1-i;j++)&#123;//内层循环控制每一趟排序多少次 if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;&#125; 选择排序123456789101112131415161718public static void selectsort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; for(int i=0;i&lt;arr.length;i++)&#123; int index = i;//初始下标为i for(int j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[index])&#123; index = j; &#125; &#125; if(index != i)&#123; int temp = arr[index]; arr[index] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 插入排序基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 1234567891011public static void insertSort(int[] a) &#123; for(int i = 1; i &lt; a.length; i++) &#123;// 从数组的第二个元素开始循环将数组中的元素插入 int temp = a[i];// 设置数组中的第2个元素为第一次循环要插入的数据 int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; a[j]) &#123; a[j + 1] = a[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动 j--; &#125; a[j + 1] = temp;// 直到要插入的元素不小于第j个元素,将temp插入到数组中 &#125;&#125; shell排序基本思想：本质是插入排序，通过将数组数组的方式来将增加排序的速度，分组的方式第一次将数组的长度/2,第二次/4,当结果等于1的时候，那么将这个数组进行插入排序就完成了排序，当然分组时也是需要排序的。 123456789101112131415public static void shellSort(int[] a) &#123; // 将数组分组 for (int temp = a.length / 2; temp &gt;= 1; temp /= 2) &#123; // 这里的思路和插入排序的思路相同，通过找到前一个的数大于或者小于来进行插入 for(int i = temp; i &lt; a.length; i += temp) &#123; int temp = a[i]; int j = i - temp; while(j &gt;= 0 &amp;&amp; temp &lt; a[j]) &#123; a[j + temp] = a[j]; j -= temp; &#125; a[j + temp] = temp; &#125; &#125; &#125; O（nlog2n）排序快速排序12345678910111213141516171819public static void quickSort(int[] arr,int low,int high)&#123; if(low &gt; high)&#123; return ; &#125; int i = low, j = high,temp = arr[low]; while(i &lt; j)&#123; while( arr[j] &gt;= temp &amp;&amp; i &lt; j)&#123; j--; &#125; arr[i] = arr[j]; while(arr[i] &lt;= temp &amp;&amp; i &lt; j)&#123; i++; &#125; arr[j] = arr[i]; &#125; arr[j] = temp; quickSort(arr,low,j-1); quickSort(arr,j+1,high);&#125; 归并排序（1）稳定性：归并排序是一种稳定的排序。（2）存储结构要求：可用顺序存储结构。也易于在链表上实现。（3）时间复杂度：对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。（4）空间复杂度：需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。 注意：若用单链表做存储结构，很容易给出就地的归并排序 12345678910111213141516171819202122232425262728293031323334353637public static int[] sort(int[] a,int low,int high)&#123; int mid = (low+high)/2; if(low&lt;high)&#123; sort(a,low,mid); sort(a,mid+1,high); //左右归并 merge(a,low,mid,high); &#125; return a; &#125; public static void merge(int[] a, int low, int mid, int high) &#123; int[] temp = new int[high-low+1]; int i= low; int j = mid+1; int k=0; // 把较小的数先移到新数组中 while(i&lt;=mid &amp;&amp; j&lt;=high)&#123; if(a[i]&lt;a[j])&#123; temp[k++] = a[i++]; &#125;else&#123; temp[k++] = a[j++]; &#125; &#125; // 把左边剩余的数移入数组 while(i&lt;=mid)&#123; temp[k++] = a[i++]; &#125; // 把右边边剩余的数移入数组 while(j&lt;=high)&#123; temp[k++] = a[j++]; &#125; // 把新数组中的数覆盖nums数组 for(int x=0;x&lt;temp.length;x++)&#123; a[x+low] = temp[x]; &#125; &#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; int[] a=&#123;49,38,65,97,76,13,27,49,78,34,12,64&#125;; int arrayLength=a.length; //循环建堆 for(int i=0;i&lt;arrayLength-1;i++)&#123; //建堆 buildMaxHeap(a,arrayLength-1-i); //交换堆顶和最后一个元素 swap(a,0,arrayLength-1-i); System.out.println(Arrays.toString(a)); &#125; &#125; //对data数组从0到lastIndex建大顶堆 public static void buildMaxHeap(int[] data, int lastIndex)&#123; //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125; //交换 private static void swap(int[] data, int i, int j) &#123; int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125;&#125; 基数排序123456789101112131415161718192021222324252627282930import java.util.*;public class RadixSort &#123; // 各位装通法 public int[] radixSort(int[] A, int n) &#123; int length = n; int divisor = 1;// 定义每一轮的除数，1,10,100... //定义了10个桶，以防每一位都一样全部放入一个桶中 int[][] bucket = new int[10][length]; int[] count = new int[10];// 统计每个桶中实际存放的元素个数 int digit;// 获取元素中对应位上的数字，即装入那个桶 for (int i = 1; i &lt;= 3; i++) &#123;// 经过4次装通操作，排序完成 for (int temp : A) &#123;// 计算入桶 digit = (temp / divisor) % 10; bucket[digit][count[digit]++] = temp; &#125; int k = 0;// 被排序数组的下标 for (int b = 0; b &lt; 10; b++) &#123;// 从0到9号桶按照顺序取出 if (count[b] == 0)// 如果这个桶中没有元素放入，那么跳过 continue; for (int w = 0; w &lt; count[b]; w++) &#123; A[k++] = bucket[b][w]; &#125; count[b] = 0;// 桶中的元素已经全部取出，计数器归零 &#125; divisor *= 10; &#125; return A; &#125;&#125; 总结1.若n较小(如n≤50)，可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。2.若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；3.若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。4.快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；5.堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。6.若要求排序稳定，则可选用归并排序。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"HashMap的工作原理","date":"2018-04-03T10:28:28.000Z","path":"2018/04/03/HashMap的工作原理/","text":"“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。 “如果两个键的hashcode相同，你如何获取值对象？”面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 “如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 散列表的hash算法是根据移位来进行计算的，只能是进行＊2或者／2。因此，扩容的大小要符合这个标准，否则会造成没必要的浪费甚至错误。扩容的成本并不低，因为需要遍历一个时间复杂度为O(n)的数组，并且为其中的每个enrty进行hash计算。加入到新数组中，所以最好的情况是能够合理的使用HashMap的构造方法创建合适大小的HashMap，使得在不浪费内存的情况下，尽量减少扩容，这个就要根据业务来决定了。 “你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(racecondition)。 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ 热心的读者贡献了更多的关于HashMap的问题： 为什么String,Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。 我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点： hashing的概念 HashMap中解决碰撞的方法 equals()和hashCode()的应用，以及它们在HashMap中的重要性 不可变对象的好处 HashMap多线程的条件竞争 重新调整HashMap的大小 总结1. 什么时候会使用HashMap？它有什么特点？ 是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2.HashMap的工作原理 HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将Key传给get()方法，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap在每个链表节点中储存键值对对象。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？HashMap中解决碰撞的方法 通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法计算index，把节点再放到新的bucket中。 6.当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。 转载自：http://www.importnew.com/10620.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Hello,My Blog","date":"2018-04-02T13:17:30.000Z","path":"2018/04/02/Hello-My-Blog/","text":"纵有疾风起，人生不言弃 花了一天半的时间终于开通了自己的博客。参照网上教程从下载Node.js、Hexo到下载博客模板、调试、配置成自己想要的样子，以及学这个Markdown语法，中间也遇到了一些小小的Bug，有些百度出来了，有的自己解决了，有的还没解决就只能小小的掩盖一下，以后慢慢学习，不断进步，慢慢解决吧。 虽然是借用了Hexo的模板，并挂在Github上的免费博客，但还是希望自己以后能坚持写下去，能将学习过程中的点点滴滴都能记录下来！纵有疾风起，人生不言弃！","tags":[]},{"title":"Hello World","date":"2018-04-01T15:50:22.104Z","path":"2018/04/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]