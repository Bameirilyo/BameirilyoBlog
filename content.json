[{"title":"Java BigDecimal详解","date":"2018-07-17T03:12:56.000Z","path":"2018/07/17/Java-BigDecimal详解/","text":"1.引言借用《Effactive Java》这本书中的话，float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场啦。 2.BigDecimal简介BigDecimal 由任意精度的整数非标度值 和32 位的整数标度 (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负scale 次幂。因此，BigDecimal表示的数值是(unscaledValue × 10-scale )。 3.测试代码3.1构造函数（主要测试参数类型为double和String的两个常用构造函数）1234BigDecimal aDouble =new BigDecimal(1.22);System.out.println(\"construct with a double value: \" + aDouble);BigDecimal aString =new BigDecimal(\"1.22\");System.out.println(\"construct with a String value: \" + aString); 你认为输出结果会是什么呢？如果你没有认为第一个会输出1.22，那么恭喜你答对了，输出结果如下： 123construct with a doublevalue:1.2199999999999999733546474089962430298328399658203125construct with a String value: 1.22 JDK的描述： 参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。 这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。 当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String) 构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。 3.2 加法操作12345BigDecimal a =new BigDecimal(\"1.22\");System.out.println(\"construct with a String value: \" + a);BigDecimal b =new BigDecimal(\"2.22\");a.add(b);System.out.println(\"aplus b is : \" + a); 我们很容易会认为会输出： 12construct with a Stringvalue: 1.22a plus b is :3.44 但实际上a plus b is : 1.22 4.源码分析4.1 valueOf(doubleval)方法1234567public static BigDecimal valueOf(double val) &#123; // Reminder: a zero double returns '0.0', so we cannotfastpath // to use the constant ZERO. This might be important enough to // justify a factory approach, a cache, or a few private // constants, later. returnnew BigDecimal(Double.toString(val));//见3.1关于JDK描述的第三点 &#125; 4.2 add(BigDecimal augend)方法12345678910111213141516171819202122232425262728293031323334public BigDecimal add(BigDecimal augend) &#123; //整型数字表示的BigDecimal,例a的intCompact值为122 long xs =this.intCompact; long ys = augend.intCompact;//同上 BigInteger fst = (this.intCompact !=INFLATED) ?null :this.intVal;//初始化BigInteger的值，intVal为BigDecimal的一个BigInteger类型的属性 BigInteger snd =(augend.intCompact !=INFLATED) ?null : augend.intVal; int rscale =this.scale;//小数位数 long sdiff = (long)rscale - augend.scale;//小数位数之差 if(sdiff != 0) &#123;//取小数位数多的为结果的小数位数 if (sdiff &lt; 0) &#123; int raise =checkScale(-sdiff); rscale =augend.scale; if (xs ==INFLATED || (xs =longMultiplyPowerTen(xs,raise)) ==INFLATED) fst =bigMultiplyPowerTen(raise); &#125;else&#123; int raise =augend.checkScale(sdiff); if (ys == INFLATED ||(ys =longMultiplyPowerTen(ys,raise)) == INFLATED) snd = augend.bigMultiplyPowerTen(raise); &#125; &#125; if (xs != INFLATED &amp;&amp; ys != INFLATED) &#123; long sum = xs + ys; if ( (((sum ^ xs) &amp; (sum ^ ys))) &gt;= 0L)//判断有无溢出 return BigDecimal.valueOf(sum,rscale);//返回使用BigDecimal的静态工厂方法得到的BigDecimal实例 &#125; if (fst == null) fst = BigInteger.valueOf(xs);//BigInteger的静态工厂方法 if (snd == null) snd = BigInteger.valueOf(ys); BigInteger sum =fst.add(snd); return(fst.signum == snd.signum) ? new BigDecimal(sum,INFLATED, rscale, 0) :new BigDecimal(sum, compactValFor(sum),rscale, 0);//返回通过其他构造方法得到的BigDecimal对象 &#125; 以上只是对加法源码的分析，减乘除其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以a.add(b);虽然做了加法操作，但是a并没有保存加操作后的值，正确的用法应该是a=a.add(b); 5.总结 (1)商业计算使用BigDecimal。 (2)尽量使用参数类型为String的构造函数。 (3) BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。 (4)我们往往容易忽略JDK底层的一些实现细节，导致出现错误，需要多加注意。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"MySQL性能管理及架构设计(二)","date":"2018-07-16T02:26:00.000Z","path":"2018/07/16/MySQL性能管理及架构设计(二)/","text":"一、数据库结构优化1.1 数据库结构优化目的​ 1、减少数据冗余：（数据冗余是指在数据库中存在相同的数据，或者某些数据可以由其他数据计算得到），注意，尽量减少不代表完全避免数据冗余； 2、尽量避免数据维护中出现更新，插入和删除异常： ​ 插入异常：如果表中某个实体随着另一个实体而存在 ​ 更新异常：如果更改表中某个实体的单独属性时，需要多次进行更新 ​ 删除异常：如果删除表中的某一个实体则会导致其他实体的消失 ​ 总结：要避免异常，需要对数据库结构进行范式化设计。 ​ 3、节约数据存储空间。 ​ 4、提高查询效率。 1.2 数据库结构设计步骤​ 1、需求分析：全面了解产品设计的存储需求、数据处理需求、数据安全性与完整性； ​ 2、逻辑设计（重要）：设计数据的逻辑存储结构。数据实体之间的逻辑关系，解决数据冗余和数据维护异常。数据范式可以帮助我们设计； ​ 3、物理设计：表结构设计，存储引擎与列的数据类型； ​ 4、维护优化： 索引优化、存储结构优化。 1.3 数据库范式设计与反范式化​ 传送门：数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩 1.3.1 范式化设计的优缺点优点： 可以尽量减少数据冗余（数据表更新快体积小） 范式化的更新操作比反范式化快 范式化的表通常比反范式化更小 缺点： 对于查询需要对多个表进行关联 更难进行索引优化 1.3.2 反范式化设计的优缺点优点： 可以减少表的关联 可以更好的进行索引优化 缺点： 存在数据冗余及数据维护异常 对数据的修改需要更多的成本 1.4 物理设计1.4.1 物理设计设计的内容 定义数据库、表及字段的命名规范（可读性、表意性、长名原则） 选择合适的存储引擎 为表中的字段选择合适的数据类型 当一个列可以选择多种数据类型是，应优先选择数字类型，其次是日期或二进制类型，最后是字符类型。对于同级别的数据类型，应当优先选择占用空间小的数据类型。 建立数据库结构 相关传送门：MySQL中字段类型与合理的选择字段类型；int(11)最大长度是多少？，varchar最大长度是多少二、高可用架构设计2.1 高可用指的是通过尽量缩短因日常维护操作（计划）和突发的系统崩溃（非计划）所导致的停机时间，以提高系统和应用的可用性。 2.2 如何实现高可用 避免导致系统不可用的因素，较少系统不可用的时间 建立完善的监控及报警系统 对备份数据进行恢复测试 正确配置数据库环境 对不需要的数据进行归档和清理 增加系统的冗余，保证发生系统不可用是可以尽快恢复 避免存在单点故障： 利用SUN共享存储或DRDB磁盘复制解决MySQL单点故障（并不是一种好的方式） 利用多写集群或NDB集群来解决MySQL单点故障 利用主从复制解决单点故障 主从切换及故障转移 2.3 MMM架构(Multi-Master Replicatuion Manage)2.3.1 主要作用：监控和管理MySQL的主主复制拓扑，并在当前的主服务器失效时，进行主和主备服务器之间的主从切换和故障转移等工作。 2.1 读写分离​ ​ MaxScale：实现MySQL读写分离与负载均衡的中间件利器 三、数据库索引优化（非常重要）3.1 两种主要数据结构：B-tree和Hash3.1.1 B-tree结构​ B-tree索引的限制：​ 3.1.2 Hash结构​ Hash索引的限制： Hash索引必须进行二次查找 Hash索引无法用于排序 Hash索引不支持部分索引查找也不支持范围查找 Hash索引中Hash码的计算可能存在Hash冲突，不适合重复值很高的列，如性别，身份证比较合适。 3.1.3 MySQL常见索引和各种索引区别12345PRIMARY KEY（主键索引） ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) UNIQUE(唯一索引) ALTER TABLE `table_name` ADD UNIQUE (`column`)INDEX(普通索引) ALTER TABLE `table_name` ADD INDEX index_name ( `column` ) FULLTEXT(全文索引) ALTER TABLE `table_name` ADD FULLTEXT ( `column` )组合索引 ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` ) 普通索引：最基本的索引，没有任何限制 唯一索引：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。 主键索引：它 是一种特殊的唯一索引，不允许有空值。 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。 组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。 3.2 使用索引好处和索引缺陷3.2.1 为什么要使用索引​ 1、索引大大减少了存储引擎需要扫描的数据量； ​ 2、索引可以帮助我们进行排序以避免使用临时表； ​ 3、索引可以把随机I/O变为顺序I/O。 3.2.2 索引不是越多越好​ 1、索引会增加写操作的成本； ​ 2、太多的索引会增加查询优化器的选择时间。 索引就好比一本书的目录，它会让你更快的找到内容，显然目录（索引）并不是越多越好，假如这本书1000页，而有500页是目录，它当然效率低，目录是要占纸张的,而索引是要占磁盘空间的。 3.3 索引优化策略3.3.1 索引列上不能使用表达式和函数​ 3.3.2 前缀索引和索引列的选择性 Innodb索引列最大宽度为667个字节(utf-8 差不多255个字符),MyIsam索引类宽度最大为1000个字节，于是出现前缀索引，索引的选择性。 ​ 对于列的值较长，比如BLOB、TEXT、VARCHAR，就必须建立前缀索引，即将值的前一部分作为索引。这样既可以节约空间，又可以提高查询效率。但无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。 ​ 语法： ALTER TABLE table_name ADD KEY(column_name(prefix_length)) ​ 如何选择索引列的顺序：​ 1、经常会被使用到的列优先（选择性差的列不适合，如性别，查询优化器可能会认为全表扫描性能更好）； ​ 2、选择性高的列优先； ​ 3、宽度小的列优先（一页中存储的索引越多，降低I/O，查找越快）； 3.3.3 组合/联合索引策略​ 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。深入理解请移步：最左前缀原理与相关优化 3.3.4 覆盖索引策略​ 跟组合索引有点类似，如果索引包含所有满足查询需要的数据的索引则成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作。即索引的叶子节点上面包含了他们索引的数据(hash索引不可以)。 ​ 判断标准：使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。 优点:​ 1、可以优化缓存,减少磁盘IO操作； 2、可以减少随机IO,变随机IO操作变为顺序IO操作； 3、可以避免对InnoDB主键索引的二次查询； 4、可以避免MyISAM表进行系统调用； 无法使用覆盖索引的情况：​ 1、存储引擎不支持覆盖索引； 2、查询中使用了太多的列（如SELECT * ）； 3、使用了双%号的like查询（底层API所限制）； ​ mysql高效索引之覆盖索引 3.3.5 SQL索引优化总结口诀（套路重点） 全值匹配我最爱，最左前缀要遵守；带头大哥不能死，中间兄弟不能断；索引列上不计算，范围之后全失效；LIKE百分写最右，覆盖索引不写 *；不等空值还有or，索引失效要少用；字符单引不可丢，SQL高级也不难 ； ​ MySQL高级-索引优化 3.4 使用索引来优化查询3.4.1 利用索引排序​ 1、group by 实质是先排序后分组，遵照索引的最佳左前缀。； ​ 2、索引中所有列的方向(升序、降序)和Order By子句完全一致； ​ 3、当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置； ​ 4、如果最左列使用了范围，则排序会失效； ​ 5、where 高于having，能写在where限定的条件就不要去having去限定了 3.5 索引的维护和优化3.5.1 删除重复索引​ ​ 注：主键约束相当于(唯一约束 + 非空约束) ​ 一张表中最多有一个主键约束,如果设置多个主键,就会出现如下提示：Multiple primary key defined!!! 3.5.2 删除冗余索引​ ​ 检查工具：**pt-duplicate-key-checker**","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"MySQL性能管理及架构设计(一)","date":"2018-07-15T12:35:20.000Z","path":"2018/07/15/MySQL性能管理及架构设计(一)/","text":"一、什么影响了数据库查询速度1.1 影响数据库查询速度的四个因素​ sql查询速度、服务器硬件、网卡流量、磁盘IO 1.2 风险分析 QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。 ​ Tips：最好不要在主库上数据库备份，大型活动前取消这样的计划。 效率低下的sql：超高的QPS与TPS。 大量的并发：数据连接数被占满（max_connection默认100，一般把连接数设置得大一些）。并发量:同一时刻数据库服务器处理的请求数量 超高的CPU使用率：CPU资源耗尽出现宕机。 磁盘IO：磁盘IO性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。 1.3 网卡流量：如何避免无法连接数据库的情况 减少从服务器的数量（从服务器会从主服务器复制日志） 进行分级缓存（避免前端大量缓存失效） 避免使用select * 进行查询 分离业务网络和服务器网络 1.4 大表带来的问题（重要）1.4.1 大表的特点 记录行数巨大，单表超千万 表数据文件巨大，超过10个G 1.4.2 大表的危害1.慢查询：很难在短时间内过滤出需要的数据 查询字区分度低 -&gt; 要在大数据量的表中筛选出来其中一部分数据会产生大量的磁盘io -&gt; 降低磁盘效率 2.对DDL操作影响： ​ 建立索引需要很长时间： MySQL -v&lt;5.5 建立索引会锁表 MySQL -v&gt;=5.5 建立索引会造成主从延迟（mysql建立索引，先在组上执行，再在库上执行） ​ 修改表结构需要长时间的锁表：会造成长时间的主从延迟(‘480秒延迟’) 1.4.3 如何处理数据库上的大表 1.分库分表把一张大表分成多个小表 ​ 难点：分表主键的选择、分表后跨分区数据的查询和统计 2.大表历史数据归档（减少对前后端业务的影响） 难点：归档时间点的选择、如何进行归档操作 1.5 大事务带来的问题（重要）1.5.1 什么是事务 事务时数据库区别于其它一切文件系统的重要特性之一 事务时一组具有原子性的SQL语句，或是一个独立的工作单元 1.5.2事务的ACID属性 1、原子性（atomicity)：全部成功，全部回滚失败。银行存取款。 2、一致性（consistent)：银行转账的总金额不变。 3、隔离性（isolation)： ​ 隔离性等级（隔离性由低到高，并发行由高到低）： 未提交读(READ UNCOMMITED) 脏读,两个事务之间互相可见； 已提交读(READ COMMITED)符合隔离性的基本概念,一个事务进行时，其它已提交的事物对于该事务是可见的，即可以获取其它事务提交的数据。 可重复读(REPEATABLE READ) InnoDB的默认隔离等级。事务进行时，其它所有事务对其不可见，即多次执行读，得到的结果是一样的！ 可串行化（SERIALIZABLE） 在读取的每一行数据上都加锁，会造成大量的锁超时和锁征用，严格数据一致性且没有并发是可使用。 ​ 查看系统的事务隔离级别：show variables like &#39;%iso%&#39;; 开启一个新事务：begin; 提交一个事务：commit; 修改事物的隔离级别：set session tx_isolation=&#39;read-committed&#39;; 4、持久性(DURABILITY)：从数据库的角度的持久性，磁盘损坏就不行了 1.5.3 大事务 运行时间长，操作数据比较多的事务； ​ 风险：锁定数据太多，回滚时间长，执行时间长。 锁定太多数据，造成大量阻塞和锁超时； 回滚时所需时间比较长，且数据仍然会处于锁定； 如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟。 如何处理大事务： 避免一次处理太多数据，可以分批次处理； 移出不必要的SELECT操作，保证事务中只有必要的写操作。 二、什么影响了MySQL性能2.1 影响性能的几个方面 服务器硬件： CPU：64位的CPU一定要工作在64位的系统下；对于并发比较高的场景CPU的数量比频率重要；对于CPU密集性场景和复杂SQL则频率越高越好。 内存：选择主板所能使用的最高频率的内存；内存的大小对性能很重要，所以尽可能的大 I/O子系统：PCIe -&gt;SSD -&gt;Raid10 -&gt; 磁盘 -&gt;SAN PS：1.MySQL不支持多CPU对同一SQL并发处理 ​ 2.WEB应用中CPU数量比频率更重要 ​ 3.内存越多越好，但是对性能影响有限，并不能无限的增加性能 服务器系统（系统参数优化）。 数据库存储引擎。MyISAM：不支持事务，表级锁。InnoDB: 事务级存储引擎，完美支持支持行级锁，事务ACID特性。 数据库参数配置。 数据库结构设计和SQL语句。（重点优化） 2.2 MySQL体系结构​ 分三层：客户端 -&gt; 服务层 -&gt; 存储引擎 \\1.png) ​ MySQL是插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎! 所有跨存储引擎的功能都是在服务层实现的。 MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。 2.3 InnoDB存储引擎​ MySQL5.5及之后版本默认的存储引擎：InnoDB。 /InnoDB.png) 2.3.1 InnoDB使用表空间进行数据存储。show variables like &#39;innodb_file_per_table 如果innodb_file_per_table 为 ON 将建立独立的表空间，文件为tablename.ibd； 如果innodb_file_per_table 为 OFF 将数据存储到系统的共享表空间，文件为ibdataX（X为从1开始的整数）； .frm ：是服务器层面产生的文件，类似服务器层的数据字典，记录表结构。 2.3.2 (MySQL5.5默认)系统表空间与(MySQL5.6及以后默认)独立表空间​ 1.1 系统表空间无法简单的收缩文件大小，造成空间浪费，并会产生大量的磁盘碎片。 ​ 1.2 独立表空间可以通过optimeze table 收缩系统文件，不需要重启服务器也不会影响对表的正常访问。 ​ 2.1 如果对多个表进行刷新时，实际上是顺序进行的，会产生IO瓶颈。 ​ 2.2 独立表空间可以同时向多个文件刷新数据。 强烈建立对Innodb 使用独立表空间，优化什么的更方便，可控。 2.3.3 系统表空间的表转移到独立表空间中的方法​ 1、使用mysqldump 导出所有数据库数据（存储过程、触发器、计划任务一起都要导出 ）可以在从服务器上操作。 ​ 2、停止MYsql 服务器，修改参数（my.cnf加入innodb_file_per_table），并删除Inoodb相关文件（可以重建Data目录）。 ​ 3、重启MYSQL，并重建Innodb系统表空间。 ​ 4、 重新导入数据。 ​ 或者 Alter table 同样可以的转移，但是无法回收系统表空间中占用的空间。 2.4 InnoDB存储引擎的特性2.4.1 特性一：事务性存储引擎及两个特殊日志类型：Redo Log 和 Undo Log Innodb 是一种事务性存储引擎。 完全支持事务的ACID特性。 支持事务所需要的两个特殊日志类型：Redo Log 和Undo Log ​ Redo Log：实现事务的持久性(已提交的事务)。 ​ Undo Log：未提交的事务，独立于表空间，需要随机访问，可以存储在高性能io设备上。 Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。 2.4.2 特性二：支持行级锁 InnoDB支持行级锁。 行级锁可以最大程度地支持并发。 行级锁是由存储引擎层实现的。 2.4.3 特性三：Innodb状态检查1show engine innodb status 2.4.4 适用场景 大多数OLTP应用（5.7之后Innodb也支持全文索引和空间函数） 2.5 什么是锁2.5.1 锁 锁的主要作用是管理共享资源的并发访问 锁用于实现事物的隔离性 2.5.2 锁类型 共享锁（读锁） 独占锁（写锁） | | 写锁 | 读锁 || :–: | :—-: | :—-: || 写锁 | 不兼容 | 不兼容 || 读锁 | 不兼容 | 兼容 | 2.5.3 锁的粒度MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关 Innodb中锁的粒度： 表级锁 行级锁 ​ 将table_name加表级锁命令：lock table table_name write; 写锁会阻塞其它用户对该表的‘读写’操作，直到写锁被释放：unlock tables； 锁的开销越大，粒度越小，并发度越高。 表级锁通常是在服务器层实现的。 行级锁是存储引擎层实现的。innodb的锁机制，服务器层是不知道的 2.5.4 阻塞和死锁​ （1）阻塞是由于资源不足引起的排队等待现象 。 （2）死锁是由于两个对象在拥有一份资源的情况下申请另一份资源，而另一份资源恰好又是这两对象正持有的，导致两对象无法完成操作，且所持资源无法释放。 2.6 CSV存储引擎2.6.1 CSV存储引擎文件系统存储特点： 数据以文本方式存储在文件中 .CSV文件存储表内容 .CSM文件存储表的元数据如表状态和数据量 .frm文件存储表结构信息 2.6.2 CSV存储引擎特点： 以CSV格式进行数据存储 所有列必须都是不能为NULL的 不支持索引（每次都要全表扫描，查询效率低，不适合大表，不适合在线处理） 可以对数据文件直接编辑，保存文本文件内容 2.6.3 适合场景适合作为数据交换的中间表 电子表格 -&gt; CSV文件 -&gt; MySQL数据目录 电子表格 -&gt; CSV文件 -&gt; 其他web程序 2.7 Archive存储引擎2.7.1 Archive存储引擎文件系统存储特点 以zlib对标数据进行压缩，磁盘I/O更少 数据存储在ARZ为后缀的文件中 2.7.2 Archive存储引擎特点： 只支持insert和select操作 只允许在自增ID列上加索引 2.7.3 适合场景日志和数据采集类应用 2.8 Memory存储引擎2.8.1 Memory存储引擎文件系统存储特点 也称为HEAP存储引擎，数据保存在内存中（表结构保存在磁盘中，重启后数据丢失，表结构不丢失） 2.8.2 Memory存储引擎特点： 支持HASH索引和BTree索引：等值查找选择HASH索引；范围查找选择BTree索引较好 所有字段都为固定长度 （例如指定varchar(10)，存储时自动转换为char(10)） 不支持BLOB和TEXT等大字段 使用表级锁 最大大小由max_heap_table_size参数决定 2.8.3 Memory存储引擎表 VS临时表临时表： 系统使用临时表 超过限制使用MyISAM临时表 未超限制使用Memory create temporary table 建立的临时表 2.8.4 适合场景 用于查找或者映射表，例如邮编和地区的对应表 用于保存数据分析中产生的中间表 用于缓存周期性聚合数据的结果表 注意：Memory数据易丢失，所以要求数据可再生 2.9 Federated存储引擎2.9.1 Federated存储引擎特点 提供了访问远程MySQL服务器上表的方法 本地不存储数据，数据全部放在远程服务器上 本地需要保存表结构和远程服务器的连接信息 2.9.2 如何使用Federated存储引擎默认禁止，启用需要在启动时增加federator参数 1mysql://user_name[:password]@host_name[:port_num]/db_name/tbl_name 2.9.3适用场景偶尔的统计分析及手工查询 2.10 如何选择正确的存储引擎​ 参考条件： 事务 备份(Innobd免费在线备份) 崩溃恢复 存储引擎的特有特性 ​ 总结:Innodb大法好。 注意:尽量别使用混合存储引擎，比如回滚会出问题、在线热备问题。 /存储引擎对比.png) 2.11 配置参数2.11.1 MySQL获取配置信息路径 命令行参数 mysqld_safe –datadir=/data/sql_data 配置文件 mysqld –help –verbose |grep -A 1 ‘Default options’ /etc/my.cnf /etc/mysql/my.cnf /home/mysql/my.cnf ~/.my.cnf 2.11.2 MySQL配置参数的作用域 全局参数 set global 参数名=参数值; set @@global.参数名 :=参数值; 全局参数 set [session]l 参数名=参数值; set @@session.参数名 :=参数值; 2.11.3 内存配置相关参数 确定可以使用的内存上限。 1内存的使用上限不能超过物理内存，否则容易造成内存溢出；（对于32位操作系统，MySQL只能使用3G以下的内存。） 确定MySQL的每个连接单独使用的内存。 1234567sort_buffer_size #定义了每个线程排序缓存区的大小，MySQL在有查询、需要做排序操作时才会为每个缓冲区分配内存（直接分配该参数的全部内存）；join_buffer_size #定义了每个线程所使用的连接缓冲区的大小，如果一个查询关联了多张表，MySQL会为每张表分配一个连接缓冲，导致一个查询产生了多个连接缓冲；read_buffer_size #定义了当对一张MyISAM进行全表扫描时所分配读缓冲池大小，MySQL有查询需要时会为其分配内存，其必须是4k的倍数；read_rnd_buffer_size #索引缓冲区大小，MySQL有查询需要时会为其分配内存，只会分配需要的大小。 ​ 注意：以上四个参数是为一个线程分配的，如果有100个连接，那么需要×100。 ①MySQL是单进程多线程（而oracle是多进程），也就是说MySQL实例在系统上表现就是一个服务进程，即进程； ②MySQL实例是线程和内存组成，实例才是真正用于操作数据库文件的； 一般情况下一个实例操作一个或多个数据库；集群情况下多个实例操作一个或多个数据库。 确定需要为操作系统保留多少内存 如何为缓存池分配内存 ​ Innodb_buffer_pool_size，定义了Innodb所使用缓存池的大小，对其性能十分重要，必须足够大，但是过大时，使得Innodb 关闭时候需要更多时间把脏页从缓冲池中刷新到磁盘中； 1总内存 -（每个线程所需要的内存*连接数）- 系统保留内存 ​ key_buffer_size，定义了MyISAM所使用的缓存池的大小，由于数据是依赖存储操作系统缓存的，所以要为操作系统预留更大的内存空间； 1select sum(index_length) from information_schema.talbes where engine='myisam' ​ 注意：即使开发使用的表全部是Innodb表，也要为MyISAM预留内存，因为MySQL系统使用的表仍然是MyISAM表。 ​ max_connections 控制允许的最大连接数， 一般2000更大。 不要使用外键约束保证数据的完整性。 2.12 性能优化顺序从上到下： 数据库结构设计和SQL语句 数据库存储引擎的选择和参数配置 系统选择及优化 硬件升级","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"MySQL复制","date":"2018-07-14T07:08:19.000Z","path":"2018/07/14/MySQL复制/","text":"一、复制解决了什么 实现在不同服务器上的数据分布 利用二进制日志增量进行，不需要太多的带宽，但是使用基于行的复制在进行大批量的更改时，会对带宽带来一定的压力，特别是跨IDC环境下进行复制，应该分批进行 实现数据读取的负载均衡 需要其他组件配合完成 利用DNS轮询的方式把程序的读连接到不同的备份数据库 利用LVS,haproxy这样的代理方式 增加了数据安全性（复制不能代替备份） 实现数据库高可用和故障切换 实现数据库在线升级 二、MySQL的二进制日志2.1 介绍12MySQL服务层日志：二进制日志、慢查日志、通用日志MySQL存储引擎层日志（innodb）：重做日志、回滚日志 二进制日志记录了所有对MySQL数据库的修改事件，包括增删改查事件核对表结构的修改事件 2.2 基于段的格式(binlog_format=STATEMENT)5.7之前默认存储格式 2.2.1 优点日志记录量相对较小，节约磁盘及网络I/O（看具体SQL，只对一条记录修改或插入产生的日志量可能比row大） 2.2.2 缺点 必须记录上下文信息，保证语句在从服务器上执行结果和在主服务器上相同 特定函数如UUID(),user()这样的非确定性函数还是无法复制，可能造成复制的主从服务器数据不一致 2.3 基于段的格式(binlog_format=ROW)可以避免MySQL复制中出现的主从不一致问题 同一SQL语句修改了10000条数据的情况下，基于段的日志格式只会记录这个SQL语句，基于行的日志会有10000条记录分别记录每一行的数据修改 2.3.1 优点 使主从复制更加安全 对每一行的数据修改比基于段的复制高效 误操作二修改了数据库中的数据，同时又没有备份可以恢复是，我们可以通过分析二进制日志，对日志中记录的数据修改操作做反向处理的方式来达到恢复数据的目的 2.3.2 缺点 记录的日志量较大 binlog_row_image=[FULL|MINIMAL|NOBLOB] 2.4 基于段的格式(binlog_format=MIXED)特点： 根据SQL语句由系统在基于段和基于行的日志格式中进行选择 数据量的大小由所执行的SQL语句决定 2.5 选择建议 binlog_format=MIXED 或 binlog_format=row binlog_row_image=MINIMAL 三、二进制日志格式对复制的影响3.1 基于SQL语句的复制（SBR）：二进制日志格式使用的是statement格式优点： 生成的日志量少，节约网络传输i/O 并不强制要求主从数据库的表定义完全相同 相比于基于行的复制方式更为灵活 缺点： 对于非确定性事件，无法保证主从复制数据的一致性 对于存储过程，触发器，自定义函数进行的修改也可能造成数据不一致 相比于基于行的复制方式再从上执行时需要更 多的行锁 3.2 基于行的复制（RBR）：二进制日志格式使用的是基于行的日志格式优点： 可以应用于任何SQL的复制包括非确定函数，存储过程等 可以减少数据库锁的使用 缺点： 要求主从数据库的表结构相同，否则可能会中断复制 无法在从上单独执行触发器 3.3 混合模式：根据实际内容在以上两者间切换四、 MySQL复制工作方式 主将变更写入二进制日志 从读取主的二进制日志变更并写入到relay_log中 在从上重放relay_log中的日志： 基于SQL段的日志是在从库上重新执行记录的SQL 基于行的日志则是在从直接应用对数据库行的修改 4.1 基于日志点的复制优点： 是MySQL最早的支持的复制技术，Bug相对较少 对SQL查询没有任何限制 故障处理比较容易 缺点： 故障转移时重新获取新主的日志点信息比较困难 4.2 基于GTID的复制GTID即全局事务ID，其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID GTID=source_id:transaction_id 优点： 可以很方便的进行故障转移 从库不会丢失主库上的任何修改 缺点： 故障处理比较复杂 对执行的SQL有一定的限制 五、 MySQL复制拓扑5.1 一主多从的复制拓扑优点： 配置简单 可以用多个从库分担读负载 用途： 为不同业务使用不同的从库 将一台从库放到远程IDC，用作灾备恢复 奋斗主库的读负载 5.2 主-主复制拓扑5.2.1 主主模式下的主-主复制的配置注意事项：（产生数据冲突二造成复制链路的中断，耗费大量的时间，造成数据丢失） 两个主中所操作的表最好能够分开 使用下面两个参数控制自增ID的生成 auto_increment_increment=2 auto_increment_offset=1|2 5.2.2 主备模式下的主-主复制的配置注意事项：（只有一台主服务器对外提供服务，一台服务器处于只读状态并且只作为热备使用，在对外提供服务的主库出现故障或是计划性的维护时才会进行切换，是原来的备库成为主库，而且原来的主库会成为新的备库并处理制度或是下线状态，代维护完成后重新上线） 确保两台服务器上的初始数据相同 确保两台服务器上已经启动binlog并且有不同的service_id 在两台服务器上启用log_slave_updates参数 在初始的备库上启用read_only 六、 复制性能优化影响主从延迟的因素： 主库写入二进制日志的事件（措施：控制主库的事务大小，分割大事务） 二进制日志传输时间（措施：使用MIXED日志格式或设置set binlog_row_image = minimal） 默认情况下从只有一个SQL线程，主上并发的修改在从上变成了串行（措施：使用多线程复制，在MySQL5.7中可以按照逻辑是中的方式来分配SQL线程）","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"VARCHAR和CHAR对比","date":"2018-07-14T07:08:19.000Z","path":"2018/07/14/VARCHAR和CHAR对比/","text":"一、VARCHAR类型1.存储特点 varchar用于存储变长字符串，只占用必要的存储空间 列的最大长度小于255则只占用一个额外字节用于记录字符串长度 列的最大长度大于255则要占用两个额外字节用于记录字符串长度 2.VARCHAR长度的选择问题 使用最小的符合需求的长度 varchar(5)和varchar(200)存储“MySQL”字符串性能不同 3.VARCHAR的适用场景 字符串列的最大长度比平均长度大很多 字符串列很少被更新 使用了多字节字符集存储字符串 二、CHAR类型1. 存储特点 CHAR类型是定长的 字符串存储在CHAR类型的列中会删除末尾的空格 CHAR类型的最大宽度为255 2. CHAR的适用场景 CHAR类型是和存储数据长度近似的值（MD5值、手机号、身份证号） CHAR类型适合存储短字符串 存储经常更新的字符串列","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"Redis安装过程及报错缺少tcl解决方法","date":"2018-05-27T14:05:37.000Z","path":"2018/05/27/Redis安装过程及报错缺少tcl解决方法/","text":"1.安装过程 1234$ wget http://download.redis.io/releases/redis-4.0.9.tar.gz$ tar xzf redis-4.0.9.tar.gz$ cd redis-4.0.9$ make 2.根据提示运行make test,报错信息如下： 12345678910bameirilyo@CY-20151020KBQI:/opt/redis/redis-4.0.9$ make testcd src &amp;&amp; make testmake[1]: Entering directory '/opt/redis/redis-4.0.9/src' CC Makefile.depYou need tcl 8.5 or newer in order to run the Redis testMakefile:242: recipe for target 'test' failedmake[1]: *** [test] Error 1make[1]: Leaving directory '/opt/redis/redis-4.0.9/src'Makefile:6: recipe for target 'test' failedmake: *** [test] Error 2 3.根据报错信息You need tcl 8.5 or newer in order to run the Redis test安装tcl 8.6.8 123456wget http://downloads.sourceforge.net/tcl/tcl8.6.8-src.tar.gz sudo tar xzvf tcl8.6.8-src.tar.gzcd /usr/local/tcl8.6.1/unix/ sudo ./configure sudo make sudo make install 4.之后继续返回redis目录继续make test安装之后make即可","tags":[{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"Maven环境隔离设置","date":"2018-05-24T08:35:17.000Z","path":"2018/05/24/Maven环境隔离设置/","text":"一般分为：本地开发环境（Local）、开发环境（Dev）、测试环境（Beta）、线上环境（Prod） 在pom.xml中的build节点内增加 1234567891011&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources.$&#123;deploy.type&#125;&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;*.jsp&lt;/exclude&gt; //排除jsp，jsp不需要环境隔离 &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt;//该目录为公用 &lt;/resource&gt;&lt;/resources&gt; 在pom.xml中增加profiles节点 123456789101112131415161718192021222324252627&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;//用命令行编译时未指定环境则为默认环境 &lt;/activation&gt; &lt;properties&gt; &lt;deploy.type&gt;dev&lt;/deploy.type&gt;//与上文directory内声明的名称一致即可 &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;beta&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;beta&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;prod&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 新建对应的文件夹，并把要隔离的文件分开，公共的留下 如：新建resources.beta、resources.dev、resources.prod文件夹，并把不同的配置文件移到这几个文件夹内，如日志配置xml文件、数据库properties配置文件等等，其余applicationContext.xml、applicationContext-datasource.xml、generatorConfig.xml、mappers文件夹内文件留在resources文件夹内。 在IDEA右侧Maven Projects，选中本地开发环境对应的环境，点击import change进行更新。 Profiles文件夹下选择IDEA默认的打包环境 命令行打包方式： 12mvn clean package -Dmaven.test.skip=true -Pbeta//清除已有包、跳过单元测试、-P后跟环境名称 PS：命令行打包至target文件夹内，手动指定打包环境，不指定则由true指定。IDEA自动打包发送至tomcat中，由右侧Maven Projects指定打包环境","tags":[{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"E20表示数值的字符串","date":"2018-05-22T13:37:38.000Z","path":"2018/05/22/E20表示数值的字符串/","text":"请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100”, “5e2”, “-123”, “3.1416” 和 “-1E-16”都表示数值。但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//正则表达式解法public class Solution &#123; public boolean isNumeric(char[] str) &#123; String string = String.valueOf(str); return string.matches(\"[\\\\+\\\\-]?\\\\d*(\\\\.\\\\d+)?([eE][\\\\+\\\\-]?\\\\d+)?\"); &#125;&#125;/*以下对正则进行解释:[\\\\+\\\\-]? -&gt; 正或负符号出现与否\\\\d* -&gt; 整数部分是否出现，如-.34 或 +3.34均符合(\\\\.\\\\d+)? -&gt; 如果出现小数点，那么小数点后面必须有数字； 否则一起不出现([eE][\\\\+\\\\-]?\\\\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现， 紧接着必须跟着整数；或者整个部分都不出现*/ //参见剑指offerpublic class Solution &#123; private int index = 0; public boolean isNumeric(char[] str) &#123; if (str.length &lt; 1) return false; boolean flag = scanInteger(str); if (index &lt; str.length &amp;&amp; str[index] == '.') &#123; index++; flag = scanUnsignedInteger(str) || flag; &#125; if (index &lt; str.length &amp;&amp; (str[index] == 'E' || str[index] == 'e')) &#123; index++; flag = flag &amp;&amp; scanInteger(str); &#125; return flag &amp;&amp; index == str.length; &#125; private boolean scanInteger(char[] str) &#123; if (index &lt; str.length &amp;&amp; (str[index] == '+' || str[index] == '-') )&#123; index++; &#125; return scanUnsignedInteger(str); &#125; private boolean scanUnsignedInteger(char[] str) &#123; int start = index; while (index &lt; str.length &amp;&amp; str[index] &gt;= '0' &amp;&amp; str[index] &lt;= '9') index++; return start &lt; index; //是否存在整数 &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E19正则表达式匹配","date":"2018-05-22T13:30:29.000Z","path":"2018/05/22/E19正则表达式匹配/","text":"题目： 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 思路： 当模式中的第二个字符不是“*”时： 1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 而当模式中的第二个字符是“*”时： 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： 1、模式后移2字符，相当于x*被忽略； 2、字符串后移1字符，模式后移2字符； 3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 这里需要注意的是：Java里，要时刻检验数组是否越界。 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) &#123; return false; &#125; int strIndex = 0; int patternIndex = 0; return matchCore(str, strIndex, pattern, patternIndex);&#125; public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex, pattern, patternIndex + 2) //模式后移2，视为x*匹配0个字符 || matchCore(str, strIndex + 1, pattern, patternIndex + 2) //视为模式匹配1个字符 || matchCore(str, strIndex + 1, pattern, patternIndex); //*匹配1个，再匹配str中的下一个 &#125; else &#123; return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; &#125; //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex + 1, pattern, patternIndex + 1); &#125; return false; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E回溯法","date":"2018-05-21T07:44:42.000Z","path":"2018/05/21/E回溯法/","text":"E12回溯法题目：请设计一个函数，用来推断在一个矩阵中是否存在一条包括某字符串全部字符的路径。路径能够从矩阵中随意一格開始。每一步能够在矩阵中间向左、右、上、下移动一格。假设一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 举例分析比如在以下的3*4的矩阵中包括一条字符串”bcced”的路径。 但矩阵中不包括字符串“abcb”的路径，因为字符串的第一个字符b占领了矩阵中的第一行第二格子之后，路径不能再次进入这个格子。 a b c e s f c s a d e e 解题思路这是一个能够用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。假设路径上的第i个字符不是ch。那么这个格子不可能处在路径上的第i个位置。假设路径上的第i个字符正好是ch。那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其它格子都有4个相邻的格子。反复这个过程知道路径上的全部字符都在矩阵中找到相应的位置。 因为回朔法的递归特性，路径能够被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后。在与第n个字符相应的格子的周围都没有找到第n+1个字符。这个时候仅仅要在路径上回到第n-1个字符。又一次定位第n个字符。 因为路径不能反复进入矩阵的格子。还须要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。当矩阵中坐标为（row,col）的格子和路径字符串中下标为pathLength的字符一样时。从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下标为pathLength+1的字符。 假设4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不对，我们须要回到前一个字符(pathLength-1)，然后又一次定位。 一直反复这个过程，直到路径字符串上全部字符都在矩阵中找到合适的位置。 12345678910111213141516171819202122232425262728293031/**用一个状态数组保存之前访问过的字符，然后再分别按上，下，左，右递归*/public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; int flag[] = new int[matrix.length]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (helper(matrix, rows, cols, i, j, str, 0, flag)) return true; &#125; &#125; return false; &#125; private boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag) &#123; int index = i * cols + j; if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index] == 1) return false; if(k == str.length - 1) return true; flag[index] = 1; if (helper(matrix, rows, cols, i - 1, j, str, k + 1, flag) || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag) || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag) || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) &#123; return true; &#125; flag[index] = 0; return false; &#125;&#125; E13机器人的运动范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 12345678910111213141516171819202122232425public class Solution &#123; public int movingCount(int threshold, int rows, int cols) &#123; int flag[][] = new int[rows][cols]; //记录是否已经走过 return helper(0, 0, rows, cols, flag, threshold); &#125; private int helper(int i, int j, int rows, int cols, int[][] flag, int threshold) &#123; if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || numSum(i) + numSum(j) &gt; threshold || flag[i][j] == 1) return 0; flag[i][j] = 1; return helper(i - 1, j, rows, cols, flag, threshold) + helper(i + 1, j, rows, cols, flag, threshold) + helper(i, j - 1, rows, cols, flag, threshold) + helper(i, j + 1, rows, cols, flag, threshold) + 1; &#125; private int numSum(int i) &#123; int sum = 0; do&#123; sum += i%10; &#125;while((i = i/10) &gt; 0); return sum; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E递归","date":"2018-05-21T07:44:10.000Z","path":"2018/05/21/E递归/","text":"E10-1求斐波那契数列的第n项12345678910111213public static long fibonacci(int n) &#123; long[] a=&#123;0,1&#125;; if(n&lt;2) return a[n]; long fib1=0; long fib2=1; long fibN=0; for(int i=2;i&lt;=n;i++)&#123; fibN=fib1+fib2; fib1=fib2; fib2=fibN; &#125; return fibN;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E队列","date":"2018-05-21T07:43:46.000Z","path":"2018/05/21/E队列/","text":"E09-2用两个队列实现栈思路： 压入元素时，两队列都空，压入queue1；有一不空时，压入不空的那个队列；删除元素时，如果queue1为空，queue2有元素，将queue2的元素依次放入queue1中，直到最后一个元素，将其弹出；反之一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.ArrayDeque;import java.util.Queue;public class Demo &#123; private Queue&lt;Integer&gt; queue1 = new ArrayDeque&lt;&gt;(); private Queue&lt;Integer&gt; queue2 = new ArrayDeque&lt;&gt;(); public void push(int node) &#123; //两个栈都为空时，优先考虑queue1 if (queue1.isEmpty()&amp;&amp;queue2.isEmpty()) &#123; queue1.add(node); return; &#125; //如果queue1为空，queue2有元素，直接放入queue2 if (queue1.isEmpty()) &#123; queue2.add(node); return; &#125; if (queue2.isEmpty()) &#123; queue1.add(node); return; &#125; &#125; public int pop() &#123; //两个栈都为空时，没有元素可以弹出 if (queue1.isEmpty()&amp;&amp;queue2.isEmpty()) &#123; try &#123; throw new Exception(\"stack is empty\"); &#125; catch (Exception e) &#123; &#125; &#125;//如果queue1为空，queue2有元素，将queue2的元素依次放入queue1中，直到最后一个元素，将其弹出 if (queue1.isEmpty()) &#123; while (queue2.size()&gt;1) &#123; queue1.add(queue2.poll()); &#125; return queue2.poll(); &#125; if (queue2.isEmpty()) &#123; while (queue1.size()&gt;1) &#123; queue2.add(queue1.poll()); &#125; return queue1.poll(); &#125; return (Integer) null; &#125; public static void main(String[] args) &#123; Demo demo08 = new Demo(); demo08.push(1); demo08.push(2); demo08.push(3); demo08.push(4); System.out.println(demo08.pop()); System.out.println(demo08.pop()); demo08.push(5); System.out.println(demo08.pop()); System.out.println(demo08.pop()); System.out.println(demo08.pop()); System.out.println(demo08.pop()); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E栈","date":"2018-05-21T07:43:10.000Z","path":"2018/05/21/E栈/","text":"E09-1用两个栈实现队列思路： 压入元素时，直接压入stack1；删除元素时，先查看stack2是否为空，非空则弹出栈顶元素；stack2为空则将stack1中元素弹出并压入stack2中 12345678910111213141516171819202122232425262728293031import java.util.Stack;public class StackQueue &#123; private Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); private Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void appendTail(int node) &#123; stack1.push(node); &#125; public int deleteHead() &#123; //若两个栈都为空，抛出异常：队列为空 if(stack1.isEmpty() &amp;&amp; stack2.isEmpty()) try &#123; throw new Exception(\"队列为空\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //检查s2是否为空 if(stack2.isEmpty())&#123; //从stack1弹出元素并压入stack2 while(!stack1.isEmpty())&#123; int x = stack1.pop(); stack2.push(x); &#125; &#125; //出队 return stack2.pop(); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E字符串","date":"2018-05-21T07:41:59.000Z","path":"2018/05/21/E字符串/","text":"E58_1翻转单词顺序牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 方法一： 1234567891011121314public static String ReverseSentence(String str) &#123; if(str.trim().equals(\"\"))&#123; return str; &#125; String[] a = str.split(\" \"); StringBuffer sb = new StringBuffer(); for (int i = a.length; i &gt;0;i--)&#123; sb.append(a[i-1]); if(i &gt; 1)&#123; sb.append(\" \"); &#125; &#125; return sb.toString();&#125; 方法二： 1234567891011121314151617181920212223242526272829303132public class No58 &#123; private static void reverseSentence(String str) &#123; if(str==null) return; char[] arr=str.toCharArray(); reverse(arr,0,arr.length-1); int start=0; int end=0; for(char i=0;i&lt;arr.length;i++)&#123; if(arr[i]==' ')&#123; reverse(arr, start, end); end++; start=end; &#125;else if(i==arr.length)&#123; end++; reverse(arr, start, end); &#125;else&#123; end++; &#125; &#125; for(char c:arr)&#123; System.out.print(c); &#125; &#125; private static void reverse(char[] arr,int start,int end) &#123; for(int i=start,j=end;i&lt;=j;i++,j--)&#123; char temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; &#125;&#125; E58_2左旋字符串对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。 1234567public String LeftRotateString(String str,int n) &#123; if (str == null || str.length() == 0) return \"\"; StringBuilder sb1 = new StringBuilder(str.substring(0, n)); StringBuilder sb2 = new StringBuilder(str.substring(n, str.length())); sb2.append(sb1); return sb2.toString();&#125; 拼接最小字典序字符串给定一个字符串类型的数组strs。找到一种拼接顺序，使得将所有字符串拼接起来组成的大字符串是所有可能性中字典序最小的，并返回这个大字符串。 举例： strs=[“abc”,”de”]。可以拼成”abcde”,也可以拼成”deabc”,但前者字典顺序更小，所以返回“abcde” strs=[“b”,”ba”]. 可以拼成“bba”和“bab”，后者字典序小，返回后者“bab” 如果字符串数组长度为n，则这道题的最优解的时间复杂度O(N*logN).实质是一种排序的实现，排序的结果就是拼接的顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Prior &#123; public String findSmallest(String[] strs, int n) &#123; // 这里使用插入排序 for (int i = 1; i &lt; strs.length; i++) &#123; // 当前需要排序的元素 String target = strs[i]; // j标记当前位置 int j = i; while(j&gt;0 &amp;&amp; (target+strs[j-1]).compareTo(strs[j-1]+target) &lt; 0)&#123; strs[j] = strs[j-1]; j--; &#125; strs[j] = target; &#125; StringBuffer sb = new StringBuffer(); for(String str: strs)&#123; sb.append(str); &#125; return sb.toString(); &#125; //方法二，使用Arrays.sort()方法 public String findSmallest2(String[] strs, int n) &#123; if(strs == null)&#123; return null; &#125; Comparator&lt;String&gt; c = new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; String str1first = str1 + str2; String str2first = str2 + str1; return str1first.compareTo(str2first); &#125; &#125;; Arrays.sort(strs, c); StringBuffer str = new StringBuffer(); for(int i = 0; i &lt; n; i++)&#123; str.append(strs[i]); &#125; return str.toString(); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E查找和排序","date":"2018-05-13T11:51:59.000Z","path":"2018/05/13/E查找和排序/","text":"对某公司所有员工的年龄进行排序要求时间复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;//对某公司所有员工的年龄进行排序，要求时间复杂度为O(n)public class AgeSort &#123; public static void ageSort(int[] ages) &#123; //countAge的下标i代表年龄，countAge[i]代表年龄为i的员工人数 int[] countAge = new int[100]; //健壮性判断 if (ages == null || ages.length &lt;= 0) &#123; System.out.println(\"数组为空！\"); return; &#125; for (int i = 0; i &lt; ages.length; i++) &#123; if (ages[i] &lt; 0 || ages[i] &gt; 99) &#123; System.out.println(\"数组中存在非法年龄！\"); return; &#125; &#125; //统计每个年龄的人数，存储在countAge数组中 for (int i = 0; i &lt; ages.length; i++) countAge[ages[i]]++; //将countAge数组展开，存放在ages数组中 int index = 0;//用于记录ages数组当前下标 for (int i = 0; i &lt; countAge.length; i++) &#123; for (int j = 0; j &lt; countAge[i]; j++) &#123; ages[index] = i; index++; &#125; &#125; &#125;&#125; E11旋转数组的最小数字题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 如果直接遍历数组，时间复杂度为O(n),可以利用旋转数组的特性来解决此题，利用二分查找法实现O(logn)的查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Solution &#123; public static int minNumberInRotateArray(int[] array) &#123; if(array == null || array.length == 0) &#123; return 0; &#125; int p1 = 0;//从前往后走 int p2 = array.length-1;//从后往前走 int index = 0; //当数组发生旋转了 while(array[p1] &gt;= array[p2]) &#123; //当两个指针走到挨着的位置时，p2就是最小数了 if(p2 - p1 == 1) &#123; index = p2; break; &#125; index = (p1 + p2)/2; //如果中间位置的数既等于p1位置的数又等于P2位置的数 if(array[p1] == array[index] &amp;&amp; array[p2] == array[index]) &#123; return minInorder(array,p1,p2); &#125; //若中间位置的数位于数组1，让p1走到mid的位置 if(array[p1] &lt;= array[index]) &#123; p1 = index; &#125; else if(array[p2] &gt;= array[index]) &#123; //若中间位置的数位于数组2，让p2走到mid的位置 p2 = index; &#125; &#125; //如果没发生旋转，直接将array[0]的值返回 return array[index]; &#125; private static int minInorder(int[]array,int p1,int p2) &#123; int result = array[p1]; for (int i = p1 + 1; i &lt;= p2; i++) &#123; if(result &gt; array[i]) &#123; result = array[i]; &#125; &#125; return result; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"串的模式匹配","date":"2018-05-11T13:22:30.000Z","path":"2018/05/11/串的模式匹配/","text":"BF算法 Brute-Force算法易于理解，但是时间效率不高。它是一种带回溯的模式匹配算法，将目标串中所有长度为匹配串长度的字串依次与匹配串比较。 12345678910111213141516171819public static int bruteForce(String str1,String str2)&#123; if(str1 != null &amp;&amp; str2 != null &amp;&amp; str1.length() &gt;= str2.length())&#123; int i = 0; int j = 0; while(i &lt; str1.length() &amp;&amp; j &lt; str2.length()) &#123; if (str1.charAt(i) == str2.charAt(j)) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if(j &gt;= str2.length())&#123; return i-str2.length(); &#125; &#125; return -1;&#125; 最好情况下时间复杂度为O(m)，即主串前m个字符正好等于模式串的m个字符；最坏情况为O(nm). KMP算法算法思想：设s为目标串，t为模式串，并设i指针和j指针分别指示目标串和模式串中正待比较的字符，令i和j的初值均为0。若$s_i$=$t_i$，则i和j分别增1；否则，i不变，j退回到j=next[j]的位置(即模式串右滑)，比较$s_i$和$t_i$，若相等则指针各增1，否则j再退回到下一个j=next[j]的位置(即模式串继续右滑)，再比较$s_i$和$t_i$。以此类推，直到出现下列两种情况之一：一种情况是j退回到某个j=next[j]位置时，有$s_i$=$t_i$，则指针各增1后继续匹配；另一种情况是j退回到j=-1时，此时令i、j指针各增1，即下一次比较有$s_{i+1}$和$t_0$。 next数组详解例子： 目标串s=ababcabcacbab，模式串t=abcac 注：next数组与目标串无关，只利用模式串即可 j 0 1 2 3 4 t[j] a b c a c next[j] -1 0 0 0 1 规定：next[0]=-1，next[1]=0 求其余值为：“t[1]-t[n-1]”之间的（即去头去尾）形成的后缀字符串与模式串t的开头字符串比较，没有相同字符串则为0，有几次值为几 next[2]求法：形成字符串b，与模式串“abcac”没有相同字符，为0； next[3]求法：形成字符串bc、c，与模式串“abcac”没有相同字符，为0； next[4]求法：形成字符串bca、ca、a，a与模式串“abcac”有相同字符a，为1； 求解： 1234567891011121314第一次匹配：目标串：a b a b c a b c a c b a b 模式串：a b c a c （i=2，j=2时失败）修改为i=2，j=next[2]=0第二次匹配：目标串：a b a b c a b c a c b a b 模式串： a b c a c （i=6，j=4时失败）修改为i=6，j=next[4]=1第三次匹配：目标串：a b a b c a b c a c b a b 模式串： a b c a c （i=10，j=5时成功）返回i-t.length=5 ​","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"平衡二叉树、B树、B+树、B*树","date":"2018-05-08T12:39:23.000Z","path":"2018/05/08/平衡二叉树、B树、B-树、B-树/","text":"平衡二叉树（1）由来：平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构； （2）特点： 平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则： 非叶子节点只能允许最多两个子节点存在，每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)； 平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成正比、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如AVL、Treap、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找； 总结平衡二叉树特点： （1）非叶子节点最多拥有两个子节点； （2）非叶子节值大于左边子节点、小于右边子节点； （3）树的左右两边的层级数相差不会大于1; （4）没有值相等重复的节点; B树(B-tree)注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树; 1、概念：B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点; 2、规则： （1）树种的每个节点最多拥有m个子节点且m&gt;=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）； （2）除根节点外每个节点的关键字数量大于等于ceil(m/2)-1个小于等于m-1个，非根节点关键字数必须&gt;=2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2) （3）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子 （4）如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1; （5）所有节点关键字是按递增次序排列，并遵循左小右大原则； 最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A） 3、B树的查询流程： 如上图我要从上图中找到E字母，查找流程如下 （1）获取根节点的关键字进行比较，当前根节点关键字为M，E要小于M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）； （2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点； （3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）； 4、B树的插入节点流程 定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来; 遵循规则： （1）当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于cei(5/2)小于等于5-1（关键字数小于cei(5/2) -1就要进行节点合并，大于5-1就要进行节点拆分,非根节点关键字数&gt;=2）； （2）满足节点本身比左边节点大，比右边节点小的排序规则; 5、B树节点的删除 规则： （1）当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于cei(5/2)-1，小于等于5-1，非根节点关键字数大于2； （2）满足节点本身比左边节点大，比右边节点小的排序规则; （3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 3、特点： B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度; B+树B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别 （1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加； （2）B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接； （3）B+树的根节点关键字数量和其子节点个数相等; （4）B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样； 特点： 在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定; B*树B*树是B+树的变种，相对于B+树他们的不同之处如下： （1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b树的初始化个数为（cei(2/3m)） （2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来； 特点： 在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少； 总结：从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度； 不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的； 如果还没理解的话推荐以下资料描叙的很详细： 补充概念： 附一（二分法查找）：二分法查找原理 - 知乎专栏 附二（B、B+、B树）：[从B树、B+树、B树谈到R 树](http://blog.csdn.net/v_JULY_v/article/details/6530142/) 附三（B、B+、B*树）：end’s coding life","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"RGB字符串排序","date":"2018-05-07T13:57:01.000Z","path":"2018/05/07/RGB字符串排序/","text":"将输入的乱序R\\G\\B字符串按RRRGGGBBB方式排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str = sc.next(); char[] a = str.toCharArray(); fun(a,str.length()); for (int i = 0; i &lt; str.length(); i++)&#123; System.out.print(a[i]); &#125; &#125; public static void fun(char a[], int n) &#123; int i = -1; while (a[i+1] == 'R') &#123; i++; &#125; int j = n; while (a[j-1] == 'B') &#123; j--; &#125; int p = i+1; while (p &lt; j) &#123; if (a[p] == 'R') &#123; i++;// swap(a[p], a[i]); char temp = a[p]; a[p] = a[i]; a[i] = temp; while (a[i+1] == 'R') &#123; i++; &#125; if (a[p] == 'B') &#123; continue; &#125; &#125; else if (a[p] == 'B') &#123; j--;// swap(a[p], a[j]); char temp2 = a[p]; a[p] = a[j]; a[j] = temp2; while (a[j-1] == 'B') &#123; j--; &#125; if (a[p] == 'R') &#123; continue; &#125; &#125; p++; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"比较两个字符串A和B，确定A中是否包含B中所有的字符","date":"2018-05-07T13:48:55.000Z","path":"2018/05/07/比较两个字符串A和B，确定A中是否包含B中所有的字符/","text":"题目样例： 给出 A = “ABCD” B = “ACD”，返回 true给出 A = “ABCD” B = “AABC”， 返回 false 注意在 A 中出现的 B 字符串里的字符不需要连续或者有序。 1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String inputStr = sc.next(); //注：此题的输入为ABCD51NB;NB51，用分号分隔两个字符串 String[] strs = inputStr.split(\";\"); boolean k = compareStrings(strs[0],strs[1]); System.out.println(k); &#125; public static boolean compareStrings(String A, String B) &#123; char[] a = A.toCharArray(); char[] b = B.toCharArray(); Arrays.sort(a); Arrays.sort(b); int acount=0,bcount=0; while (acount&lt;a.length &amp;&amp; bcount&lt;b.length) &#123; if (a[acount]==b[bcount]) &#123; acount++; bcount++; &#125;else &#123; acount++; &#125; &#125; if (bcount == b.length) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; （51信用卡笔试）","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"单例模式","date":"2018-05-07T13:22:11.000Z","path":"2018/05/07/单例模式/","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1创建一个 Singleton 类。 SingleObject.java 1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(\"Hello World!\"); &#125;&#125; 步骤 2从 singleton 类获取唯一的对象。 SingletonPatternDemo.java 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 步骤 3验证输出。 1Hello World! 单例模式的几种实现方式单例模式的实现有多种方式，如下所示： 1、懒汉式，线程不安全是否 Lazy 初始化：是 是否多线程安全：否 实现难度：易 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 代码实例： 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 代码实例： 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 代码实例： 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。 代码实例： 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 5、登记式/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 代码实例： 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 6、枚举JDK 版本：JDK1.5 起 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。 代码实例： 12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"volatile关键字","date":"2018-05-03T15:01:24.000Z","path":"2018/05/03/volatile关键字/","text":"volatile 关键字的作用 保证内存的可见性 防止指令重排 注意：volatile 并不保证原子性 如何保证内存可见性volatile保证可见性的原理是在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是保证变量修改的实时可见性。 当且仅当满足以下所有条件时，才应该使用volatile变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量没有包含在具有其他变量的不变式中。 volatile使用建议： 在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。 由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。 volatile和synchronized区别 volatile不会进行加锁操作： volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。 volatile 变量作用类似于同步变量读写操作： 从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。 volatile 不如 synchronized安全： 在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。 volatile 无法同时保证内存可见性和原则性： 加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"哈希冲突","date":"2018-05-03T14:52:23.000Z","path":"2018/05/03/哈希冲突/","text":"通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种： 开放定址法这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式： $H_i$=（H（key）+$d_i$）% m i=1，2，…，n 其中H（key）为哈希函数，m 为表长，$d_i$称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种： 线性探测再散列$d_i$=1，2，3，…，m-1 这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。 二次探测再散列$d_i$=$1^2$,$-1^2$,$2^2$,$-2^2$,……，$k^2$,$-k^2$ ( k&lt;=m/2 ) 这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。 伪随机探测再散列$d_i$=伪随机数序列。 例子具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。 例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。 如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。 如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + $1^2$）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - $1^2$）% 11 = 2，此时不再冲突，将69填入2号单元。 如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。 再哈希法这种方法是同时构造多个不同的哈希函数： $H_i$=$RH_1$（key） i=1，2，…，k 当哈希地址$H_i$=$RH_1$（key）发生冲突时，再计算$H_i$=$RH_2$（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。 链地址法这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。 建立公共溢出区 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 优缺点开放散列（open hashing）/ 拉链法（针对桶链结构） 优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可 缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作 封闭散列（closed hashing）/ 开放定址法 优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的 缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"查找数组中未出现的最小正整数","date":"2018-05-03T14:51:07.000Z","path":"2018/05/03/查找数组中未出现的最小正整数/","text":"题目： 给定一个整数数组A和数组的大小n，请返回数组中未出现的最小正整数。保证数组大小小于等于500。 测试样例：[-1,2,3,4],4 返回：1 分析： 最小的没有出现的正整数：如果1没有出现,那么最小结果为1；如果1到n都出现，那么最下的结果为n+1；因此结果的范围1～n+1。数据范围最大500数据不是很大，可以考虑以空间换时间的做法。 定义一个数组res[n]，遍历数组A，如果A[i]&gt;n抛弃，不会是结果；如果A[i]&lt;n，令res[A[i]-1]=1; 遍历res 为0的输出下标加1，即为结果 1234567891011121314public int findArrayMex(int[] A, int n) &#123; int[] res = new int[n]; for (int i = 0; i &lt; n; i++) &#123; if (A[i] &gt; 0 &amp;&amp; A[i] &lt;= n)&#123; res[A[i]-1] = 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (res[i] == 0)&#123; return i+1; &#125; &#125; return n+1;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E03-2不修改数组找出重复的数","date":"2018-05-03T14:48:59.000Z","path":"2018/05/03/E03-2不修改数组找出重复的数/","text":"//不修改数组找出重复的数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//不修改数组找出重复的数public class Test &#123; public int getDuplication(int[] arr) &#123; for(int i = 0;i &lt; arr.length;i++) &#123; if(arr[i] &lt; 0 || arr[i] &gt;= arr.length) throw new IllegalArgumentException(\"输入参数不合法\"); &#125; int start = 0; int end = arr.length-1; int middle = 0; while(end &gt;= start) &#123; middle = (end + start)/2; int count = countRange(arr,start,middle); if(end == start) &#123; if(count &gt; 1) return start; else break; &#125; if(count &gt; (middle-start+1))//说明(start,middle)这个区间有重复的数 end = middle; else start = middle + 1; &#125; return -1; &#125; private int countRange(int[] arr, int start, int end) &#123; int count = 0; for(int i = 0;i &lt; arr.length;i++) &#123; if(arr[i] &gt;= start &amp;&amp; arr[i] &lt;= end) ++count; &#125; return count; &#125; public static void main(String[] args) &#123; Test test = new Test(); int[] arr = &#123;0,3,5,4,1,2,6,7,0&#125;; int value = test.getDuplication(arr); System.out.print(value); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"元素互不相邻的最大和子数组","date":"2018-05-03T14:43:27.000Z","path":"2018/05/03/元素互不相邻的最大和子数组/","text":"题目对于一个给定的数组，在其中选取其子数组，要求相邻的元素不能选取，且要保证选出的子数组元素和最大。输入数组长度及其元素，输出所选子数组的和。 测试输入74 2 6 1 3 5 8 测试输出21 分析1为了让子数组和最大，应该尽可能让它包含更多的元素，并且相邻元素不能选取，所以选取的任意两个数字之间最多间隔两个数，因为假设如果间隔了三个而子数组和最大，那么最中间的那个数一定可以选中，此时子数组和也一定比之前更大，产生矛盾。由此可见，本题只需要分析连续的三个元素的关系即可。 按照第i个元素是否被选取，前i个元素的和要么与前i−1个元素的和相同(不选取)，要么是前i−2个元素的和加上此第i个元素(选取)，这两种情况取最大。这很容易通过递归实现出来，也可以使用动态规划实现。要用动态规划，子问题的选取需要具有无后效性，即前i个元素的选取只能和之前的选取有关，和未来的情况无关。对于数组array[i]，i=0∼n−1，定义s[i]表示前i个元素的最大和，则递归式为 $$ s[i]=\\left{ \\begin{aligned} 0 &amp; &amp; i=0 \\ array[0] &amp; &amp; i=1 \\ max(s[i−1],s[i−2]+array[i]) &amp; &amp; 2≤i≤n \\end{aligned} \\right. $$ 代码11234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class NotAdjacentLine &#123; static int solution(int[] array, int n) &#123; if (n &lt; 1) return 0; if (n == 1) return array[0]; return Math.max(solution(array, n - 1), solution(array, n - 2) + array[n - 1]); &#125; static int solution2(int[] array, int n) &#123; int[] s = new int[n + 1]; s[0] = 0; s[1] = array[0]; for (int i = 2; i &lt; n + 1; i++) &#123; int takei = s[i - 2] + array[i - 1]; int skipi = s[i - 1]; s[i] = Math.max(takei, skipi); &#125; return s[n]; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] array = new int[n]; for (int i = 0; i &lt; n; i++) &#123; array[i] = sc.nextInt(); &#125; System.out.println(solution2(array, n)); &#125;&#125; 变形将上述的数组变成一个环，其他条件保持不变。 测试输入74 2 6 1 3 5 8 测试输出17 分析2对于环的情况，仍然可以利用上述直线的方法完成，只是有一些变化。首先要保证首尾元素不能同时选取，它们也属于相邻元素，这可以通过构造最优解来判断：如果首尾元素同时选取，则删除尾元素而保留首元素；其次为了找到所有可取的情况，需要对数组不断进行循环移位，从每一个元素开始，找出能够取得的最大和。这里对数组的循环移位实际上只需要做两次即可，因为我们求解s[i]时，只与s[i−1]和s[i−2]有关，环上的每一个元素位置等价，即都要能够成为这三项中的任意一项，这里位置不等价的只有四个元素：首位元素不能成为s[i−1]和s[i]，第二元素不能成为s[i]，而倒数第二元素不能成为s[i−2]，末尾元素不能成为s[i−2]和s[i−1]。所以为了满足环上元素位置等价的条件，只需要再循环移动数组两次即可，最后比较这三种情况取最大值。 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Scanner;public class NotAdjacentCircle &#123; static int solution(int[] array, int n) &#123; int[] s = new int[n + 1]; boolean[] isUsed = new boolean[n];// 元素是否使用，用于构造最优解 s[0] = 0; s[1] = array[0]; isUsed[0] = true; for (int i = 2; i &lt; n + 1; i++) &#123; int takei = s[i - 2] + array[i - 1]; int skipi = s[i - 1]; if (takei &gt; skipi) &#123; s[i] = takei; isUsed[i - 1] = true; &#125; else &#123; s[i] = skipi; isUsed[i - 1] = false; &#125; &#125; return makeCircle(s, isUsed, n); &#125; static int makeCircle(int[] s, boolean[] isUsed, int n) &#123; if (!isUsed[n - 1]) return s[n];// 最后一个元素没用，首尾不会相邻 int i = n - 1; boolean isFirstUsed = false;// 第一个元素是否使用 while (i &gt;= 0) &#123;// 构造最优解的过程 if (isUsed[i]) &#123; if (i == 0) isFirstUsed = true; i -= 2; &#125; else &#123; i -= 1; &#125; &#125; return isFirstUsed ? s[n - 1] : s[n];// 如果首尾相邻，则删除尾元素 &#125; static int[] leftShift(int[] array, int steps) &#123; int n = array.length; int[] newArray = new int[n]; System.arraycopy(array, steps, newArray, 0, n - steps); System.arraycopy(array, 0, newArray, n - steps, steps); return newArray; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] array = new int[n]; for (int i = 0; i &lt; n; i++) &#123; array[i] = sc.nextInt(); &#125; int r1 = circleSolution(array, n); array = leftShift(array, 1); int r2 = circleSolution(array, n); r2 = Math.max(r1, r2); array = leftShift(array, 1); int r3 = circleSolution(array, n); r3 = Math.max(r2, r3); System.out.println(r3); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"顺时针打印矩阵","date":"2018-05-03T14:40:49.000Z","path":"2018/05/03/顺时针打印矩阵/","text":"代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 */public class E29PrintMatrix &#123; public static void printMatrixInCircle(int[][] array)&#123; if(array == null) return; int start = 0; while(array[0].length &gt; start*2 &amp;&amp; array.length &gt;start*2)&#123; printOneCircle(array,start); start++; &#125; &#125; private static void printOneCircle(int[][] array,int start)&#123; int columns = array[0].length; int rows = array.length; int endX = columns - 1 - start; int endY = rows - 1 - start; //从左到右打印一行 for(int i = start;i &lt;= endX ;i++)&#123; int number = array[start][i]; System.out.print(number+\",\"); &#125; //从上到下打印一列 if(start &lt;endY)&#123; for(int i = start +1;i&lt;=endY;i++)&#123; int number = array[i][endX]; System.out.print(number+\",\"); &#125; &#125; //从右到左打印一行 if(start &lt; endX &amp;&amp; start &lt; endY)&#123; for(int i = endX -1;i&gt;=start;i--)&#123; int number = array[endY][i]; System.out.print(number+\",\"); &#125; &#125; //从下到上打印一列 if(start &lt;endY &amp;&amp; start &lt;endY -1)&#123; for(int i =endY -1;i&gt;=start+1;i--)&#123; int number = array[i][start]; System.out.print(number+\",\"); &#125; &#125; &#125; public static void main(String[]args)&#123; int[][] arr=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; printMatrixInCircle(arr); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"钱币拼凑（动态规划问题）","date":"2018-05-03T14:33:59.000Z","path":"2018/05/03/钱币拼凑（动态规划问题）/","text":"题目： 给你六种面额 1、5、10、20、50、100 元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0~10000的非负整数）的不同组合的个数。 123456789101112131415161718//拼凑面额public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int arr[] = &#123;1, 5, 10, 20, 50, 100&#125;; while (in.hasNext()) &#123; int n = in.nextInt(); long res[] = new long[n + 1]; res[0] = 1L; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (j &gt;= arr[i]) &#123; res[j] += res[j - arr[i]]; &#125; &#125; &#125; System.out.println(res[n]); &#125;&#125; 给你六种面额 1、5、10、20、50、100 元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0~10000的非负整数）的不同组合的个数。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"解码字符串","date":"2018-05-03T14:31:06.000Z","path":"2018/05/03/解码字符串/","text":"题目： 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: s = “3[a]2[bc]”, 返回 “aaabcbc”. s = “3[a2[c]]”, 返回 “accaccacc”. s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”. 思路： 1. 没有中括号时正常运算，将结果存入res中 2. 遇到左括号时将res及括号之前的数字分别压栈 3. 遇到右括号时将取出左括号之前的数字（stack中取出），并加上左括号前的运算结果res（stack中取出），并拼接字符串： stack中存入的是遇到左括号时①括号之前计算结果res，②括号之前的数字 12345678910111213141516171819202122232425262728293031323334353637public String decodeString(String s) &#123; String res = \"\"; // 记录'['之前的数字 Stack&lt;Integer&gt; countStack = new Stack&lt;&gt;(); // 记录'['之前的运算结果 Stack&lt;String&gt; resStack = new Stack&lt;&gt;(); int idx = 0; int curNum = 0; while (idx &lt; s.length())&#123; char ch = s.charAt(idx); if (Character.isDigit(ch)) &#123; while (Character.isDigit(s.charAt(idx))) curNum = 10 * curNum + (s.charAt(idx++) - '0'); &#125; else if (ch == '[') &#123; resStack.push(res); res = \"\";// 注意 // 此push可以放在上面的while循环中 countStack.push(curNum); curNum = 0;// 注意 idx++; // 取出计算结果，和数字 &#125; else if (ch == ']') &#123; StringBuilder temp = new StringBuilder(resStack.pop()); int repeatTimes = countStack.pop(); for (int i = 0; i &lt; repeatTimes; i++) &#123; temp.append(res); &#125; res = temp.toString(); idx++; // 字母 &#125; else &#123; res += s.charAt(idx++); &#125; &#125; return res;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"Java虚拟机","date":"2018-05-02T14:58:48.000Z","path":"2018/05/02/Java虚拟机/","text":"Java虚拟机内存的划分，每个区域的功能程序计数器(线程私有) 线程创建时创建，执行本地方法时其值为undefined。 虚拟机栈(线程私有) （栈内存）为虚拟机执行java方法服务：方法被调用时创建栈帧–&gt;局部变量表-&gt;局部变量、对象引用 如果线程请求的栈深度超出了虚拟机所允许的深度，就会出现StackOverFlowError。-Xss规定了栈的最大空间 虚拟机栈可以动态扩展，如果扩展到无法申请到足够的内存，会出现OOM 本地方法栈(线程私有) java虚拟机栈是为虚拟机执行java方法服务的，而本地方法栈则为虚拟机执使用到的Native方法服务。 Java虚拟机没有对本地方法栈的使用和数据结构做强制规定。Sun HotSpot把Java虚拟机栈和本地方法栈合二为一 会抛出StackOverFlowError和OutOfMemoryError Java堆 被所有线程共享，在Java虚拟机启动时创建，几乎所有的对象实例都存放到堆中 GC的管理的主要区域 物理不连续，逻辑上连续，并可以动态扩展，无法扩展时抛出OutOfMemoryError 方法区 用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码的数据 Sun HotSpot 虚拟机把方法区叫做永久待(Permanent Generation) 垃圾回收主要针对运行时数据区那些区域？运行时数据区的线程私有区域有：虚拟机栈，本地方法栈，程序计数器等； 栈中的栈帧随着方法的进入和退出执行入栈和出栈，每个栈帧的内存分配在编译期就已经确定；随着线程或方法的结束，内存也随着回收； 运行时数据区的线程共享区域有：方法区，堆； ​ 方法区和堆只有程序处于运行期才能确定创建那些对象，因此这部分内存分配和回收都是动态的； ​ 垃圾回收的重点区域； 对象存活判断引用计数算法给对象添加一个引用计数器，被引用时计数器值+1，引用失效计数器值-1，当计数器值为0时对象不可能再被使用； 缺点： 引入计数器是解决一个问题又附加的引入一个问题。因为每次加减操作，可能影响系统性能。 无法处理循环引用问题，因此java的垃圾回收器中，没有使用这种算法。 优点：实现简单，判断效率高（应用：FlashPlayer，Python等） 可达性分析算法将”GC Roots”对象作为起始节点，向下搜索，搜索走过的路径为引用链；当一个对象到GC Roots没有引用链时，则该对象是不可用的； 可作为”GC Roots”的对象 Java虚拟机栈中的对象 方法区中的静态成员 方法区中的常量引用对象 本地方法区中的JNI（Native方法）引用对象。 JVM垃圾处理方法(标记清除、复制、标记整理)标记-清除算法定义：先标记要回收的对象，然后统一回收 适用：存活对象较少的垃圾回收。 适用：存活对象较多的垃圾回收 缺点：1.效率低 ​ 2.标记清除后产生大量不连续的内存碎片。给大对象分配内存时没有足够连续的内存空间导致提前触发垃圾回收动作。 标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象 清除阶段：清除所有未被标记的对象 复制算法定义：将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。 适用：存活对象较少的垃圾回收。 优点：不用考虑内存碎片问题；实现简单，高效。 标记-整理算法定义：先标记要回收的对象，将存活对象移至一端，之后清理边界以外的内存。 标记阶段：先通过根节点，标记所有从根节点开始的可达对象，为被标记的为垃圾对象 整理阶段：将所有的存活对象压缩到内存的一段，之后清理边界所有的空间 分代收集算法根据对象存活周期划分新生代和老年代，采用合适的回收算法。 三种算法的比较效率：复制算法 &gt; 标记/整理算法 &gt; 标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。 内存整齐度：复制算法=标记/整理算法&gt;标记/清除算法。 内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。 JVM如何GC，新生代，老年代，持久代，都存储哪些东西，以及各个区的作用？新生代在方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 老年代 在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。而且大对象直接进入老年代 当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代 永久代即方法区。 GC详解及Minor GC和Full GC触发条件总结GC，即就是Java垃圾回收机制。目前主流的JVM（HotSpot）采用的是分代收集算法。与C++不同的是，Java采用的是类似于树形结构的可达性分析法来判断对象是否还存在引用。即：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。 GC机制 要准确理解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个方面来具体分析。 第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。（1）程序调用System.gc时可以触发；（2）系统自身来决定GC触发的时机。 系统判断GC触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。 第二：“对什么东西”笼统的认为是Java对象并没有错。但是准确来讲，GC操作的对象分为：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。 第三：“做了什么”最浅显的理解为释放对象。但是从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。 具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。 对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。 第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。 第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。 GC过程中用到的回收算法： 通过上面的GC过程不难看出，Java堆中的年轻代和老年代采用了不同的回收算法。年轻代采用了复制法；而老年代采用了标记-整理法 JVM内存空间图解 程序计数器：线程私有。是一块较小的内存，是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。 Java栈：线程私有。生命周期和线程相同。是Java方法执行的内存模型。执行每个方法都会创建一个栈帧，用于存储局部变量和操作数（对象引用）。局部变量所需要的内存空间大小在编译期间完成分配。所以栈帧的大小不会改变。存在两种异常情况：若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。 Java堆：所有线程共享。虚拟机启动时创建。存放对象实力和数组。所占内存最大。分为新生代（Young区），老年代（Old区）。新生代分Eden区，Servior区。Servior区又分为From space区和To Space区。Eden区和Servior区的内存比为8:1。 当扩展内存大于可用内存，抛OOM。 方法区：所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。又称为非堆（Non – Heap）。方法区又称“永久代”。GC很少在这个区域进行，但不代表不会回收。这个区域回收目标主要是针对常量池的回收和对类型的卸载。当内存申请大于实际可用内存，抛OOM。 本地方法栈：线程私有。与Java栈类似，但是不是为Java方法（字节码）服务，而是为本地非Java方法服务。也会抛StackOverflowError和OOM。 Minor GC ，Full GC 触发条件 Minor GC触发条件：当Eden区满时，触发Minor GC。 Full GC触发条件： 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法去空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 各个垃圾收集器是怎么工作的Serial收集器 是一个单线程的收集器，不是只能使用一个CPU。在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。 新生代采用复制算法，Stop-The-World 老年代采用标记-整理算法，Stop-The-World 简单高效，Client模式下默认的新生代收集器 ParNew收集器 ParNew收集器是Serial收集器的多线程版本 新生代采用复制算法，Stop-The-World 老年代采用标记-整理算法，Stop-The-World 它是运行在Server模式下首选新生代收集器 除了Serial收集器之外，只有它能和CMS收集器配合工作 ParNew Scanvenge收集器 类似ParNew，但更加关注吞吐量。目标是：达到一个可控制吞吐量的收集器。 停顿时间和吞吐量不可能同时调优。我们一方面希望停顿时间少，另外一方面希望吞吐量高，其实这是矛盾的。因为：在GC的时候，垃圾回收的工作总量是不变的，如果将停顿时间减少，那频率就会提高；既然频率提高了，说明就会频繁的进行GC，那吞吐量就会减少，性能就会降低。 G1收集器 是当今收集器发展的最前言成果之一，对垃圾回收进行了划分优先级的操作，这种有优先级的区域回收方式保证了它的高效率 最大的优点是结合了空间整合，不会产生大量的碎片，也降低了进行gc的频率 让使用者明确指定指定停顿时间 CMS收集器：（Concurrent Mark Sweep：并发标记清除老年代收集器） 一种以获得最短回收停顿时间为目标的收集器，适用于互联网站或者B/S系统的服务器上 初始标记(Stop-The-World)：根可以直接关联到的对象 并发标记(和用户线程一起)：主要标记过程，标记全部对象 重新标记(Stop-The-World)：由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正 并发清除(和用户线程一起)：基于标记结果，直接清理对象 并发收集，低停顿 用什么工具可以查出内存泄漏 MemoryAnalyzer：一个功能丰富的 JAVA 堆转储文件分析工具，可以帮助你发现内存漏洞和减少内存消耗 EclipseMAT：是一款开源的JAVA内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于Eclipse RCP(Rich Client Platform)，可以下载RCP的独立版本或者Eclipse的插件 JProbe：分析Java的内存泄漏。 JVM如何加载一个类的过程，双亲委派模型中有哪些方法有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？双亲委派概念 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。 加载器 启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将 &lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。、 系统（System）类加载器：由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。除了以上列举的三种类加载器，还有一种比较特殊的类型 — 线程上下文类加载器。 如果加载同一个类，该使用哪一个类？ 父类的 java是如何进行对象实例化的 ,Student s = newStudent();在内存中做了哪些事情? 加载Student.class文件进内存 在栈内存为s开辟空间 在堆内存为学生对象开辟空间 对学生对象的成员变量进行默认初始化 对学生对象的成员变量进行显示初始化 通过构造方法对学生对象的成员变量赋值 学生对象初始化完毕，把对象地址赋值给s变量 了解过JVM调优没，基本思路是什么","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"HTTP的报文结构","date":"2018-05-01T14:56:49.000Z","path":"2018/05/01/HTTP的报文结构/","text":"HTTP 报文有 请求报文 和 响应报文 两种。请求报文：从客户向服务器发送请求报文。响应报文：从服务端到客户的回答。 由于 HTTP 是面向文本的，因此在报文中的每一个字段都是一些 ASCII 码串，因此各个字段的长度是不确定的。这也造成了 HTTP 报文结构的统一性，不然无法解析出数据。 HTTP的这两种报文都由三部分组成：开始行、首部行、实体主体。 开始行区分请求报文与响应报文 请求报文的开始行 也叫请求行，由 方法、[空格]、URL、[空格]、HTTP版本 组成。 方法： 向请求资源指定的资源发送请求报文的方法，其作用是可以指定请求的资源按期望产生某种行为。URL : 链接HTTP版本：目前有 HTTP/1.0、HTTP/1.1、HTTP/2.0 版本，其中 HTTP1.0 版本使用较广泛。 以下为 HTTP/1.0 和 HTTP/1.1 支持的方法： 方法 说明 支持的HTTP协议版本 GET 请求读取由URL所标志的信息 1.0、1.1 POST 给服务器添加信息（例如，注释） 1.0、1.1 PUT 在指明的URL下存储一个文档 1.0、1.1 HEAD 请求读取由URL所标志的信息的首部 1.0、1.1 DELETE 删除URL所标志的资源 1.0、1.1 OPTIONS 询问URL所支持的方法 1.1 TRACE 用来进行环回测试的请求报文 1.1 CONNECT 用于代理服务器 1.1 LINK 建立和资源之间的联系 1.0 响应报文的开始行 也叫响应行，由 HTTP 版本、[空格]、状态码、[空格]、状态码描述组成。 状态码（Status-Code）都是三位数字的，分为 5 大类共 33 种。如： 状态码 说明 请求行例子 1xx 表示通知信息的，如请求收到了或正在进行处理 2xx 表示成功 HTTP/1.1 200 OK 3xx 表示重定向 4xx 表示客户端的差错，如请求链接为不存在 HTTP/1.1 404 Not Found 5xx 表示服务器的差错 常见状态码说明： 200 OK： 表示客户端请求成功 400 Bad Request：表示客户端请求有语法错误，不能被服务器端解析 401 Unauthonzed：表示请求未经授权，该状态码必须与WWW-Authenticate报文头一起使用 404 Not Found：请求的资源不存在，例如输入了错误的url 500 Internal Server Error：表示服务器发生了不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable：表示服务器当前不能处理客户端的请求，在一段时间后服务器可能恢复正常 首部行1.是用来说明浏览器、服务器或报文主体的一些信息。2.可以有好几行，也可以不使用3.每个首部行都是由 首部字段名、[空格] 和 值 组成4.每个首部行在结束地方都有 CRLF（『回车』和『换行』符） HTTP 首部字段分为 4 种： 通用首部字段、请求首部字段、响应首部字段、实体首部字段。 响应头： 一般情况下，响应头会包含以下，甚至更多的信息。 Location：服务器返回给客户端，用于重定向到新的位置 Server： 包含服务器用来处理请求的软件信息及版本信息 Vary：标识不可缓存的请求头列表 Connection: 连接方式。 对于==请求端==来讲：close是告诉服务端，断开连接，不用等待后续的求请了。keeplive则是告诉服务端，在完成本次请求的响应后，保持连接，等待本次连接后的后续请求。 对于==响应端==来讲：close表示连接已经关闭。keeplive则表示连接保持中，可以继续处理后续请求。Keep-Alive表示如果请求端保持连接，则该请求头部信息表明期望服务端保持连接多长时间（秒），例如300秒，应该这样写Keep-Alive:300 实体主体在请求报文中，一般是 post/put 提交的表单信息。与首部行之间有 CRLF 即空行。 注意：实体主体与首部行隔一空行 总结HTTP 报文有 请求报文 和 响应报文 两种。HTTP的这两种报文都由三部分组成：开始行、首部行、实体主体。开始行可用于区分两种报文。首部行都是由 首部字段名 和 值 组成，每个首部行在结束地方都有 CRLF首部行和实体主体间有 CRLF PS： 1，URI、URL和URN之间的区别 URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成 URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源 URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化 HTTP规范将更通用的概念URI作为其资源标识符，但是实际上，HTTP应用程序处理的只是URI的URL子集","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"TCP的拥塞控制","date":"2018-05-01T14:25:48.000Z","path":"2018/05/01/TCP的拥塞控制/","text":"一般原理：发生拥塞控制的原因：资源(带宽、交换节点的缓存、处理机)的需求&gt;可用资源。 作用：拥塞控制就是为了防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。拥塞控制要做的都有一个前提：就是网络能够承受现有的网络负荷。 对比流量控制：拥塞控制是一个全局的过程，涉及到所有的主机、路由器、以及降低网络相关的所有因素。流量控制往往指点对点通信量的控制。是端对端的问题。 ​ 拥塞窗口：发送方为一个动态变化的窗口叫做拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度。发送方让自己的发送窗口=拥塞窗口，但是发送窗口不是一直等于拥塞窗口的，在网络情况好的时候，拥塞窗口不断的增加，发送方的窗口自然也随着增加，但是接受方的接受能力有限，在发送方的窗口达到某个大小时就不在发生变化了。 ​ 发送方如果知道网络拥塞了呢？发送方发送一些报文段时，如果发送方没有在时间间隔内收到接收方的确认报文段，则就可以认为网络出现了拥塞。 ​ 慢启动算法的思路：主机开发发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。 ​ 例子：开始发送方先设置cwnd（拥塞窗口）=1,发送第一个报文段M1，接收方接收到M1后，发送方接收到接收方的确认后，把cwnd增加到2，接着发送方发送M2、M3，发送方接收到接收方发送的确认后cwnd增加到4，慢启动算法每经过一个传输轮次（认为发送方都成功接收接收方的确认），拥塞窗口cwnd就加倍。 拥塞避免：为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量（我也不知道这个到底是什么，就认为他是一个拥塞控制的标识）,它的用法： 当cwnd &lt; ssthresh,使用慢启动算法， 当cwnd &gt; ssthresh,使用拥塞控制算法，停用慢启动算法。 当cwnd = ssthresh，这两个算法都可以。 拥塞避免的思路：是让cwnd缓慢的增加而不是加倍的增长，每经历过一次往返时间就使cwnd增加1，而不是加倍，这样使cwnd缓慢的增长，比慢启动要慢的多。 ​ 无论是慢启动算法还是拥塞避免算法，只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半（&gt;=2），cwnd(拥塞窗口)设置为1，然后在使用慢启动算法，这样做的目的能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增长块的多。 实例：1.TCP连接进行初始化的时候，cwnd=1,ssthresh=16。 ​ 2.在慢启动算法开始时，cwnd的初始值是1，每次发送方收到一个ACK拥塞窗口就增加1，当ssthresh =cwnd时，就启动拥塞控制算法，拥塞窗口按照规律增长， ​ 3.当cwnd=24时，网络出现超时，发送方收不到确认ACK，此时设置ssthresh=12,(二分之一cwnd),设置cwnd=1,然后开始慢启动算法，当cwnd=ssthresh=12,慢启动算法变为拥塞控制算法，cwnd按照线性的速度进行增长。 AIMD(加法增大乘法减小) 乘法减小：无论在慢启动阶段还是在拥塞控制阶段，只要网络出现超时，就是将cwnd置为1，ssthresh置为cwnd的一半，然后开始执行慢启动算法（cwnd&lt;ssthresh）。 加法增大：当网络频发出现超时情况时，ssthresh就下降的很快，为了减少注入到网络中的分组数，而加法增大是指执行拥塞避免算法后，是拥塞窗口缓慢的增大，以防止网络过早出现拥塞。 ​ 这两个结合起来就是AIMD算法，是使用最广泛的算法。拥塞避免算法不能够完全的避免网络拥塞，通过控制拥塞窗口的大小只能使网络不易出现拥塞。 快重传： ​ 快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。 ! ​ 快恢复： 当发送发连续接收到三个重复确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。 此时不执行慢启动算法，而是把cwnd设置为ssthresh减半后的数值， 然后执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 摘抄自：计算机网络(谢希仁第五版)。","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"面试题","date":"2018-04-26T07:34:47.000Z","path":"2018/04/26/面试题/","text":"1.三路快排 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private void quickSort(int[] a, int left, int right) &#123; if (right &lt;= left) return; /* * 工作指针 * p指向序列左边等于pivot元素的位置 * q指向序列右边等于Pivot元素的位置 * i指向从左向右扫面时的元素 * j指向从右向左扫描时的元素 */ int p, q, i, j; int pivot;// 锚点 i = p = left; j = q = right - 1; /* * 每次总是取序列最右边的元素为锚点 */ pivot = a[right]; while (true) &#123; /* * 工作指针i从右向左不断扫描，找小于或者等于锚点元素的元素 */ while (i &lt; right &amp;&amp; a[i] &lt;= pivot) &#123; /* * 找到与锚点元素相等的元素将其交换到p所指示的位置 */ if (a[i] == pivot) &#123; swap(a, i, p); p++; &#125; i++; &#125; /* * 工作指针j从左向右不断扫描，找大于或者等于锚点元素的元素 */ while (left &lt;= j &amp;&amp; a[j] &gt;= pivot) &#123; /* * 找到与锚点元素相等的元素将其交换到q所指示的位置 */ if (a[j] == pivot) &#123; swap(a, j, q); q--; &#125; j--; &#125; /* * 如果两个工作指针i j相遇则一趟遍历结束 */ if (i &gt;= j) break; /* * 将左边大于pivot的元素与右边小于pivot元素进行交换 */ swap(a, i, j); i++; j--; &#125; /* * 因为工作指针i指向的是当前需要处理元素的下一个元素 * 故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间 */ i--; p--; while (p &gt;= left) &#123; swap(a, i, p); i--; p--; &#125; /* * 因为工作指针j指向的是当前需要处理元素的上一个元素 * 故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间 */ j++; q++; while (q &lt;= right) &#123; swap(a, j, q); j++; q++; &#125; /* * 递归遍历左右子序列 */ quickSort(a, left, i); quickSort(a, j, right); &#125; private void quick(int[] a) &#123; if (a.length &gt; 0) &#123; quickSort(a, 0, a.length - 1); &#125; &#125; private void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 2. 12345678910111213141516171819202122/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/ int SelectPivotMedianOfThree(int arr[],int low,int high) &#123; int mid = low + ((high - low) &gt;&gt; 1); //计算数组中间的元素的下标 //使用三数取中法选择枢轴 if (arr[mid] &gt; arr[high]) //目标: arr[mid] &lt;= arr[high] &#123; swap(arr[mid],arr[high]); &#125; if (arr[low] &gt; arr[high]) //目标: arr[low] &lt;= arr[high] &#123; swap(arr[low],arr[high]); &#125; if (arr[mid] &gt; arr[low]) //目标: arr[low] &gt;= arr[mid] &#123; swap(arr[mid],arr[low]); &#125; //此时，arr[mid] &lt;= arr[low] &lt;= arr[high] return arr[low]; //low的位置上保存这三个位置中间的值 //分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void QSort(int arr[],int low,int high) &#123; int first = low; int last = high; int left = low; int right = high; int leftLen = 0; int rightLen = 0; if (high - low + 1 &lt; 10) &#123; InsertSort(arr,low,high); return; &#125; //一次分割 int key = SelectPivotMedianOfThree(arr,low,high); //使用三数取中法选择枢轴 while(low &lt; high) &#123; while(high &gt; low &amp;&amp; arr[high] &gt;= key) &#123; if (arr[high] == key)&#123; //处理相等元素 swap(arr[right],arr[high]); right--; rightLen++; &#125; high--; &#125; arr[low] = arr[high]; while(high &gt; low &amp;&amp; arr[low] &lt;= key) &#123; if (arr[low] == key) &#123; swap(arr[left],arr[low]); left++; leftLen++; &#125; low++; &#125; arr[high] = arr[low]; &#125; arr[low] = key; //一次快排结束 //把与枢轴key相同的元素移到枢轴最终位置周围 int i = low - 1; int j = first; while(j &lt; left &amp;&amp; arr[i] != key) &#123; swap(arr[i],arr[j]); i--; j++; &#125; i = low + 1; j = last; while(j &gt; right &amp;&amp; arr[i] != key) &#123; swap(arr[i],arr[j]); i++; j--; &#125; QSort(arr,first,low - 1 - leftLen); QSort(arr,low + 1 + rightLen,last); &#125;","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Linux","date":"2018-04-25T13:06:24.000Z","path":"2018/04/25/Linux/","text":"在Linux系统中,一切设备都看作文件。而每打开一个文件,就有一个代表该打开文件的文件描述符。程序启动时默认打开三个I/O设备文件: 文件描述符0：标准输入文件stdin 文件描述符1：标准输出文件stdout 文件描述符2：标准错误输出文件stderr 在64位操作系统中： | char | 1个字节(固定) || :———–: | :——————————————: || (即指针变量) | 8个字节 || short int | 2个字节(固定) || int | 4个字节(固定) || unsigned int | 4个字节(固定) || float | 4个字节(固定) || double | 8个字节(固定) || long | 8个字节 || unsigned long | 8个字节(变化其实就是寻址控件的地址长度数值) || long long | 8个字节(固定) | 如果您想列出当前目录以及子目录下所有扩展名为“.txt”的文件，可以使用的命令是（find -name“*.txt”） 12find . &quot;.txt&quot; 查找&quot;.&quot;，&quot;.txt&quot;这两个目录ls 只能显示当前目录的文件 vi编辑器中，dd：删除一整行，yy：复制一整行，pp：黏贴 权限 u-g-o：用户-组内用户-其他用户 权限类型 读 写 可执行，r-w-x：用4-2-1表示。 总共10位：1 3 3 3 分别对应 类型 （根）用户权限 组内用户权限 其他用户权限 在Linux中查看ARP缓存记录的命令是 “arp –a” -a&lt;主机&gt;：显示arp缓冲区的所有条目； -H&lt;地址类型&gt;：指定arp指令使用的地址类型；-d&lt;主机&gt;：从arp缓冲区中删除指定主机的arp条目； -D：使用指定接口的硬件地址；-e：以Linux的显示风格显示arp缓冲区中的条目； -i&lt;接口&gt;：指定要操作arp缓冲区的网络接口；-s&lt;主机&gt;&lt;MAC地址&gt;：设置指定的主机的IP地址与MAC地址的静态映射； -n：以数字方式显示arp缓冲区中的条目； -v：显示详细的arp缓冲区条目，包括缓冲区条目的统计信息； -f&lt;文件&gt;：设置主机的IP地址与MAC地址的静态映射 交换分区，就是windows中虚拟内存在linux中的叫法；其空间的分配的推荐做法是： 目前Red Hat（红帽官方）推荐交换分区的大小应当与系统物理内存的大小保持线性比例关系。在小于2GB物理内存的系统中，交换分区大小应该设置为内存大小的两倍；如果内存大小多于2GB，交换分区大小应该是物理内存大小加上2GB；原则上，由于交换分区读写速度比真正内存区慢的多，因此在实际应用中如果不是特别需要应该设置的越小越好。 查看CPU信息命令 cat /proc/cpuinfo 查看内存信息命令 cat /proc/meminfo 查看硬盘信息命令 fdisk -l 查看当前目录下所有目录以及子目录的大小： du -h hdparm命令可以查看硬盘信息 方式一：free 直观的展示linux系统内存使用及交换区的容量大小等 方式二：top 动态实时查看系统中每一个进程的资源使用情况 方式三：cat /proc/meminfo 查看物理内存的大小 方式四：gnome-system-monitor 一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的视图工具。 方式五：ps aux –sort -rss 各个线程的资源使用情况 方式六：vmstat -s vmstat命令显示实时的和平均的统计，覆盖CPU、内存、I/O等内容。 10. 12345678# 改变权限chmod 777 filepath# 改变所有者chown test filepath # 改变所属组chgrp user filepath#改变所有者及用户组可直接使用以下命令chown test:user file1 在bash中，在一条命令后加入”1&gt;&amp;2”意味着 标准输出重定向到标准错误输出 0 ,1,2叫文件描述符；Linux中，每打开一个文件都有一个小的整数与之对应，就是文件描述符！0 是标准输入的 （stdin）1 是标准输出的 （stdout）2 是标准报错输出的 （stderr） ‘&lt;’是输入重定向符 ‘&gt;’是输出重定向符 在CPU和物理内存之间进行地址转换时，（ MMU）将地址从虚拟（逻辑）地址空间映射到物理地址空间 MMU 是Memory Manage Unit的缩写，即是存储管理单元，其功能是和物理内存之间进行地址转换 在CPU和物理内存之间进行地址转换，将地址从逻辑空间映映射到物理地址空间。 ctrl+z把正在运行的程序调到后台,暂停一个前台的作业，即挂起 。 ctrl+x在某些文字处理程序中，这个控制字符将会剪切高亮的文本并且将它复制到剪贴板中。ctrl+v在输入文本的时候，按下之后，可以插入控制字符。ctrl+c中断，终结一个前台作业。 命令：[-z””]&amp;&amp;echo 0 ||echo 1的输出是 0 123456789[ -z &quot;&quot; ] 命令判断双引号中变量的字符串长度是否为0，[ -z &quot;&quot; ] &amp;&amp; echo 0 || echo 1 ^ ^ ^命令1 命令2 命令3本题即：先判断 “” 变量中是否无值，成功 然后根据 &amp;&amp; 符特性，当命令1执行成功时执行命令2，也就是执行echo 0 然后根据 || 符特性，前一个命令不能执行才执行后一个，命令2 echo 0 执行成功，所以命令3 echo 1不执行 命令结束 局域网的网络地址192.168.1.0/24，局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20访问172.16.1.0/24网络时，其路由设置正确的是？ 1route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1 -net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络。 route print–本命令用于显示路由表中的当前项目，由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。 route add–使用本命令，可以将新路由项目添加给路由表。例如，如果要设定一个到目的网络209.98.32.33的路由，其间要经过5个路由器网段，首先要经过本地网络上的一个路由器，其IP为202.96.123.5，子网掩码为255.255.255.224，那么你应该输入以下命令： route add 209.98.32.33 mask 255.255.255.224 202.96.123.5 metric 5 route change–你可以使用本命令来修改数据的传输路由，不过，你不能使用本命令来改变数据的目的地。下面这个例子可以将数据的路由改到另一个路由器，它采用一条包含3个网段的更直的路径： route change 209.98.32.33 mask 255.255.255.224 202.96.123.250 metric 3 route delete–使用本命令可以从路由表中删除路由。例如：route delete 209.98.32.33 route命令主要用于手动配置静态路由表 进程对管道进行读操作和写操作都可能被阻塞 Linux 有三个查看文件的命令，cat,less,more都可以查看，只是查看的方式不一样，less可以让光标上下移动，more只能用enter键往下翻，cat的话直接跳到最后一页。 一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。 除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。 硬链接 指向的是inode号，删了一个文件名其他文件名不会报错软链接指向的是文件名，删了源文件名 其他文件名会报错 在某特定文件夹内查找所有带abc的文件,选出可以实现的？ 1find .|xargs grep -ri &quot;abc&quot; Find是一个非常有效的工具，它可以遍历当前目录甚至于整个文件系统来查找某些文件或目录. 主要选项: -name 按照文件名查找文件 -perm 按照文件权限来查找文件 -prune 不在当前指定的目录中查找 -user 按照文件属主来查找文件 -group 按照文件所属的组来查找文件 -mtime -n +n 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前. -nogroup 查找无有效所属组的文件，即该文件所属的组不存在 -nouser 查找无有效属主的文件 -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件 -type 查找某一类型的文件 [ 文件类型： b 块设备文件 d 目录 c 字符设备文件 p 管道文件 l 符号链接文件 f 普通文件 ] -size n[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计 -depth 在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找 -mount 在查找文件时不跨越文件系统mount点 -follow 如果find命令遇到符号链接文件，就跟踪到链接所指向的文件 -cpio 对匹配的文件使用cpio命令，就将这些文件备份到磁盘设备中 (其余选项，请man find，进一步查看) 对find命令选项的一些例子： $ find /etc -type d ＃在/ et c目录下查找所有的目录 $ find /etc -user yaoyuan ＃在/etc目录下查找文件属主为yaoyuan的文件 $ find . -size +1000000c ＃在当前目录下查找文件长度大于1 M字节的文件 下面关于i节点描述错误的是？A 1234A.i节点和文件名是一一对应的B.i节点能描述文件占用的块数C.i节点描述了文件大小和指向数据块的指针D.通过i节点实现文件的逻辑结构和物理结构的转换 1:软链接就相当于快捷方式，删除源文件，快捷方式就没有意义了。2:硬链接相当于备份了文件，但是还可以和源文件内容同步，删除源文件，硬链接文件任然有效。3:软链接可以跨文件系统，但是硬链接不能4:软链接的源文件的inode不相同，但是硬链接文件和源文件inode相同 Vi三种模式详解 命令行模式 （command mode/一般模式）:任何时候，不管用户处于何种模式，只要按一下“ESC”键，即可使Vi进入命令行模式；我们在shell环境（提示符为$）下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合法命令，Vi会响铃报警。文本输入模式 （input mode/编辑模式）: 在命令模式下输入插入命令i（insert）、附加命令a（append）、打开命令o（open）、修改命令c（change）、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按”ESC“键即可。末行模式 （last line mode/指令列命令模式） 末行模式也称ex转义模式。 Vi和Ex编辑器的功能是相同的，二者主要区别是用户界面。在Vi中，命令通常是单个键，例如i、a、o等；而在Ex中，命令是以按回车键结束的正文行。Vi有一个专门的“转义”命令，可访问很多面向行的Ex命令。在命令模式下，用户按“:”键即可进入末行模式下，此时Vi会在显示窗口的最后一行（通常也是屏幕的最后一行）显示一个“:”作为末行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的（如把编辑缓冲区的内容写到文件中等）。末行命令执行完后，Vi自动回到命令模式。 在Linux系统下，你用vi编辑器对文本文件test.txt进行了修改，想保存对该文件所做的修改并正常退出vi编辑器，可以（在命令模式下执行ZZ命令、在末行模式下执行:wq）。 useradd 增加用户 usermod 修改用户账号信息 groupadd 添加组账号 userdel 删除用户 A du(disk usage) 命令功能说明：统计目录(或文件)所占磁盘空间的大小 ​ B df(disk file) 命令功能说明： 用于显示文件系统的磁盘使用情况 ​ C free 命令功能说明：可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区 ​ D vmstat 命令功能说明： 命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息 whereis 可查询二进制文件(-b)、帮助文档(-m)、源程序（-s），无选项时，返回所有结果，-u(除上述三种的其它文件) which 查看可执行文件的位置 whatis 查询命令有什么功能 apropos 搜索指定关键字的命令 在RHEL5统中，“run.sh”是Shell执行脚本，在执行./run.sh file1 file2 file3 命令的过程中，变量$1的值为（ file1 ） shell中命令行参数:$0表示脚本名,$1-$9表示后面的参数 dev 设备信息 home 家目录 bin/sbin 可执行文件 etc 系统文件 lib/lib64 动态库/静态库 lost+found 丢失文件 opt 第三方文件（相对于操作系统） root 管理员的家目录 usr 第三方头文件和库 var 系统日志文件/缓存文件 单任务系统中两个程序A和B，其中 A程序：CPU：10s -&gt; 设备1：5s -&gt; CPU: 5s -&gt; 设备2:10s -&gt; CPU：10s； B程序：设备1:10s -&gt; CPU：10s -&gt; 设备2：5s -&gt; CPU: 5S -&gt; 设备2： 10s； 执行顺序为A -&gt;B,那么CPU的利用率为（ ） 两个任务执行完成所需要时间为：10 + 5 + 5 + 10 + 10 + 10 + 10 + 5 + 5 + 10 = 80s CPU所需时间为： 10 + 5 + 10 + 10 + 5 = 40s 故CPU利用率为：40 / 80 = 0.5. 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。** 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。** /etc/hosts 主机名到 IP 地址的映射关系的文件 /etc/resolv.conf DNS 服务的配置文件 /etc/gateways 建立动态路由需要用到的文件 /etc/HOSTNAME，这个文件存的是你的主机名，就比如你的终端的提示符yourname@hostname ，这里的hostname就写在这个文件里面 FTP服务器有两个端口，其中21端口用于连接，20端口用于传输数据 进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。 也就是说，端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。 新建一个管理员用户admin,需要使用的参数() useradd -u 0 -o admin -u 用户号 指定用户的用户号；因为系统用户的用户号为0，故指定用户号为0 如果同时有-o选项，则可以重复使用其他用户的标识号；因为系统本身存在用户号为0的系统用户，故应该使用该参数。 在重新启动Linux系统的同时把内存中的信息写入硬盘，应使用（#shutdown -r now）命令实现 在linux命令中reboot是重新启动，shutdown -r now是立即停止然后重新启动，都说他们两个是一样的，其实是有一定的区别的。 shutdown命令可以安全地关闭或重启Linux系统，它在系统关闭之前给系统上的所有登录用户提示一条警告 信息。该命令还允许用户指定一个时间参数，可以是一个精确的时间，也可以是从现在开始的一个时间段。 精确时间的格式是hh:mm，表示小时和分钟，时间段由+ 和分钟数表示。系统执行该命令后会自动进行数据同步的工作。 该命令的一般格式: shutdown [选项][时间] [警告信息] 命令中各选项的含义为: - k 并不真正关机而只是发出警告信息给所有用户 - r 关机后立即重新启动 - h 关机后不重新启动 - f 快速关机重启动时跳过fsck - n 快速关机不经过init 程序 - c 取消一个已经运行的shutdown 需要特别说明的是该命令只能由超级用户使用。 例1，系统在十分钟后关机并且马上重新启动: # shutdown –r +10 例2，系统马上关机并且不重新启动:# shutdown –h now halt是最简单的关机命令，其实际上是调用shutdown -h命令。halt执行时，杀死应用进程，文件系统写操作完成后就会停止内核。 halt命令的部分参数如下： [-f] 没有调用shutdown而强制关机或重启 [-i] 关机或重新启动之前，关掉所有的网络接口 [-p] 关机时调用poweroff，此选项为缺省选项 reboot的工作过程与halt类似，其作用是重新启动，而halt是关机。其参数也与halt类似。reboot命令重启动系统时是删除所有的进程，而不是平稳地终止它们。因此，使用reboot命令可以快速地关闭系统，但如果还有其它用户在该系统上工作时，就会引起数据的丢失。所以使用reboot命令的场合主要是在单用户模式。 init是所有进程的祖先，其进程号始终为1。init用于切换系统的运行级别，切换的工作是立即完成的。init 0命令用于立即将系统运行级别切换为0，即关机；init 6命令用于将系统运行级别切换为6，即重新启动 用什么命令来显示当前目录？ （1）直接pwd可以 （2）$pwd是不可以的，因为$表示引用pwd的结果，但是没有对这个结果做任何处理 （3）echo $(pwd) 或者echo $PWD都可以，前者是表示引用pwd命令的输出并且打印到屏幕；后者的PWD是一个环境变量； 在Linux上，对于多进程，子进程继承了父进程的下列哪些？共享内存、信号掩码、已打开的文件描述符 父进程和子进程拥有独立的地址空间和PID参数。 子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。 经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争” 35.Linux 系统中DHCP 服务器的服务程序是dhcpd，配置文件是dhcpd.conf，如果在该配置文件中包括如下配置内容： Subnet 192.168.2.0 netmask 255.255.255.0 { range 192.168.2.100 192.168.2.200 ; } 关于以上配置内容，说法正确的是（ ） 12对子网“192.168.2.0/24”中的主机进行动态地址分配在子网中用于动态分配的IP 地址数量为101 个 A类的默认子网掩码 255.0.0.0 B类的默认子网掩码 255.255.0.0 C类的默认子网掩码 255.255.255.0 16位是B类，B类IP地址的前面6位表示网络地址，后16位表示主机地址，B类IP地址前面开头的数字范围是128—191 24位是C类，标准的C类地址的确是24位的子网掩码，但是为了更好的饿使用IP地址，采用了一种技术叫VLSM的。 题目的前面开头是192，所以是C类地址，所以24位表示主机地址。所以是／24 Linux 下进程间的通信方式有以下几种 （1）管道/无名管道 （2）信号 （3）共享内存 （4）消息队列 （5）信号量 （6）socket 这是书上说的六种通信方式，通过文件锁的方式也可以实现进程间的通信（上网查了一下）所以要记住文件锁 ps 查看当前系统中的进程 who -b 查看当前系统的启动时间 last reboot 查看当前系统的启动时间 w 查看当前系统的启动时间 top 查看当前系统的启动时间 uptime 查看当前系统的启动时间 38.通常，一个进程由三个部分组成：进程控制块PCB、数据和程序。在UNIX中，一个进程也由三个部分组成：进程控制块、数据段和共享正文段，并有其自身的不同含义。 进程运行时用到的数据以及工作区，构成了一个进程的数据段。要注意的是，如果进程执行的程序是不能被共享的，那么也把它归入到数据段中。 为了管理好进程的共享正文段，UNIX在内存专门开辟了一个text结构区域，形成正文段表text[ ]. 因此，划分进程为进程控制块、正文段、数据段可以实现共享正文，共享数据和可重入。 39. cat /proc/cpuinfo：查看一台linux机器的CPU信息 du：查看该目录占用文件系统数据块的情况 cat /proc/swaps：查看SWAP分区信息 df -lh：查看硬盘信息 命令 subnet 166.173.197.131 netmask 255.255.255.192{ range 166.173.197.10 166.173.197.107; default-lease-time 600; max-lease-time 7200; } 表示？（） 12一个两小时的最大租用时间指定了一个十分钟的缺省租用时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190答案：该报文表示的意义： 对子网166.173.197.131（其子网掩码为255.255.255.192，即网络号占高26位，主机号占低6位），该子网的网络地址为：166.173.197.128，其主机范围为166.173.197.128-166.173.197.191. 现在对该可选择范围内申请主机号范围在166.173.197.10-166.173.197.107的IP地址； 该申请默认租用时间为600s，最大租用时间不超过7200秒 至于申请和分配是否成功在这里并不关心。IP 和子网掩码我们都知道， IP 是由四段数字组成，在此，我们先来了解一下 3 类常用的 IPA 类 IP 段 0.0.0.0 到 127.255.255.255 (0 段和 127 段不使用 )B 类 IP 段 128.0.0.0 到 191.255.255.255C 类 IP 段 192.0.0.0 到 223.255.255.255XP 默认分配的子网掩码每段只有 255 或 0A 类的默认子网掩码 255.0.0.0 一个子网最多可以容纳 1677 万多台电脑B 类的默认子网掩码 255.255.0.0 一个子网最多可以容纳 6 万台电脑C 类的默认子网掩码 255.255.255.0 一个子网最多可以容纳 254 台电脑我们必须有一个子网掩码，因为：1 ）当配置 IP 时，所有计算机都必须填写子网掩码2 ）我们必须在我们的网络中设置一些逻辑边界3 ）我们必须至少输入所使用 IP 类的默认子网掩码我以前认为，要想把一些电脑搞在同一网段，只要 IP 的前三段一样就可以了，今天，我才知道我错了。如果照我这样说的话，一个子网就只能容纳 254 台电脑？真是有点笑话。我们来说详细看看吧。要想在同一网段，只要网络标识相同就可以了，那要怎么看网络标识呢？首先要做的是把每段的 IP 转换为二进制。（有人说，我不会转换耶，没关系，我们用 Windows 自带计算器就行。打开计算器，点查看 &gt; 程序员，输入十进制的数字，再点一下“二进制”这个单选点，就可以切换至二进制了。）把子网掩码切换至二进制，我们会发现，所有的子网掩码是由一串连续的 1 和一串连续的 0 组成的（一共 4 段，每段 8 位，一共 32 位数）。255.0.0.0 11111111.00000000.00000000.00000000255.255.0.0 11111111.11111111.00000000.00000000255.255.255.0 11111111.11111111.11111111.00000000这是 A/B/C 三类默认子网掩码的二进制形式，其实，还有好多种子网掩码，只要是一串连续的 1 （不少于 8 个）和一串连续的 0 就可以了（每段都是 8 位）。如 11111111.11111111.11111000.00000000 ，这也是一段合法的子网掩码。子网掩码决定的是一个子网的计算机数目，计算机公式是 2 的 m 次方，其中，我们可以把 m 看到是后面的多少个 0 。如 255.255.255.0 转换成二进制，那就是 11111111.11111111.11111111.00000000 ，后面有 8 个 0 ，那 m 就是 8 ， 255.255.255.0 这个子网掩码可以容纳 2 的 8 次方（台）电脑，也就是 256 台，但是有两个 IP 是不能用的，那就是最后一段不能为 0 和 255 ，减去这两台，就是 254 台。划分方法子网的划分，实际上就是设计子网掩码的过程。子网掩码主要是用来区分 IP 地址中的网络 ID 和主机 ID ，它用来屏蔽 IP 地址的一部分，从 IP 地址中分离出网络 ID 和主机 ID. 子网掩码是由 4 个十进制数组成的数值 &quot; 中间用 &quot;.&quot; 分隔，如 255.255.255.0 。若将它写成二进制的形式为 :11111111.11111111.11111111.00000000 ，其中为 &quot;1&quot; 的位分离出网络 ID, 为 &quot;0&quot; 的位分离出主机 ID ，也就是通过将 IP 地址与子网掩码进行 &quot; 与 &quot; 逻辑操作，得出网络号。例如，假设 IP 地址为 192.160.4.1 ，子网掩码为 255.255.255.0 ，则网络 ID 为 192.160.4.0, 主机 ID 为 0.0.0.1 。计算机网络 ID 的不同，则说明他们不在同一个物理子网内，需通过路由器转发才能进行数据交换。每类地址具有默认的子网掩码 : 对于 A 类为 255.0.0.0 ，对于 B 类为 255.255.0.0 ，对于 C 类为 255.255.255.0 。除了使用上述的表示方法之外，还有使用子网掩码中 &quot;1&quot; 的位数来表示的，在默认情况下， A 类地址为 8 位， B 类地址为 16 位， C 类地址为 24 位。例如， A 类的某个地址为 12.10.10.3/8 ，这里的最后一个 &quot;8&quot; 说明该地址的子网掩码为 8 位，而 199.42.26.0/28 表示网络 199.42.26.0 的子网掩码位数有 28 位。如果希望在一个网络中建立子网，就要在这个默认的子网掩码中加入一些位，它减少了用于主机地址的位数。加入到掩码中的位数决定了可以配置的子网。因而，在一个划分了子网的网络中，每个地址包含一个网络地址、一个子网位数和一个主机地址示例255.255.248.0 这个子网掩码可以最多容纳多少台电脑？计算方法把将其转换为二进制的四段数字（每段要是 8 位，如果是 0 ，可以写成 8 个0 ，也就是 00000000）11111111.1111111.11111000.00000000然后，数数后面有几颗 0 ，一共是有 11 颗，那就是 2 的 11 次方，等于 2048 ( 注意：主机号中全0 是保留地址，全 1 是广播地址，所以它们不算可用主号地址。网络号也是一样的。子网号是可以用全 0 和全 1 的 ) ，所以这个子网掩码最多可以容纳 2048-2=2046 台电脑。一个子网最多可以容纳多少台电脑你会算了吧，下面我们来个逆向算法的题。一个公司有 530 台电脑，组成一个对等局域网，子网掩码设多少最合适？首先，无疑， 530 台电脑用 B 类 IP 最合适（ A 类不用说了，太多， C 类又不够，肯定是 B 类），但是 B 类默认的子网掩码是 255.255.0.0 ，可以容纳 6 万台电脑，显然不太合适，那子网掩码设多少合适呢？我们先来列个公式。公式2 的 m 次方 &gt;=560首先，我们确定 2 的 m 次方一定是大于 2 的 8 次方的，因为我们知道 2 的 8 次方是 256 ，也就是 C 类 IP 的最大容纳电脑的数目，我们从 9 次方一个一个试， 2 的 9 次方是 512 ，不到 560 ， 2 的 10 次方是 1024 ，看来 2 的 10 次方最合适了。子网掩码一共由 32 位组成，已确定后面 10 位是 0 了，那前面的 22 位就是 1 ，最合适的子网掩码就是： 11111111.11111111.11111100.00000000 ，转换成 10 进制，那就是 255.255.252.0 。分配和计算子网掩码你会了吧，下面，我们来看看 IP 地址的网段。相信好多人都和我一样，认为 IP 只要前三段相同，就是在同一网段了，其实，不是这样的，同样，我也把 IP 的每一段转换为一个二进制数，这里就拿 IP ： 192.168.0.1 ，子网掩码： 255.255.255.0 做实验吧。192.168.0.111000000.10101000.00000000.00000001（这里说明一下，和子网掩码一样，每段 8 位，不足 8 位的，前面加 0 补齐。）IP 11000000.10101000.00000000.00000001子网掩码 11111111.11111111.11111111.00000000同一网段在这里，向大家说一下到底怎么样才算同一网段。要想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？各类 IP 的网络标识算法都是不一样的。 A 类的，只算第一段。B 类，只算第一、二段。 C 类，算第一、二、三段。算法只要把 IP 和子网掩码的每位数 AND 就可以了。AND 方法： 0 和 1=0 0 和 0=0 1 和 1=1如： And 192.168.0.1 ， 255.255.255.0 ，先转换为二进制，然后 AND 每一位IP 11000000.10101000.00000000.00000001子网掩码 11111111.11111111.11111111.00000000得出 AND 结果 11000000.10101000.00000000.00000000转换为十进制 192.168.0.0 ，这就是网络标识，再将子网掩码反取，也就是 00000000.00000000.00000000.11111111 ，与 IP AND得出结果 00000000.00000000.00000000.00000001 ，转换为 10 进制，即 0.0.0.1 ，这 0.0.0.1 就是主机标识。要想在同一网段，必需做到网络标识一样。我们再来看看这个改为默认子网掩码的 B 类 IP如 IP ： 188.188.0.111 ， 188.188.5.222 ，子网掩码都设为 255.255.254.0 ，在同一网段吗？先将这些转换成二进制188.188.0.111 10111100.10111100.00000000.01101111188.188.5.222 10111100.10111100.00000101.11011110255.255.254.0 11111111.11111111.11111110.00000000分别 AND ，得10111100.10111100.00000000.0000000010111100.10111100.00000100.00000000网络标识不一样（看 255.255.254.0 转换成二进制后 1 的数位，所以可以看到不一样），即不在同一网段。判断是不是在同一网段，你会了吧，下面，我们来点实际的。一个公司有 530 台电脑，组成一个对等局域网，子网掩码和 IP 设多少最合适？子网掩码不说了，前面算出结果来了 11111111.11111111.11111100.00000000 ，也就是 255.255.252.0B 类地址选一个 B 类 IP 段，这里就选 188.188.x.x 吧这样， IP 的前两段确定的，关键是要确定第三段，只要网络标识相同就可以了。我们先来确定网络号。（我们把子网掩码中的 1 和 IP 中的 ? 对就起来， 0 和 * 对应起来，如下：）255.255.252.0 11111111.11111111.11111100.00000000188.188.x.x 10111100.10111100.??????**.********网络标识 10111100.10111100.??????00.00000000由此可知， ? 处随便填（只能用 0 和 1 填，不一定全是 0 和 1 ），我们就用全填 0 吧， * 处随便，这样呢，我们的 IP 就是10111100.10111100.000000**.******** ，一共有 530 台电脑， IP 的最后一段 1 ～ 254 可以分给 254 台计算机， 530/254=2.086 ，采用进 1 法，得整数 3 ，这样，我们确定了 IP 的第三段要分成三个不同的数字，也就是说，把 000000** 中的 ** 填三次数字，只能填 1 和 0 ，而且每次的数字都不一样，至于填什么，就随我们便了，如 00000001 ， 00000010 ， 00000011 ，转换成十进制，分别是 1 ， 2 ， 3 ，这样，第三段也确定了，这样，就可以把 IP 分成 188.188.1.y ， 188.188.2.y ， 188.188.3.y ， y 处随便填，只要在 1 ～ 254 范围之内，并且这 530 台电脑每台和每台的 IP 不一样，就可以了。有人也许会说，既然算法这么麻烦，干脆用 A 类 IP 和 A 类默认子网掩码得了，偶要告诉你的是，由于 A 类 IP 和 A 类默认子网掩码的主机数目过大，这样做无疑是大海捞针，如果同时局域网访问量过频繁、过大，会影响效率的，所以，最好设置符合自己的 IP 和子网掩码 ^_^举个实例：比如公司分配到的网段是 192.168.1.0/24 ，首先我要分一个 8 个主机的网段出来，那么这个网段的首地址是什么 ? 之后，我又要划分一个 16 个主机的地址出来，那么 16 个主机的首地址是什么？划分实例C 类地址例子 : 网络地址 192.168.10.0; 子网掩码 255.255.255.192(/26)1. 子网数 =2*2=42. 主机数 =2 的 6 次方 -2=623. 有效子网 ?:block size=256-192=64; 所以第一个子网为 192.168.10.64, 第二个为 192.168.10.1284. 广播地址 : 下个子网 -1. 所以 2 个子网的广播地址分别是 192.168.10.127 和 192.168.10.1915. 有效主机范围是 : 所以第一个子网为 192.168.10.0 ，第二个为 192.168.10.64 ，第三个为 192.168.10.128 ，第四个为 192.168.10.192B 类地址例子 1: 网络地址 :172.16.0.0; 子网掩码 255.255.192.0(/18)1. 子网数 =2*2=42. 主机数 =2 的 14 次方 -2=163823. 有效子网 ?:block size=256-192=64; 所以第一个子网为 172.16.64.0, 最后 1 个为 172.16.128.04. 广播地址 : 下个子网 -1. 所以 2 个子网的广播地址分别是 172.16.127.255 和 172.16.191.2555. 有效主机范围是 : 第一个子网的主机地址是 172.16.64.1 到 172.16.127.254; 第二个是 172.16.128.1 到 172.16.191.254B 类地址例子 2: 网络地址 :172.16.0.0; 子网掩码 255.255.255.224(/27)1. 子网数 =2 的 11 次方 -2=2046( 因为 B 类地址默认掩码是 255.255.0.0, 所以网络位为 8+3=11)2. 主机数 =2 的 5 次方 -2=303. 有效子网 ?:block size=256-224=32; 所以第一个子网为 172.16.0.32, 最后 1 个为 172.16.255.1924. 广播地址 : 下个子网 -1. 所以第一个子网和最后 1 个子网的广播地址分别是 172.16.0.63 和 172.16.255.2235. 有效主机范围是 : 第一个子网的主机地址是 172.16.0.33 到 172.16.0.62; 最后 1 个是 172.16.255.193 到 172.16.255.223Variable Length Subnet Masks(VLSM)变长子网掩码 (VLSM) 的作用 : 节约 IP 地址空间 ; 减少路由表大小 . 使用 VLSM 时 , 所采用的路由协议必须能够支持它 , 这些路由协议包括 RIPv2,OSPF,EIGRP 和 BGP. 41.EXT2、EXT3：linux环境上的文件系统。ext2/ext3文件系统使用索引节点来记录文件信息，作用像windows的文件分配表。索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。 EXT2、EXT3的区别如下： （1）ext2和ext3的格式完全相同，只是在ext3硬盘最后面有一部分空间用来存放Journal（日志）的记录； （2）在ext2中，写资料到硬盘中时，先将资料写入缓存中，当缓存写满时才会写入硬盘中； （3）在ext3中，写资料到硬盘中时，先将资料写入缓存中，缓存写满时系统先通知Journal，再将资料写入硬盘，完成后再通知Journal，资料已完成写入工作； （4）是否有Journal的差别： 在ext2中，系统开机时会去检查有效位（Valid bit），如果值为1，表示系统上次有正常关机；如果为0，表示上次关机未正常关机，那系统就会从头检查硬盘中的资料，这样时间会很长；在ext3中，也就是有Journal机制里，系统开机时检查Journal的资料，来查看是否有错误产生，这样就快了很多； （5）tune2fs –j 将ext2转换成ext3 Ext3 目前所支持的最大16TB 文件系统和最大2TB 文件，Ext4 分别支持 1EB（1,048,576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。 /proc/interrupts 显示使用的中断 /proc/ioports 当前使用的I/O端口 /proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。 /proc/kmsg 内核输出的消息，也被送到syslo 在使用VI编辑器的时候，查找内容的方法有两种： 1、“/”：这个查找是自上而下 2、“？”：这个查找是自下而上 针对“/”：使用“n”查找下一个，使用“N”查找上一个 44./ect/passwd用来保存用户的基本信息，而/etc/shadow用来保存所有用户的密码，在/etc/shadow中第二字段为用户的加密密码，如果密码是”!!”或” * “则代表没有密码不能登录，需要用户登录验证","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"}]},{"title":"项目积累","date":"2018-04-25T12:50:45.000Z","path":"2018/04/25/项目积累/","text":"生产环境下，应对高并发一般都是本地缓存和网络缓存相结合。GuavaCache是本地缓存，redis是网络缓存。","tags":[{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"计算机网络","date":"2018-04-25T12:14:59.000Z","path":"2018/04/25/计算机网络/","text":"PPP协议有两种认证方式，PAP(口令鉴别协议)方式和CHAP（口令握手鉴别协议）方式。PAP只需进行一次认证，并且只在链路初始状态时执行。而且用户名与密码的传送方式是明文的。CHAP采用周期性的验证，并且认证内容经过MD5加密后再传送，安全性要比PAP高。 IEEE 802.3标准采用CSMA/CD，并用二进制指数退避和1-坚持算法 CSMA/CD采用二进制指数退避算法，又称为二元指数后退算法。退避算法是以冲突窗口大小为基准的，每个节点有一个冲突计数器C。退避的时间与冲突次数具有指数关系，冲突次数越多，退避的时间就可能越长，若达到限定的冲突次数，该节点就停止发送数据。 互联网采用的路由选择协议是动态的RIP是基于距离向量的路由选择协议，RIP选择一个到目的网络具有最少路由器的路由（最短路由）。OSPF最主要特征是使用分布式链路状态协议，所有的路由器最终都能建立一个链路状态数据库（全网的拓扑结构图）。BGP-4采用路径向量路由选择协议。BGP所交换的网络可达性信息是要到达某个网络所要经过的自治系统序列。 4. 1具有5个10M端口的集线器的总带宽可以达到(10M) 集线器不管有多少个端口，所有端口都共享一条带宽，在同一时刻只能有两个端口传送数据，其他端口只能等待；只能工作在半双工模式下。交换机每个端口都有一条独占的带宽，当两个端口工作时并不影响其他端口的工作，交换机可以工作在半双工模式下也可以工作在全双工模式下。 某主机的 IP 地址为 180.80.77.55 ，子网掩码为 255.255.252.0 。若该主机向其所在子网发送广播分组，则目的地址可以是 180.80.79.255。 1231.子网掩码的第3 个字节为 11111100 ，可知前 22 位为子网号、后 10 位为主机号。 IP 地址的第 3 个字节为 010011 01 （下划线为子网号的一部分），将主机号（即后 10 位）全置为 1 ，可以得到广播地址为 180.80.79.255 。2.把IP地址跟子网掩码取与（&amp;）得到网络地址：广播地址是网络地址的主机位全1 3. 广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机 从组的使用范围来分，可以分为三种：全局组、本地域组和通用组。 IEEE 802.3 ：以太网介质访问控制协议 （CSMA/CD）及物理层技术规范。 IEEE 802.5 ：令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。 9.传输介质 10BASE-2 细缆 10BASE-5 粗缆 10BASE-T 非屏蔽双绞线 10BASE-FL 光纤 几种常用的广域网：公用电话交换网（ PSTN）、分组交换网（X . 25）、数字数据网（DDN）、帧中继（FR）、交换式多兆位数据服务（SMDS）和异步传输模式（ATM）。 要想连上Internet，至少需要四个条件：1.IP地址；2.子网掩码；3.gateway(网关)；4.DNS（域名服务器） 而此题说的是设备，则肯定选择路由器，因为只有路由器才能完成网关这个条件，而网关本身并不是一种设备 套接字由什么构成 (IP地址与端口号 ) 物理层的接口有哪几个方面的特性？各包含些什么内容？ （1）机械特性:说明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。（2）电气特性:指明在接口电缆的各条线上出现的电压的范围。 （3）功能特性:指明某条线上出现的某一电平的电压表示何意。 （4）规程特性:说明对于不同功能的各种可能事件的出现顺序。 交换机根据下列哪个地址来决定转发？（目标MAC地址 Ethernet采用的媒体访问控制方式是 （CSMA/CD 虚电路方法在传输数据前（）必须预先建立一条逻辑连接 255.0.0.0；255.255.0.0；255.255.255.0分别为A,B,C类地址的缺省子网掩码 局域网中的MAC层与OSI 参考模型（数据链路层） 相对应 DNS：域名解析 FTP：文件传输 www：信息查询 ADSL：非对称数字用户线路，数据传输 MAC地址长度为：48位 （6字节）； 两台主机之间的数据链路层采用后退N帧协议（GBN）传输数据，数据传输速率为16 kbps，单向传播时延为270ms，数据帧长度范围是128～512字节，接收方总是以与数据帧等长的帧进行确认。为使信道利用率达到最高，帧序号的比特数至少为 123456789数据是沿着介质从一端传到另一端的，当前将数据发送出去了，不代表在接收到确认之前不能发送数据，为了使效率达到最高，应该继续发送数据。接下来考虑两个问题，①数据发送出去到接收到确认的时间是多少，②这段时间内最多能发送多少帧先解决第一个问题：发出一帧的时间：128 * 8 / (16 * 10^3) = 64ms；加上时延：64 + 270 * 2 + 64 = 668ms然后解决第二个问题：尽可能的发送更多的帧，那么帧应该尽可能的小，得出：668 / 64 = 10.4帧问题问的是求“为使信道利用率达到最高，帧序号的比特数至少为”，注意最后一句话，问的是对帧进行编号。2^4 &gt; 10.4，因此编号至少需要4比特。 数据链路层互联的设备是网桥(bridge)，在网络互联中它起到数据接收、地址过滤与数据转发的作用，用来实现多个网络系统之间的数据交换。 12345678网桥的基本特征: 1．网桥在数据链路层上实现局域网互连； 2．网桥能够互连两个采用不同数据链路层协议、不同传输介质与不同传输速率的网络 3．网桥以接收、存储、地址过滤与转发的方式实现互连的网络之间的通信； 4．网桥需要互连的网络在数据链路层以上采用相同的协议 5．网桥可以分隔两个网络之间的通信量，有利于改善互连网络的性能与安全性。 6. 网桥只适合于用户数不太多（不超过几百个）和信息量不太大的局域网，否则有时会产生较大的广播风暴 7.由于网桥对接收的帧要先存储和查找站表，然后转发，这就增加了时延 CSMA/CD：带有冲突检测的载波监听多路访问，可以检测冲突，但无法“避免”CSMA/CA：带有冲突避免的载波侦听多路访问，发送包的同时不能检测到信道上有无冲突，只能尽量‘避免’； 1.两者的传输介质不同,CSMA/CD用于总线式以太网,而CSMA/CA则用于无线局域网802.11a/b/g/n等等； 2.检测方式不同，CSMA/CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA/CA采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式。 或者简单的这样记：以太网有线的是CSMA/CD，无线的话采用CSMA/CA。 局域网工作的层次跨越了：数据链路层和物理层。 一个理想低通信道带宽为3KHZ，其最高码元传输速率为6000Baud。若一个码元携带2bit信息量，则最高信息传输速率为（）。 码元=2*带宽 1已知码元率，就不需要带宽了，码元速率为6000Baud,一个码元携带2bit信息量，所以信息传输速率为6000*2=12000bit/s。 DNS功能是将域名映射为IP，ARP是把IP解析为MAC 1234567第一层：物理层第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY 第三层：网络层 IP、IPX、APPLETALK、ICMP 第四层：传输层 TCP、UDP、SPX 第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG 第七层：应用层 HTTP,FTP,SNMP等 交换机，网桥属于数据链路层设备 中继器，集线器属于物理层设备 路由器属于网络层设备 OSI模型中哪一层提供物理地址和介质访问控制功能（数据链路层）。 虚拟局域网（VLAN，Virtual Local Area Network）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。 VLAN是一种比较新的技术，工作在OSI参考模型的第2层和第3层，一个VLAN就是一个广播域，VLAN之间的通信是通过第3层的路由器来完成的。 与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点： 网络设备的移动、添加和修改的管理开销减少；可以控制广播活动；可提高网络的安全性。 在计算机网络中，能将异种网络互联起来，实现不同网络协议相互转换的网络互连设备是（网关）。 12345678网关和路由器最大的区别是是否连接相似的网络。如果连接相似的网络，则称为路由器。而连接不相似的网络，称为网关。逻辑层面：相似的网络：如果都是互联网上的两个网络，我们称为相似的网络。不相似的网络：如果一个是私网，一个是公网。我们称为不相似的网络。物理层面：相似的网络：都是以太网或者同一种介质的网络。不相似的网络：一边是以太，一边是SDH或者ATM等 RIP(Routing Information Protocol) 是一种分布式的基于距离向量的路由选择协议。 从一路由器到直接连接的网络的距离定义为 1。 从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。 RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。 RIP 允许一条路径最多只能包含 15 个路由器。 “距离”的最大值为16 时即相当于不可达。可见 RIP 只适用于小型互联网。 ARP是地址解析协议，工作在网络层，简单语言解释一下工作原理。 1234561：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址。 3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 ICMP是Internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是网络通不通、主机是否可达、路由是否可用等网络本身的信息，这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。所以它是网络层的协议 ICMP有两种报文：差错报文、询问报文 ICMP差错报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。 五种情况：终点不可达、原点抑制、时间超过、参数问题、改变路由（重定向） ICMP询问报文有四种类型：回送请求和回答报文；时间戳请求和回答报文；掩码地址请求和回答报文；路由器询问和通告报文。 12345show frame-relay map #查看帧中继网络的映射地址 show frame-relay pvc#查看PVC状态，pvc有四种状态，分别是：delete，static，inactive，active。show frame-relay lmi #查看本地路由和真交换机的状态消息数量，LMI数据统计show interface #1. 查看接口的物理层和链路层信息，包括数据包的封装类型 星型拓扑图：点到点式； 总线型：广播式； 环形式：点到点； 树形式：点到点； 网状：点到点和广播式 telnet：远程登录协议wget：下载工具scp：基于ssh的远程复制工具rsync：基于ssh和ssl的镜像备份工具 A类：10.0.0.0 ——— 10.255.255.255 B类：172.16.0.0——— 172.31.255.255 C类：192.168.0.0———192.168.255.255 BGP(Border Gateway Protocol)是一种在自治系统之间动态交换路由信息的路由协议。 ip协议(internet protorcol网络协议)是网络层的协议，它主要是对数据报的传输，提供无连接的，不可靠的数据报传输功能。无连接，不可靠:意思是双方没有协商，网络只需要把数据报分组发到目的地，不需要确认是否到达； 数据丢失，接收方要检测出失误并要求重发… 分组没按顺序到达，接收方要重新排序接收 计算机与打印机之间的通信属于（单工通信） 无线个人区域网就是在个人工作地方把属于个人使用的电子设备用无线技术连接起来，整个网络的范围大约在10m左右。 下面哪项不是因特网的特征？ 123456A.loosely hierarchical：无明显的等级化（互联网中的节点和子网络是平等的）B.public Internet versus：公共网间互联？C.private intranet：私有内网（比如互联网中有部分ip是专门供企业内部网络使用的）D.local connection：本地连接感觉D算不上是互联网的特征吧，因为就算没有internet的时候也可以有网络连接，只是规模不大罢了。 C类地址范围为192.168.0.0~192.168.255.255，其中192.168.0.0和192.168.255.255是保留地址用于广播号，其他的都是网络号。 1.报文(message)报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。 2.分组(packet)分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。 3.数据包(data packet)数据包是TCP/IP协议通信传输中的数据单元，也称为“包”。是指自包含的，带有足够寻址信息，可独立地从源主机传输到目的主机，而不需要依赖早期的源主机和目的主机之间交换信息以及传输网络的数据包。 4.数据报(datagram)面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。 5.帧(frame)帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。 ​ 应用层——消息 传输层——数据段(segment) 网络层——分组、数据包（packet） 链路层——帧（frame） 物理层——P-PDU（bit） 交换机工作于数据链路层，其内部的cpu会在每个端口连接成功时，通过将mac地址和端口对应，形成一张mac表。仅将数据包发往对应的端口。通过交换机的过滤和转发，可以有效减少冲突域。 表示层的作用：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）； 网络层的作用：负责数据包从源到宿的传递和网际互联（包）； 传输层的作用：提供端到端的可靠报文传递和错误恢复（段）； 会话层的作用：建立、管理和终止会话（会话协议数据单元） IP地址到网络硬件地址的映射 使用的是ARP（Address Resolution Protocol）协议，将IP转换成MAC地址，网络层协议 网络硬件地址到IP地址的映射 使用的是RARP（Reverse Address Resolution Protocol）协议，将MAC地址转换成IP，网络层协议 DNS 网络设备名字到IP地址的映射 应用层协议 DHCP 有 8 种消息类型，分别是 Discover、Request、Release、Inform、Decline、Offer、ACK、NAK。 其中前 5 种可由主机发起，后 3 种只能是 DHCP 服务端向主机发送 IP数据报的格式 IP数据报由首部 和数据两部分组成。首部由固定部分和可选部分组成。首部的固定部分有20字节。可选部分的长度变化范围为1—40字节。固定部分的字段： | 字段名 | 位数（bit） | 字段名 | 位数 || :——: | :———————————————————-: | :——–: | :———————————————————-: || 版本 | 4 Ipv4 | 首部长度 | 4（表示的最大数为15个单位，一个单位表示4字节） || 服务类型 | 8 以前很少用 | 总长度 | 16 （首部和数据部分的总长度，因此数据报的最大长度为65535字节，即64KB，但是由于链路层的MAC都有一定的最大传输单元，因此IP数据报的长度一般都不会有理论上的那么大，如果超出了MAC的最大单元就会进行分片） || 标识 | 16（相同的标识使得分片后的数据报片能正确的重装成原来的数据报） | 标志 | 3 （最低位MF=1表示后面还有分片，MF=0表示这是若干个数据报片的最后一个中间位DF=0才允许分片） || 片偏移 | 片偏移指出较长的分组在分片后，某片在原分组中的相对位置，都是8字节的偏移位置 | 生存时间 | 数据报在网络中的生存时间，指最多经过路由器的跳数 || 协议 | 8（指出该数据报携带的数据是何种协议，以使得目的主机的IP层知道应将数据部分上交给哪个处理程序）如ICMP=1 IGMP=2 TCP=6 EGP=8 IGP=9 UDP=17 Ipv6=41 OSPF=89 | 首部校验和 | 这个部分只校验首部，不包括数据部分，计算方法：将首部划分为多个16位的部分，然后每个16位部分取反，然后计算和，再将和取反放到首部校验和。接收方收到后按同样的方法划分，取反，求和，在取反，如果结果为零，则接收，否则就丢弃 || 源地址 | 32 | 目的地址 | 32 | TCP数据报的格式？ 一个TCP报文段分为首部和数据两部分。首部由固定部分和选项部分组成，固定部分是20字节。TCP首部的最大长度为60。首部固定部分字段： | 字段名 | 字节（Byte） | 字段名 | 字节（Byte） || ———– | ——————————————————- | ———– | ———————————————————— || 源端口 | 2 | 目的端口 | 2 || 序号 | 4 | 确认号 | 4，是期望收到对方的下一个报文段的数据的第一个字节的序号 || 数据偏移 | 4bit 指出TCP报文段的数据起始处距离TCP报文段的起始有多远 | 保留 | 6bit || 紧急比特URG | | 确认比特ACK | 只有当ACK=1时，确认号字段才有效 || 推送比特PSH | | 复位比特RST | || 同步比特SYN | | 终止比特FIN | || 窗口 | 2 | 检验和 | 2 （包括首部和数据两部分，同时还要加12字节的伪首部进行校验和计算） || 选项 | 长度可变（范围1——40） | | | TCP的12字节伪首部： | 源IP地址（4） | 目的IP地址（4） | 0 (1) | 6(1) 代表这是TCP，IP协议中提到过 | TCP长度（2） || ————- | ————— | —– | ——————————– | ———— || | | | | | UDP数据报的格式？ 用户数据报UDP由首部和数据部分组成。首部只有8个字节，由4个字段组成，每个字段都是两个字节。 | 字段名 | 字节 | 字段名 | 字节 || —— | —- | ——– | ————————————– || 源端口 | 2 | 目的端口 | 2 || 长度 | 2 | 检验和 | 2 （检验首部和数据，加12字节的伪首部） | UDP的12字节伪首部： | 源IP地址（4） | 目的IP地址（4） | 0 (1) | 17(1) 代表这是UDP | UDP长度（2） || ————- | ————— | —– | —————– | ———— || | | | | | 以太网MAC帧格式？ | 前导码 | 前定界符 | 目的地址 | 源目的地址 | 长度字段 | 数据字段 | 校验字段 || —— | ——– | ——– | ———- | ——– | ——– | ——– || 7B | 1B | 6B | 6B | 2B | 46-1500 | 4B | 了解交换机、路由器、网关的概念，并知道各自的用途1）交换机​ 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层和第七层，并因此而得名。 2）路由器路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 3）网关网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 ​ 网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关**还原成模拟的电话信号，最后才能在电话机上听到。 对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"三个整数","date":"2018-04-20T02:59:36.000Z","path":"2018/04/20/三个整数/","text":"题目： 输入三个数x,y,z，经过若干次操作使三个数变成一样大 操作一：选择其中两个数加1； 操作二：选择其中一个数加2； 输出最少的操作次数 思路： 贪心，首先对三个数进行排序。从小到大为xyz， ①如果xy之间差距为偶数，通过对x＋2就使得xy相等，然后，对xy分别+1，使得xyz相等。 ②如果 xy之间为奇数，那么就通过对xy分别+1，使得y=z。此时如果x和Z之间差距为偶数，那么就对x加2，使得XYZ相等；如果x和Z之间差距为奇数，那么就x加2，使得X比zy都大1，然后对yz分别加1，使xyz相等 。 假设为2 5 8，那么由②可以变为 5 8 8，然后根据③，变化为 9 8 8，然后变化为 9 9 9。 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int[] arr = new int[3]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = scanner.nextInt(); &#125; Arrays.sort(arr); int x = arr[0], y = arr[1], z = arr[2]; if ((y - x) % 2 == 0) &#123; System.out.println((y - x) / 2 + z - y); &#125; else &#123; int sum1 = z - y; int sum2 = z - x - sum1; if (sum2 % 2 == 0) &#123; System.out.println(sum1 + sum2 / 2); &#125; else &#123; System.out.println(sum1 + sum2 / 2 + 2); &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"从一个字符串中找出字典序最大子序列","date":"2018-04-19T14:15:47.000Z","path":"2018/04/19/从一个字符串中找出字典序最大子序列/","text":"说明： 字典序最大(不是递增)，例如 tt&gt;t、sa&gt;s、xe&gt;xba 例： 字符串test的字典序最大子序列为tt 字符串abcde的字典序最大子序列为e 思路： 从后向前找，最后一个字符肯定包含在内，前面的字符大于后面的字符才能保证字典序最大；所以，从后往前找时，遇到比最后一个大的字符，留下当作倒数第二个字符，继续找到比倒数第二个字符大的当作第三个字符。。。。。。时间复杂度O(n) 代码实现： 1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String str = sc.next(); char[] ch = str.toCharArray(); char[] chars = new char[50]; for(int i = 0; i&lt;ch.length;i++)&#123; int max = 0; int id = 50; for(i=ch.length-1;i&gt;=0;i--) &#123; if(ch[i] &gt;= max) &#123; chars[--id] = ch[i]; max = ch[i]; &#125; &#125; for(i=id;i&lt;50;i++) &#123; System.out.print(chars[i]); &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"Deepin下使用IDEA完成项目过程中报错com.intellij.javaee.oss.admin.jmx.JmxAdminException","date":"2018-04-18T16:08:57.000Z","path":"2018/04/19/Deepin下使用IDEA完成项目过程中报错com-intellij-javaee-oss-admin-jmx-JmxAdminException/","text":"详细报错信息为： 123Artifact unnamed: Artifact is being deployed, please wait...Artifact unnamed: Error during artifact deployment. See server log for details.Artifact unnamed: com.intellij.javaee.oss.admin.jmx.JmxAdminException: com.intellij.execution.ExecutionException: /home/bameirilyo/IdeaProjects/mmall/out/artifacts/unnamed/unnamed.war not found for the web module. 解决方法为： 1.点击idea右上角Project Structur按钮 2.选择Modules 3.鼠标右键 +Add ，选择Web 4.Artifacts模块中点击“+”号，“Web Application：Exploded”中出现From Modules选择即可。 可参考本人CSDN博客：https://blog.csdn.net/bameirilyo/article/details/79998409","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"Idea内初始化git","date":"2018-04-18T16:07:10.000Z","path":"2018/04/19/Idea内初始化git/","text":"利用模板创建完最原始的web项目后就可以在idea内初始化git了，并使用idea的控制台控制git 1234567891011121314151617181920212223#初始化git$ git init#查看状态$ git status#查看分支$ git branch#增加所有文件$ git add . $ git status#提交到本地仓库，双引号内为注释$ git commit -am \"first commit init project\"#设置github中项目仓库的ssh地址$ git remote set-url origin git@github.com:xxxx/xxxx.git#将远程仓库中的内容pull到本地$ git pull #推送到远程仓库（此步报错，原因为本地仓库内容落后于远程仓库）$ git push -u origin master #强制推送到远程仓库（-f）$ git push -u -f origin master#以master为基础新建并切换到该分支$ git checkout -b xxx origin/master#将此分支推送到远程仓库$ git push origin HEAD -u","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"网络基础知识小集","date":"2018-04-17T09:01:48.000Z","path":"2018/04/17/网络基础知识小集/","text":"session与cookie常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。 联系： Cookie与Session都是用来跟踪浏览器用户身份的会话方式。 区别： Cookie数据存放在客户的浏览器上，Session数据放在服务器上。 Cookie不是很安全，别人可以分析存放在本地的Cookie并进行Cookie欺骗,如果主要考虑到安全应当使用加密的Cookie或者Session。 Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用Cookie。 单个Cookie在客户端的限制是4K，很多浏览器都限制一个站点最多保存20个Cookie。 当你在浏览器地址栏输入一个URL后回车，将会发生的事情？域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 DNS域名解析过程浏览器缓存 –&gt; 系统缓存 –&gt; 路由器缓存 –&gt; ISP（互联网服务提供商）DNS缓存 –&gt; 根域名服务器 –&gt; 顶级域名服务器 –&gt; 主域名服务器 –&gt; 保存结果至缓存 ping工作原理Ping程序的实质是利用了ICMP请求回显和回显应答报文，但ARP请求和应答报文也在其中起了非常重要的作用。 Get和Post请求GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 GET参数通过URL传递，POST放在Request body中，所以GET比POST更不安全。 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET请求可以被收藏为书签 ，而POST不可以。 GET请求只能进行url编码（ASCII），而POST支持多种编码方式。 TCP的流量控制？流量控制往往指点对点通信量的控制，是个端到端的问题。 利用滑动窗口实现流量控制，如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。 TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计数器。如果窗口不是零，那么死锁的僵局就可以打破了。 TCP的拥塞控制 – Congestion Handling1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。 Http和https的区别 http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全 HTTPS 通信过程 客户端发送请求到服务器端 服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端 客户端使用共享密钥解密数据 SSL加密建立 OSI分层 （7层） TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下： 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 每一层的作用如下：​ 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） ​ 数据链路层：将比特组装成帧和点到点的传递（帧Frame） ​ 网络层：负责数据包从源到宿的传递和网际互连（分组、包PackeT） ​ 传输层：提供端到端的可靠报文传递和错误恢复（数据段Segment） ​ 会话层：建立、管理和终止会话（会话协议数据单元SPDU） ​ 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） ​ 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） IP地址的分类 A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）； B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； 10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部） ​ IP地址与子网掩码相与得到网络号 ARP是地址解析协议，简单语言解释一下工作原理​ 1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 ​ 2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。 3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 ​ 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 各种协议ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术， DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 描述：RARPRARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 在浏览器中输入www.baidu.com后执行的全部过程1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 事件顺序: (1) 浏览器获取输入的域名www.baidu.com (2) 浏览器向DNS请求解析www.baidu.com的IP地址 (3) 域名系统DNS解析出百度服务器的IP地址 (4) 浏览器与该服务器建立TCP连接(默认端口号80) (5) 浏览器发出HTTP请求，请求百度首页 (6) 服务器通过HTTP响应把首页文件发送给浏览器 (7) 释放TCP连接 (8) 浏览器将首页文件进行解析，并将Web页显示给用户。 涉及到的协议: (1) 应用层：HTTP(www访问协议)，DNS(域名解析服务) DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输 (2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作 (3)网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)为数据包选择路由，IP协议进行主要工作，相邻结点的可靠传输，ARP协议将IP地址转成MAC地址。 TCP对应的协议和UDP对应的协议TCP对应的协议：（1）FTP：定义了文件传输协议，使用21端口。 （2）Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 （3）SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 （4）POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的协议： （1）DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 （3）TFTP(Trival File Traner Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 DNS域名系统，简单描述其工作原理。 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 面向连接和非面向连接的服务的特点是什么？面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。 非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。 端口及对应的服务？ 服务 端口号 服务 端口号 FTP 21 SSH 22 telnet 23 SMTP 25 Domain(域名服务器) 53 HTTP 80 POP3 110 NTP（网络时间协议） 123 MySQL数据库服务 3306 Shell或 cmd 514 POP-2 109 SQL Server 1433 交换机与路由器有什么区别？①工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层 ②寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址 ③转发速不同：交换机的转发速度快，路由器转发速度相对较慢。","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"输出比当前数大的最近的4的倍数","date":"2018-04-17T05:12:23.000Z","path":"2018/04/17/输出比当前数大的最近的4的倍数/","text":"题目： 输入1.2.3.4中任意数则输出4；输入5.6.7.8中任意数则输出8；不使用语法关键字 解法： 1((x-1)/4+1)*4;","tags":[{"name":"数学题","slug":"数学题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数学题/"}]},{"title":"Deepin下vsftpd虚拟用户配置","date":"2018-04-16T15:17:02.000Z","path":"2018/04/16/Deepin下vsftpd虚拟用户配置/","text":"安装vsftpd和db-util12sudo apt-get -y install vsftpdsudo apt-get install db-util 查看下vsftpd都安装了那些文件 1dpkg -L vsftpd |tac 建立本地虚拟用户 12sudo useradd -m -d /home/vsftpd vsftpd #指定目录为/home/vsftpdsudo cat /etc/passwd |grep vsftpd #查看家目录 注意：创建的用户vsftpd现在是无法登录到系统的，因为没有给该用户设置密码。在此，我们也无需让vsftpd登录到系统，这样相对来说比较安全。 用户创建完毕后，我们来创建对应的目录并修改其所属用户，如下： 1sudo chown -R vsftpd:vsftpd /home/vsftpd/ 建立虚拟用户数据库12sudo mkdir /etc/vsftpdsudo vim /etc/vsftpd/login.txt 将下面的内容填到login.txt文件内： 123456norco1norcoarm1norco2norcoarm2norco3norcoarm3 注：login.txt为登录vsftpd的用户与密码文件。奇数行为用户名，偶数行为密码。 。如下： 1234#使用db_load对loginx.txt进行加密sudo db_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/login.db#修改权限（此步可不做，未发现问题）chmod 600 /etc/vsftpd/vsftpd_login.db 生成数据库文件之后建议删除 loginuser.txt PAM验证配置vsftpd的PAM验证，在此没有使用vsftpd安装时所生成的/etc/pam.d/vsftpd文件。 因为经过多次的测试，发现如果使用该文件进行验证的话，无法验证通过。猜想有可能是vsftpd的一个BUG。 创建验证文件，如下： 123sudo vim /etc/pam.d/vsftpd.virtualauth required pam_userdb.so db=/etc/vsftpd/loginaccount required pam_userdb.so db=/etc/vsftpd/login 其中/etc/vsftpd/login对应/etc/vsftpd/login.db文件 vsftp权限配置现在正式配置vsftpd，vsftpd的几乎所有配置项都在/etc/vsftpd.conf文件中进行。 先备份。 根据业务要求vsftpd.conf配置内容如下： 12345678910111213141516171819202122232425listen=YESlisten_ipv6=NOanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_file=/var/log/vsftpd.logxferlog_std_format=YESchroot_local_user=YESchroot_list_enable=NOallow_writeable_chroot=YESsecure_chroot_dir=/var/run/vsftpd/emptyrsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NOguest_enable=YESpam_service_name=vsftpd.virtualuser_config_dir=/etc/vsftpd/vupasv_enable=YESpasv_min_port=30000pasv_max_port=31000 在以上配置文件中，有几点需要重点指出。 local_enable=YES write_enable=YES local_umask=022 这两项是启用系统用户的写权限。特别是write_enable=YES项一定要启用，否则vsftpd虚拟用户将无法登录vsftpd。 为什么会是这样？因为虚拟用户依赖与系统用户。 chroot_local_user=YES chroot_list_enable=NO allow_writeable_chroot=YES 这三项是配置vsftpd用户禁止切换上级目录的权限。 guest_enable=YES pam_service_name=vsftpd.virtual user_config_dir=/etc/vsftpd/vu 这三项是启用vsftpd虚拟用以及虚拟用户账号配置目录。 pasv_enable=YES pasv_min_port=30000 pasv_max_port=31000 这三项是启用vsftpd被动模式及相关端口。 虚拟用户相关配置vsftpd配置文件修改文件后，现在开始配置虚拟用户的相关权限。如下： 123456sudo mkdir /etc/vsftpd/vusudo vim /etc/vsftpd/vu/ailanniguest_username=ftpilannilocal_root=/www/virtual_use_local_privs=YESanon_umask=133 以上配置参数，其中guest_username=ftpilanni表示的是设置FTP对应的系统用户为ftpilanni local_root=/www/表示使用本地用户登录到ftp时的默认目录。 virtual_use_local_privs=YES虚拟用户和本地用户有相同的权限。 anon_umask表示文件上传的默认掩码。计算方式是777减去anon_umask就是上传文件的权限。在此我们设置的是133，也就是说上传后文件的权限是644。即上传的文件对所属用户来说只有读写权限，没有执行权限。 若需配置多个用户时如下设置用户权限 在该文件夹下依次建立与login.txt对应的帐号名称相同的文件内容可以参考下面： 123456789101112131415161718192021#vim norco1#[norco1]只允许下载anon_world_readable_only=NOlocal_root=/opt/ftp/norco1#vim norco2 #[norco2]允许建立，修改，但是不允许删除anon_world_readable_only=NOwrite_enable=YESanon_mkdir_write_enable=YESanon_upload_enable=YESlocal_root=/opt/ftp/norco2#vim norco3#[norco3]全部权限anon_world_readable_only=NOwrite_enable=YESanon_mkdir_write_enable=YESanon_upload_enable=YESanon_other_write_enable=YESlocal_root=/opt/ftp/norco3","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"线程池","date":"2018-04-15T15:50:48.000Z","path":"2018/04/15/线程池/","text":"什么是线程池？线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 线程池的好处： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 假设一个服务器完成一项任务所需的时间是：创建线程的时间T1，线程执行任务的时间T2，线程销毁的时间T3。如果每次请求到达就创建一个新的线程，且并发的线程数量很多，每个线程执行很短时间（T1+T3远大于T2）就结束了，这样频繁创建线程的开销是很大的，同时大大降低系统的效率。 具体参数介绍 corePollSize：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。 maximumPoolSize：最大线程数。表明线程中最多能够创建的线程数量。 keepAliveTime：空闲的线程保留的时间。 TimeUnit：空闲线程的保留时间单位。 BlockingQueue ：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选。 ThreadFactory：线程工厂，用来创建线程 RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略。 线程池工作原则 1、当线程池中线程数量小于 corePoolSize 则创建线程，并处理请求。 2、当线程池中线程数量大于等于 corePoolSize 时，则把请求放入 workQueue 中,随着线程池中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就从workQueue 中取任务并处理。 3 、当 taskQueue 已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数目达到 maximumPoolSize（最大线程数量设置值）。 4、如果线程池中线程数大于 maximumPoolSize 则使用 RejectedExecutionHandler 来进行任务拒绝处理。 设计一个动态大小的线程池，如何设计，应该有哪些方法 ？ 一个线程池包括以下四个基本组成部分： 线程管理器(ThreadPool)：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务； 工作线程(PoolWorker)：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 任务接口(Task)：每个任务必须实现的接口，以供工作线程调度任务的执行。它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 任务队列(TaskQueue)：用于存放没有处理的任务。提供一种缓冲机制； 所包含的方法 1.privateThreadPool() 创建线程池 2.public static ThreadPoolgetThreadPool() 获得一个默认线程个数的线程池 3.public voidexecute(Runnable task) 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 4.public voidexecute(Runnable[] task) 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 5.public void destroy() 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁 6.public intgetWorkThreadNumber() 返回工作线程的个数 7.public intgetFinishedTasknumber() 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成 8.public voidaddThread() 在保证线程池中所有线程正在执行，并且要执行线程的个数大于某一值时。增加线程池中线程的个数 9.public voidreduceThread() 在保证线程池中有很大一部分线程处于空闲状态，并且空闲状态的线程在小于某一值时，减少线程池中线程的个数","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java实现多线程的方式及三种方式的区别","date":"2018-04-15T07:38:02.000Z","path":"2018/04/15/Java实现多线程的方式及三种方式的区别 - 副本/","text":"实现多线程的方式 继承Thread类，重写run函数。 实现Runnable接口 使用ExecutorService、Callable、Future实现有返回结果的多线程 三种方式的区别 实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。 继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。 实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java基础知识小集","date":"2018-04-14T14:05:13.000Z","path":"2018/04/14/Java基础知识小集/","text":"1.面向对象和面向过程的区别 面向过程 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。缺点：没有面向对象易维护、易复用、易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护缺点：性能比面向过程低 2.Java的四个基本特性（抽象、封装、继承，多态） 抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。 继承：是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于抽取多类事物的共性。 多态：允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。 3.重载和重写的区别 重载：发生在同一个类中，方法名必须相同，参数类型不同、参数个数不同，方法返回值和访问修饰符可以相同也可以不同，发生在编译时。调用方法时通过传递给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类（子类重写方法的返回值类型应为父类方法返回值类型的子类或和父类方法返回值类型相等），抛出的异常小于等于父类，访问修饰符大于等于父类（即访问权限更宽松，不能更严格）；如果父类方法访问修饰符为private则子类中就不是重写。 4.构造器Constructor是否可被override构造器不能被重写，不能用static修饰构造器，只能用public、private、protected这三个权限修饰符，且不能有返回语句。 5.String和StringBuffer、StringBuilder的区别 可变性 String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。 线程安全性 String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对String 类型进行改变的时候，都会生成一个新的String 对象，然后将指针指向新的String 对象。StringBuffer每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 6.hashCode和equals方法的关系 equals相等，hashcode必相等；hashcode相等，equals可能不相等。 7.抽象类和接口的区别 语法层次 抽象类和接口分别给出了不同的语法定义。 设计层次 抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 跨域不同 抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a”关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，”like-a”的关系。 8.自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。 9.什么是泛型、为什么要使用以及泛型擦除 泛型，即“参数化类型”。 创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。 Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下： 1）.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2）.移除所有的类型参数。 10.Java中的集合类及关系图 List和Set继承自Collection接口。 Set无序不允许元素重复。HashSet和TreeSet是两个主要的实现类。 List有序且允许元素重复。ArrayList、LinkedList和Vector是三个主要的实现类。 Map也属于集合系统，但和Collection接口没关系。Map是key对value的映射集合，其中key列就是一个集合。key不能重复，但是value可以重复。HashMap、TreeMap和Hashtable是三个主要的实现类。 SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序。 11.ArrayList和vector区别ArrayList和Vector都实现了List接口，都是通过数组实现的。Vector是线程安全的，而ArrayList是非线程安全的。List第一次创建的时候，会有一个初始大小，随着不断向List中增加元素，当List 认为容量不够的时候就会进行扩容。Vector缺省情况下自动增长原来一倍的数组长度，ArrayList增长原来的50%。 12.ArrayList和LinkedList区别及使用场景区别 ArrayList底层是用数组实现的，可以认为ArrayList是一个可改变大小的数组。随着越来越多的元素被添加到ArrayList中，其规模是动态增加的。 LinkedList底层是通过双向链表实现的， LinkedList和ArrayList相比，增删的速度较快。但是查询和修改值的速度较慢。同时，LinkedList还实现了Queue接口，所以他还提供了offer(),peek(), poll()等方法。 使用场景 LinkedList更适合从中间插入或者删除（链表的特性）。 ArrayList更适合检索和在末尾插入或删除（数组的特性）。 13.Collection和Collections的区别 java.util.Collection是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 14.Concurrenthashmap实现原理 具体原理参考文章： http://www.cnblogs.com/ITtangtang/p/3948786.html http://ifeve.com/concurrenthashmap/ 15.Error、Exception区别Error类和Exception类的父类都是throwable类，他们的区别是： Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 16.Unchecked Exception和Checked Exception，各列举几个# Unchecked Exception: a. 指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复。 b. 包括Error与RuntimeException及其子类，如：OutOfMemoryError, UndeclaredThrowableException, IllegalArgumentException, IllegalMonitorStateException, NullPointerException, IllegalStateException, IndexOutOfBoundsException等。 c. 语法上不需要声明抛出异常。 Checked Exception: a. 代表程序不能直接控制的无效外界情况（如用户输入，数据库问题，网络异常，文件丢失等） b. 除了Error和RuntimeException及其子类之外，如：ClassNotFoundException, NamingException, ServletException, SQLException, IOException等。 c. 需要try catch处理或throws声明抛出异常。 17.Java中如何实现代理机制(JDK、CGLIB) JDK动态代理：代理类和目标类实现了共同的接口，用到InvocationHandler接口。 CGLIB动态代理：代理类是目标类的子类，用到MethodInterceptor接口。 18.线程的状态转换 19.如何停止一个线程 参考文章： http://www.cnblogs.com/greta/p/5624839.html 20.什么是线程安全 线程安全就是多线程访问同一代码，不会产生不确定的结果。 21.如何保证线程安全 对非安全的代码进行加锁控制； 使用线程安全的类； 多线程并发情况下，线程共享的变量改为方法级的局部变量。 23.多线程如何进行信息交互void notify() 唤醒在此对象监视器上等待的单个线程。 void notifyAll() 唤醒在此对象监视器上等待的所有线程。void wait() 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法。void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 24.sleep和wait的区别(考察的方向是是否会释放锁)sleep()方法是Thread类中方法，而wait()方法是Object类中的方法。 sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。 wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（waitpool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 25.多线程与死锁死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 产生死锁的原因： 一.因为系统资源不足。 二.进程运行推进的顺序不合适。 三.资源分配不当。 26.如何才能产生死锁 产生死锁的四个必要条件： 一.互斥条件：所谓互斥就是进程在某一时间内独占资源。 二.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 三.不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 四.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 27.死锁的预防 打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。 一.打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。 二.打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。 三.打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。 四.打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。 28.什么叫守护线程，用什么方法实现守护线程 守护线程是为其他线程的运行提供服务的线程。 setDaemon(boolean on)方法可以方便的设置线程的Daemon模式，true为守护模式，false为用户模式。 29.Java线程池技术及原理 参考文章： http://www.importnew.com/19011.html http://www.cnblogs.com/dolphin0520/p/3932921.html 30.java并发包concurrent及常用的类 这个内容有点多，参考文章： 并发包诸类概览：http://www.raychase.net/1912 线程池：http://www.cnblogs.com/dolphin0520/p/3932921.html 锁：http://www.cnblogs.com/dolphin0520/p/3923167.html 集合：http://www.cnblogs.com/huangfox/archive/2012/08/16/2642666.html 31.volatile关键字 用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。 Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。 锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的，如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。Volatile变量具有synchronized的可见性特性，但是不具备原子特性。这就是说线程能够自动发现volatile变量的最新值。 要使volatile变量提供理想的线程安全，必须同时满足下面两个条件：对变量的写操作不依赖于当前值；该变量没有包含在具有其他变量的不变式中。 第一个条件的限制使volatile变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作需要使x 的值在操作期间保持不变，而volatile变量无法实现这点。 每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。 read and load 从主存复制变量到当前工作内存 use and assign 执行代码，改变共享变量值 store and write 用工作内存数据刷新主存相关内容 其中use and assign 可以多次出现，但是这一些操作并不是原子性，也就是在read load之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。 32.Java中的NIO，BIO，AIO分别是什么 BIO:同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO:同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO:异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 33.IO和NIO区别一.IO是面向流的，NIO是面向缓冲区的。二.IO的各种流是阻塞的，NIO是非阻塞模式。三.Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 34.序列化与反序列化 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 一.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 二.在网络上传送对象的字节序列。 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 42.常见的序列化协议有哪些 Protobuf, Thrift, Hessian, Kryo 43.内存溢出和内存泄漏的区别 内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。 内存泄漏是指分配出去的内存不再使用，但是无法回收。 44.Java内存模型及各个区域的OOM，如何重现OOM 这部分内容很重要，详细阅读《深入理解Java虚拟机》，也可以详细阅读这篇文章http://hllvm.group.iteye.com/group/wiki/2857-JVM 45.出现OOM如何解决 一. 可通过命令定期抓取heap dump或者启动参数OOM时自动抓取heap dump文件。 二. 通过对比多个heap dump，以及heap dump的内容，分析代码找出内存占用最多的地方。 三. 分析占用的内存对象，是否是因为错误导致的内存未及时释放，或者数据过多导致的内存溢出。 46.用什么工具可以查出内存泄漏 一. Memory Analyzer－是一款开源的JAVA内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于Eclipse RCP(Rich Client Platform)，可以下载RCP的独立版本或者Eclipse的插件。 二. JProbe－分析Java的内存泄漏。 三.JProfiler－一个全功能的Java剖析工具，专用于分析J2SE和J2EE应用程序。它把CPU、执行绪和内存的剖析组合在一个强大的应用中，GUI可以找到效能瓶颈、抓出内存泄漏、并解决执行绪的问题。 四. JRockit－用来诊断Java内存泄漏并指出根本原因，专门针对Intel平台并得到优化，能在Intel硬件上获得最高的性能。 五. YourKit-.NET &amp; Java Profiling业界领先的Java和.NET程序性能分析工具。 六.AutomatedQA －AutomatedQA的获奖产品performance profiling和memory debugging工具集的下一代替换产品，支持Microsoft,Borland, Intel, Compaq 和 GNU编译器。可以为.NET和Windows程序生成全面细致的报告，从而帮助您轻松隔离并排除代码中含有的性能问题和内存/资源泄露问题。支持.Net 1.0,1.1,2.0,3.0和Windows 32/64位应用程序。 七.Compuware DevPartner Java Edition－包含Java内存检测,代码覆盖率测试,代码性能测试,线程死锁,分布式应用等几大功能模块 47.Java内存管理及回收算法 阅读这篇文章：http://www.cnblogs.com/hnrainll/archive/2013/11/06/3410042.html 48.Java类加载器及如何加载类(双亲委派) 阅读文章： https://www.ibm.com/developerworks/cn/java/j-lo-classloader/（推荐） http://blog.csdn.net/zhoudaxia/article/details/35824249 49.xml解析方式 一.DOM(JAXP Crimson解析器) 二.SAX 三.JDOM 四.DOM4J 区别： 一.DOM4J性能最好，连Sun的JAXM也在用DOM4J。目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J. 二.JDOM和DOM在性能测试时表现不佳，在测试10M 文档时内存溢出。在小文档情况下还值得考虑使用DOM和JDOM。虽然JDOM的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM仍是一个非常好的选择。DOM实现广泛应用于多种编程语言。它还是许多其它与XML相关的标准的基础，因为它正式获得W3C 推荐(与基于非标准的Java模型相对)，所以在某些类型的项目中可能也需要它(如在JavaScript中使用DOM)。 三.SAX表现较好，这要依赖于它特定的解析方式－事件驱动。一个SAX检测即将到来的XML流，但并没有载入到内存(当然当XML流被读入时，会有部分文档暂时隐藏在内存中)。 50.Statement和PreparedStatement之间的区别 一.PreparedStatement是预编译的,对于批量处理可以大大提高效率. 也叫JDBC存储过程 二.使用Statement 对象。在对数据库只执行一次性存取的时侯，用Statement 对象进行处理。PreparedStatement 对象的开销比Statement大，对于一次性操作并不会带来额外的好处。 三.statement每次执行sql语句，相关数据库都要执行sql语句的编译，preparedstatement是预编译得, preparedstatement支持批处理 四. 代码片段1: String updateString = “UPDATE COFFEES SET SALES = 75 “ + “WHERE COF_NAME LIKE ′Colombian′”; stmt.executeUpdate(updateString); 代码片段2: PreparedStatement updateSales = con.prepareStatement(“UPDATE COFFEES SET SALES = ? WHERE COF_NAME LIKE ? “); updateSales.setInt(1, 75); updateSales.setString(2, “Colombian”); updateSales.executeUpdate(); 片断2和片断1的区别在于，后者使用了PreparedStatement对象，而前者是普通的Statement对象。PreparedStatement对象不仅包含了SQL语句，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需DBMS运行SQL语句，而不必先编译。当你需要执行Statement对象多次的时候，PreparedStatement对象将会大大降低运行时间，当然也加快了访问数据库的速度。 这种转换也给你带来很大的便利，不必重复SQL语句的句法，而只需更改其中变量的值，便可重新执行SQL语句。选择PreparedStatement对象与否，在于相同句法的SQL语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。 五.执行许多SQL语句的JDBC程序产生大量的Statement和PreparedStatement对象。通常认为PreparedStatement对象比Statement对象更有效,特别是如果带有不同参数的同一SQL语句被多次执行的时候。PreparedStatement对象允许数据库预编译SQL语句，这样在随后的运行中可以节省时间并增加代码的可读性。 然而，在Oracle环境中，开发人员实际上有更大的灵活性。当使用Statement或PreparedStatement对象时，Oracle数据库会缓存SQL语句以便以后使用。在一些情况下,由于驱动器自身需要额外的处理和在Java应用程序和Oracle服务器间增加的网络活动，执行PreparedStatement对象实际上会花更长的时间。 然而，除了缓冲的问题之外，至少还有一个更好的原因使我们在企业应用程序中更喜欢使用PreparedStatement对象,那就是安全性。传递给PreparedStatement对象的参数可以被强制进行类型转换，使开发人员可以确保在插入或查询数据时与底层的数据库格式匹配。 当处理公共Web站点上的用户传来的数据的时候，安全性的问题就变得极为重要。传递给PreparedStatement的字符串参数会自动被驱动器忽略。最简单的情况下，这就意味着当你的程序试着将字符串“D’Angelo”插入到VARCHAR2中时，该语句将不会识别第一个“，”，从而导致悲惨的失败。几乎很少有必要创建你自己的字符串忽略代码。 在Web环境中，有恶意的用户会利用那些设计不完善的、不能正确处理字符串的应用程序。特别是在公共Web站点上,在没有首先通过PreparedStatement对象处理的情况下，所有的用户输入都不应该传递给SQL语句。此外，在用户有机会修改SQL语句的地方，如HTML的隐藏区域或一个查询字符串上，SQL语句都不应该被显示出来。 51.servlet生命周期及各个方法 参考文章http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html 52.servlet中如何自定义filter 参考文章http://www.cnblogs.com/javawebsoa/archive/2013/07/31/3228858.html 53.JSP原理 参考文章http://blog.csdn.net/hanxuemin12345/article/details/23831645 54.JSP和Servlet的区别 (1)JSP经编译后就变成了“类servlet”。 (2)JSP由HTML代码和JSP标签构成，更擅长页面显示；Servlet更擅长流程控制。 (3)JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。 55.JSP的动态include和静态include (1)动态include用jsp:include动作实现，如&lt;jsp:include page=”abc.jsp” flush=”true” /&gt;，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。会先解析所要包含的页面，解析后和主页面合并一起显示，即先编译后包含。 (2)静态include用include伪码实现，不会检查所含文件的变化，适用于包含静态页面，如&lt;%@ include file=”qq.htm” %&gt;，不会提前解析所要包含的页面，先把要显示的页面包含进来，然后统一编译，即先包含后编译。 56.Struts中请求处理过程 参考文章http://www.cnblogs.com/liuling/p/2013-8-10-01.html 57.MVC概念 参考文章http://www.cnblogs.com/scwyh/articles/1436802.html 58.Springmvc与Struts区别 参考文章： http://blog.csdn.net/tch918/article/details/38305395 http://blog.csdn.net/chenleixing/article/details/44570681 59.Hibernate/Ibatis两者的区别 参考文章http://blog.csdn.net/firejuly/article/details/8190229 60.Hibernate一级和二级缓存 参考文章http://blog.csdn.net/windrui/article/details/23165845 61.简述Hibernate常见优化策略 参考文章http://blog.csdn.net/shimiso/article/details/8819114 62.Springbean的加载过程(推荐看Spring的源码) 参考文章http://geeekr.com/read-spring-source-1-how-to-load-bean/ 63.Springbean的实例化(推荐看Spring的源码) 参考文章http://geeekr.com/read-spring-source-two-beans-initialization/ 64.Spring如何实现AOP和IOC(推荐看Spring的源码) 参考文章http://www.360doc.com/content/15/0116/21/12385684_441408260.shtml 65.Springbean注入方式 参考文章http://blessht.iteye.com/blog/1162131 66.Spring的事务管理 这个主题的参考文章没找到特别好的，http://blog.csdn.net/trigl/article/details/50968079这个还可以。 67.Spring事务的传播特性 参考文章http://blog.csdn.net/lfsf802/article/details/9417095 68.springmvc原理 参考文章http://blog.sina.com.cn/s/blog_7ef0a3fb0101po57.html 69.springmvc用过哪些注解 参考文章http://aijuans.iteye.com/blog/2160141 70.Restful有几种请求 参考文章，http://www.infoq.com/cn/articles/designing-restful-http-apps-roth，该篇写的比较全。 71.Restful好处 (1)客户-服务器：客户-服务器约束背后的原则是分离关注点。通过分离用户接口和数据存储这两个关注点，改善了用户接口跨多个平台的可移植性；同时通过简化服务器组件，改善了系统的可伸缩性。 (2)无状态：通信在本质上是无状态的，改善了可见性、可靠性、可伸缩性. (3)缓存：改善了网络效率减少一系列交互的平均延迟时间，来提高效率、可伸缩性和用户可觉察的性能。 (4)统一接口：REST架构风格区别于其他基于网络的架构风格的核心特征是，它强调组件之间要有一个统一的接口。 72.Tomcat，Apache，JBoss的区别 Apache:HTTP服务器(WEB服务器)，类似IIS，可以用于建立虚拟站点，编译处理静态页面，可以支持SSL技术，支持多个虚拟主机等功能。 Tomcat:Servlet容器，用于解析jsp，Servlet的Servlet容器，是高效，轻量级的容器。缺点是不支持EJB，只能用于java应用。 Jboss:应用服务器，运行EJB的J2EE应用服务器，遵循J2EE规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA等，其对Servlet的支持是通过集成其他Servlet容器来实现的，如tomcat和jetty。 73.memcached和redis的区别 (1)性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。 (2)内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 (3)Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。 74.如何理解分布式锁 参考文章： http://blog.csdn.net/zheng0518/article/details/51607063 http://blog.csdn.net/nicewuranran/article/details/51730131。 75.你知道的开源协议有哪些 常见的开源协议有GPL、LGPL、BSD、Apache Licence vesion 2.0、MIT，详细内容参考文章: http://blog.jobbole.com/44175/、http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html。 76.json和xml区别 XML: (1)应用广泛，可扩展性强，被广泛应用各种场合； (2)读取、解析没有JSON快； (3)可读性强，可描述复杂结构。 JSON: (1)结构简单，都是键值对； (2)读取、解析速度快，很多语言支持； (3)传输数据量小，传输速率大大提高； (4)描述复杂结构能力较弱。 77.设计模式 参考文章：http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445。 78.设计模式的六大原则 参考文章http://www.uml.org.cn/sjms/201211023.asp。 79.用一个设计模式写一段代码或画出一个设计模式的UML 参考文章http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445 80.高内聚，低耦合方面的理解 参考文章http://my.oschina.net/heweipo/blog/423235。 81.深度优先和广度优先算法 推荐看书籍复习！可参考文章： http://blog.163.com/zhoumhan_0351/blog/static/3995422720098342257387/ http://blog.163.com/zhoumhan_0351/blog/static/3995422720098711040303/ http://blog.csdn.net/andyelvis/article/details/1728378 http://driftcloudy.iteye.com/blog/782873 82.排序算法及对应的时间复杂度和空间复杂度 推荐看书籍复习！可参考文章： http://www.cnblogs.com/liuling/p/2013-7-24-01.html http://blog.csdn.net/cyuyanenen/article/details/51514443 http://blog.csdn.net/whuslei/article/details/6442755 83.排序算法编码实现 参考http://www.cnblogs.com/liuling/p/2013-7-24-01.html 84.查找算法 参考http://sanwen8.cn/p/142Wbu5.html 85.B+树 参考http://www.cnblogs.com/syxchina/archive/2011/03/02/2197251.html 86.KMP算法 推荐阅读数据复习！参考http://www.cnblogs.com/c-cloud/p/3224788.html 87.hash算法及常用的hash算法 参考http://www.360doc.com/content/13/0409/14/10384031_277138819.shtml 88.如何判断一个单链表是否有环 参考文章： http://www.jianshu.com/p/0e28d31600dd http://my.oschina.net/u/2391658/blog/693277?p= 89.队列、栈、链表、树、堆、图 推荐阅读数据复习！ 90.linux常用命令 参考http://www.jianshu.com/p/03cfc1a721b8 91.如何查看内存使用情况 参考http://blog.csdn.net/windrui/article/details/40046413 92.Linux下如何进行进程调度 推荐阅读书籍复习，参考文章： http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html http://blog.csdn.net/rainharder/article/details/7975387 93.产生死锁的必要条件 参考http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html 94.死锁预防 参考http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html 95.数据库范式 参考http://www.360doc.com/content/12/0712/20/5287961_223855037.shtml 96.数据库事务隔离级别 参考http://blog.csdn.net/fg2006/article/details/6937413 97.数据库连接池的原理 参考http://blog.csdn.net/shuaihj/article/details/14223015 98.乐观锁和悲观锁 参考http://www.open-open.com/lib/view/open1452046967245.html 99.如何实现不同数据库的数据查询分页 参考http://blog.csdn.net/yztezhl/article/details/20489387 100.SQL注入的原理，如何预防 参考https://www.aliyun.com/zixun/content/3_15_245099.html 101.数据库索引的实现(B+树介绍、和B树、R树区别) 参考文章： http://blog.csdn.net/kennyrose/article/details/7532032 http://www.xuebuyuan.com/2216918.html 102.SQL性能优化 参考文章： http://database.51cto.com/art/200904/118526.htm http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html 103.数据库索引的优缺点以及什么时候数据库索引失效 参考文章： http://www.cnblogs.com/mxmbk/articles/5226344.html http://www.cnblogs.com/simplefrog/archive/2012/07/15/2592527.html http://www.open-open.com/lib/view/open1418476492792.html http://blog.csdn.net/colin_liu2009/article/details/7301089 http://www.cnblogs.com/hongfei/archive/2012/10/20/2732589.html 104.Redis的数据类型 参考http://blog.csdn.net/hechurui/article/details/49508735 107.HTTP报文内容 参考文章： https://yq.aliyun.com/articles/44675 http://www.cnblogs.com/klguang/p/4618526.html http://my.oschina.net/orgsky/blog/387759 113.redirect与forward区别 参考http://www.cnblogs.com/wxgblogs/p/5602849.html 局部变量能否和成员变量重名？局部变量可以和成员变量重名，不加“this”修饰时，优先使用最近的变量。 java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。在实例方法中出现变量名相同时，可以使用this关键字来调用。如果成员变量用static修饰了呢，也能用this调用吗？不能了，这个时候可以通过类名来调用，因为静态成员是属于类的。 网络编程中设计并发服务器，使用多进程与多线程有什么区别？答案一:1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。两者都可以提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP(SymmetricMulti-Processing，对称多处理结构的简称，是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。)机器上运行，而进程则可以跨机器迁移。答案二:根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"操作系统知识小集","date":"2018-04-14T12:50:06.000Z","path":"2018/04/14/操作系统知识小集/","text":"进程状态变化 注意：创建和退出不是进程的状态。阻塞和就绪的区别：阻塞是等待除CPU以外的资源，而就绪等待的是CPU资源。 1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态； 2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态； 4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。 以下两种状态是不可能发生的： 阻塞——&gt;运行：即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，而是从就绪队列中选取 就绪——&gt;阻塞：就绪态根本就没有执行，谈不上进入阻塞态。 1.银行家算法：系统处于不安全状态可能会发生死锁，处于安全状态一定不会发生死锁 2.Windows操作系统中，文件组织采用树型目录结构。 3.在设备管理中，逻辑设备表（LUT）的作用是（在物理设备和逻辑设备之间建立对应关系）。 4.某个磁盘系统采用最短寻道时间优先（SSTF）磁盘调度算法，假设有一个请求柱面读写的磁盘请 求队列如下：27、136、58、100、72、40，当前磁头位置是80 柱面。请问，磁盘总的移动距离为（）。 123456789101112131415161718192021 最短寻道时间优先（SSTF）磁盘调度算法，每次寻找最近的位置访问。(1)方向假设从磁盘内部向外部移动起始 80 移动距离（柱面）72 858 14 40 1827 13100 73136 36磁盘总的移动距离：8+14+18+13+73+36=162可以直接80-27+136-27 = 162(2)方向假设从磁盘外部向内部移动起始 80 移动距离100 20136 3672 6458 1440 1827 13磁盘总的移动距离：20+36+64+14+18+13=165 5.最短任务优先（SJF）调度算法可能会导致进程饿死（Starvation） 6.chmod 命令，改写文件的读写许可设置 语法为： chmod abc file 其中 a,b,c 各为一个数字，分别表示 User, Group, Other 的权限 读r = 4, 写w = 2, 执行x = 1 7.若一个 程序或 子程序可以安全的被 并行执行，则称其为 可重入（ reentrant或re-entrant）的；即，当该子程序正在运行时，可以再次进入并执行它。若一个函数是可重入的，则该函数： 不能含有 静态（全局）非常量数据。 不能返回静态（全局）非常量数据的地址。 只能处理由调用者提供的数据。 不能依赖于单实例模式资源的锁。 不能调用不可重入的函数。 多’用户/对象/进程 优先级’以及 多进程一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的资源。 8.一个完整的计算机系统应包括___硬件系统和软件系统 9.多道程序技术即是指在内存中存放多道作业，运行结束或出错，自动调度内存中另一道作业运行。多道程序主要优点如下： （1）资源利用率高。由于内存中装入了多道程序，使它们共享资源，保持系统资源处于忙碌状态，从而使各种资源得以充分利用。 （2）系统吞吐量大。由于CPU和其它系统资源保持“忙碌”状态，而且仅当作业完成或运行不下去时才切换，系统开销小，所以吞吐量 10.文件的保密是防止文件被（窃取） 11.实现进程之间同步与互斥的通信工具为（ P、V操作 ）。 12.进程的三个状态： ​ 运行态：进程占有处理器运行 ​ 就绪态：进程具备运行条件等待处理器运行 ​ 等待态：进程由于等待资源、输入输出、信号等而不具备运行条件 三种状态之间的转换： ​ 运行态——&gt;等待态：等待资源、I/O、信号 ​ 等待态——&gt;就绪态：资源满足、I/O结束、信号完成 ​ 就绪态——&gt;运行态：处理器空闲时选择更高优先权进程抢占 ​ 运行态——&gt;就绪态：运行时间片到、有更高优先权进程 13.用管程实现进程同步时，管程中的过程是不可中断的。管程中的过程是原语，是不能中断的。 14.在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是（）。有上邻空闲区，也有下邻空闲区 15.临界资源是指每次仅允许一个进程访问的资源。 属于临界资源的硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。 诸进程间应采取互斥方式，实现对这种资源的共享。 若信号量S的初值为2，当前值为-1，则表示有_1_个进程等待信号量S。 信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为两类： 公用信号量：实现进程间的互斥，初值为1或资源的数目； 私用信号量：实现进程间的同步，初值为0或某个正整数。 信号量S的物理意义：S≥0表示某资源的可用数，若S＜0，则其绝对值表示阻塞队列中等待该资源的进程数。当信号量S为-1时，其绝对值表示阻塞队列中等待该资源的进程数为1。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"找东西背后的概率问题","date":"2018-04-14T12:44:16.000Z","path":"2018/04/14/找东西背后的概率问题/","text":"来自于《思考的乐趣-Matrix67数学笔记》第一部分第2节的一条小题 题目： 我的书桌有8个抽屉，分别用数字1到8编号。每次拿到一份文件后，我都会把这份文件随机的放在一个抽屉中。但是我非常粗心，有1/5的概率会忘了把文件放进抽屉里，最终把文件搞丢。 现在我要找一份非常重要的文件。我将按顺序打开每一个抽屉，直到找到这份文件为止（或者很悲剧的发现，翻遍了所有抽屉都没能找到这份文件）。考虑下面三个问题。(1) 假如我打开了第一个抽屉，发现里面没有我要的文件。这份文件在其余的7个抽屉里的概率是多少？(2) 假如我翻遍了前4个抽屉，里面都没有我要的文件。这份文件在剩下的4个抽屉里的概率是多少？(3) 假如我翻遍了前7个抽屉，里面都没有我要的文件。这份文件在最后一个抽屉里的概率是多少？ 解： M牛在书中给出的一个巧妙解法是这样的: 注意到，平均每10份文件就有两份被搞丢，其余8份平均地分给了8个抽屉。假如我把所有搞丢了的文件都找了回来，那么它们应该还占2个抽屉。这让我们想到了这样一个有趣的思路：在这8个抽屉后加上2个虚拟抽屉——抽屉9和抽屉10，这两个抽屉专门用来装我丢掉的文件。我们甚至可以把题目等价地变为：随机把文件放在10个抽屉里，但找文件时不允许打开最后2个抽屉。当我已经找过n个抽屉但仍没找到我想要的文件时，文件只能在剩下的10-n个抽屉里，但是我只能打开剩下的8-n个抽屉，因此所有的概率是(8 - n)/(10 - n)。当n分别等于1、4、7时，这个概率值分别是7/9、2/3和1/3。 从基本的解法中可发现，对于此题中的事件A、B，有P(A|B)恒等于1。因此，实际上当文件不在前n个抽屉中时，文件在后(抽屉总数-n)个抽屉中的概率就为(文件在后(抽屉总数 - n)个抽屉中的概率 除以 文件不在前n个抽屉中的概率) 考虑文件不在前n个抽屉中的概率，可得P(文件不在前n个抽屉中) = 1 - P(文件不丢失)·(n / 抽屉总数) 考虑文件在后(抽屉总数 - n)个抽屉中的概率，可得P(文件在后(抽屉总数 - n)个抽屉中) = P(文件不丢失)·(抽屉总数 - n) / 抽屉总数 则总体概率为P(B|A) = P(文件不丢失)·(抽屉总数 - n) / (抽屉总数 - P(文件不丢失)·n) 代入P(文件不丢失) = 4/5， 抽屉总数 = 8，可得 总体概率P = (4/5)·(8 - n) / (8 - 4·n / 5) = (8 - n) / (10 - n) 转载自网络","tags":[{"name":"数学题","slug":"数学题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数学题/"}]},{"title":"Deepin用终端查看已安装的软件列表及软件卸载","date":"2018-04-13T05:04:56.000Z","path":"2018/04/13/Deepin用终端查看已安装的软件列表及软件卸载/","text":"查看已经安装的软件包： 1dpkg -l 卸载命令： 1sudo apt-get autoremove --purge 软件包名称 用于清理下载文件的存档 ： 1sudo apt-get clean 只清理过时的包 1sudo apt-get autoclean","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"Java访问权限修饰词的作用域","date":"2018-04-12T14:46:16.000Z","path":"2018/04/12/Java访问权限修饰词的作用域/","text":"作用域（可见） 当前类 同包 子孙类 其他包 public √ √ √ √ protected √ √ √ × default(friendly) √ √ × × private √ × × ×","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"String、StringBuffer、StringBuilder以及对String不变性的理解","date":"2018-04-12T14:40:27.000Z","path":"2018/04/12/String、StringBuffer、StringBuilder以及对String不变性的理解/","text":"String、StringBuffer、StringBuilder 都是 final 类, 都不允许被继承; String 长度是不可变的,StringBuffer、StringBuilder 长度是可变的; StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer在StringBuilder的方法之上添加了synchronized修饰，保证线程安全。 StringBuilder比StringBuffer拥有更好的性能。 如果一个String类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时String的速度比StringBuffer和StringBuilder的性能好的多。 String不变性的理解 String 类是被final进行修饰的，不能被继承。 在用+号链接字符串的时候会创建新的字符串。 String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有“Hello world”字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有“Hello world”对象，则堆上和静态区中都需要创建对象。 在 java 中, 通过使用 “+” 符号来串联字符串的时候, 实际上底层会转成通过 StringBuilder 实例的 append() 方法来实现。 String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？String有重写Object的hashcode和toString吗？ String重写了Object类的hashcode和toString方法。 当equals方法被重写时，通常有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相对等的两个对象必须有相同的hashCode object1.euqal(object2) 为true时，object1.hashCode() == object2.hashCode() 为true object1.hashCode() == object2.hashCode() 为false时，object1.euqal(object2)必定为false object1.hashCode() == object2.hashCode() 为true时，但object1.euqal(object2)不一定为true 重写equals不重写hashcode会出现什么问题 在存储散列集合时(如Set类)，如果原对象.equals(新对象)，但没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写equals方法时，必须重写hashCode方法。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"TCP与UDP、三次握手四次挥手","date":"2018-04-12T14:37:51.000Z","path":"2018/04/12/TCP与UDP、三次握手四次挥手/","text":"区别 TCP 提供面向连接、可靠的数据流传输，而UDP 提供的是非面向连接的、不可靠的数据流传输。 TCP 传输单位称为TCP 报文段，UDP 传输单位称为用户数据报。 TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。 TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。 TCP首部开销20字节；UDP的首部开销小，只有8个字节。 TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。 TCP加快传输效率的方法 :采取一块确认的机制 为什么UDP有时比TCP更有优势?UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。 （1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。 （2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。 采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 TCP如何保证可靠传输？三次握手过程？ 数据包校验 超时重传机制 应答机制 对失序数据包重排序 TCP还能提供流量控制 三次握手与四次挥手 TCP共有6个标志位，分别是： SYN(synchronous),建立联机。 ACK(acknowledgement),确认。 PSH(push),传输。 FIN(finish),结束。 RST(reset),重置。 URG(urgent),紧急。 三次握手与四次挥手分别对应TCP连接建立过程与断开过程，先上TCP报文格式： 三次握手过程： 问题1： 为什么要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 例子 ： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 问题2：为什么要发送特定的数据包，随便发不行吗？三次握手的另外一个目的就是确认双方都支持TCP，告知对方用TCP传输。 第一次握手：Server 猜测Client可能要建立TCP请求，但不确定，因为也可能是Client乱发了一个数据包给自己 第二次握手：通过ack=J+1，Client知道Server是支持TCP的，且理解了自己要建立TCP连接的意图 第三次握手：通过ack=K+1，Server知道Client是支持TCP的，且确实是要建立TCP连接 四次挥手： 【注意】中断连接端可以是Client端，也可以是Server端。 问题1： 为什么要四次挥手？根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。 举个例子：A和B打电话，通话即将结束后，A说“我没啥要说的了”，B回答“我知道了”，但是B可能还会有要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说“我说完了”，A回答“知道了”，这样通话才算结束。 问题2：为什么双方要发送这样的数据包？和握手的情况类似，只是为了让对方知晓自己理解了对方的意图。 关于tcp中time_wait状态的4个问题time_wait是个常问的问题，tcp网络编程中最不容易理解的也是它的time_wait状态，这也说明了tcp/ip四次挥手中time_wait状态的重要性。 1.time_wait状态是什么简单来说：time_wait状态是四次挥手中服务器向客户端发送FIN终止连接后进入的状态。 可以看到time_wait状态存在于客户端收到服务器Fin并返回ack包时的状态当处于time_wait状态时，我们无法创建新的连接，因为端口被占用。 2.为什么客户端在time_wait状态必须等待2MSL的时间（为什么会有time_wait状态）？1.为了保证客户端发送的最后一个ACK报文段能够到达服务端。若处于time_wait的客户端发送给服务器的确认报文段ACK丢失的话，服务器将重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait而不是close状态。 2.保证已失效的报文段有足够的时间被识别并丢弃。客户端在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，防止在下一个连接中出现旧的连接请求报文段。time_wait持续的时间是2MSL，保证旧的数据可以丢弃，因为网络中的数据最大存在MSL(maxinum segment lifetime)。 3.哪一方会有time_wait状态time_wait状态是一般有客户端的状态。而且会占用端口有时产生在服务器端，因为服务器主动断开连接或者发生异常 4.如何避免time_wait状态占用资源如果是客户端，我们一般不用担心，因为客户端一般选用临时端口，再次创建连接会新分配一个端口。除非指定客户端使用某端口，不过一般不需要这么做。 如果是服务器主动关闭连接后异常终止，则因为它总是使用用一个知名服务器端口号，所以连接的time_wait状态将导致它不能重启，不过我们可以通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口。通过socksetopt设置后，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用。 此外也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而是tcp连接根本不进入time_wait状态，进而允许应用程序立即重用本地的socket地址。 close_wait状态出现的原因客户端向服务端发送了FIN报文，此时服务端进入CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN报文给客户端，那么可能是在关闭连接之前还有许多数据要发送给客户端或者其他事要做,导致没有发这个FIN packet。 如果客户端不断的发送请求连接会怎样？服务器端回为每个请求创建一个链接，然后向client端发送创建链接时的回复，然后进行等待客户端发送第三次握手数据包，这样会白白浪费资源 DDos攻击简单的说就是想服务器发送链接请求，首先进行 第一步：客户端向服务器端发送连接请求数据包（1） 第二步：服务器向客户端回复连接请求数据包（2），然后服务器等待客户端发送tcp/ip链接的第三步数据包(3) 第三步：如果客户端不向服务器端发送最后一个数据包(3)，则服务器须等待30s到2min中才能将此链接进行关闭。当大量的请求只进行到第二步，而不进行第三步，服务器又大量的资源等待第三个数据包。则造成DDos攻击。 DDos预防(没有根治的办法，除非不用TCP/IP链接)· 确保服务器的系统文件是最新版本，并及时更新系统补丁 · 关闭不必要的服务 · 限制同时打开SYN的半连接数目 · 缩短SYN半连接的timeout时间 · 正确设置防火墙 · 禁止对主机的非开放服务的访问 · 限制特定IP短地址的访问 · 启用防火墙的防DDos的属性 · 严格限制对外开放的服务器的向外访问 · 运行端口映射程序祸端口扫描程序，要认真检查特权端口和非特权端口。 · 认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更，那这台机器就可能遭到了攻击。 · 限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。 SYN网络攻击原理：在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-openconnect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。 检测：SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。windows下打开cmd,输入命令：”netstat -n -p TCP“ ，查看是否有大量的”SYN_RECEIVED“状态。","tags":[{"name":"网络","slug":"网络","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/网络/"}]},{"title":"查找算法","date":"2018-04-11T11:14:34.000Z","path":"2018/04/11/查找算法/","text":"目前查找方法主要：顺序查找、有序查找（分为：折半查找即二分查找、差值查找和斐波那契查找方法）、线性索引查找、二叉排序树、平衡二叉树（AVL树）以及多路查找树（B树）、散列表查找（哈希表）等查找方法 ​ 【1】顺序查找：是最简单的查找方法，其时间复杂度为O(n)，是通过构造一个线性表，采用遍历的方法，将记录与关键字一个一个的对比，若相等则查找成功，若全都不相等，则查找失败即记录不存在； ​ 【2】有序查找：顺序表的记录一般是无序，而有序表的记录是有序的；使用有序表查找方法时，前提条件是待查找的记录必须是已经排好序的。 有序查找分为：二分查找、插值查找和斐波那契查找方法 二分查找算法思想：又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。时间复杂度为 O(logN)。 实现： 1.非递归代码 12345678910111213141516public static int binarySearch(int []array,int a)&#123; int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi)&#123; mid=(lo+hi)/2; if(array[mid]==a)&#123; return mid+1; &#125;else if(array[mid]&lt;a)&#123; lo=mid+1; &#125;else&#123; hi=mid-1; &#125; &#125; return -1; &#125; 2.递归实现 12345678910111213public static int binarySearch(int []array,int a,int lo,int hi)&#123; if(lo&lt;=hi)&#123; int mid=(lo+hi)/2; if(a==array[mid])&#123; return mid; &#125;else if(a&gt;array[mid])&#123; return binarySearch(array,a,mid+1,hi); &#125;else&#123; return binarySearch(array,a,lo,mid-1); &#125; &#125; return -1;&#125; 插值查找对二分法查找进行改进，将要查找的关键字key与查找表中的最大最小值记录进行比较后，再确定查找的范围。在二分法查找中，是以中间记录作为查找分区的，即将表一分为二，分为上下两个查找分区： 而插值查找采用插值公式的方法，来确定查找分区。可简单这样理解，比如有100个数其值在0~1000范围之间从小到大排序，你要查找关键字为5的位置下标，若采用二分法，则大概在500的地方往下查找，但采用插值的方法，可以通过插值计算出5这个关键字应该在靠近0的地方，因此查找时从50往下开始查找，从而提高效率： ​ 因此插值查找只需要在折半查找算法的代码中简单修改一下即可： 12345678910111213141516171819202122232425262728public class JavaTest1 &#123; public static void main(String[] args) &#123; int[] num = &#123; 1, 2, 3, 4, 5, 6 &#125;;//必须有序 int index = Insert_Search(num, 5); System.out.print(index); &#125; /* *num：有序表（由小到大排列） key：要查找的关键字 *return：还回查找到关键字的下标，没有找到则还回-1 */ private static int Insert_Search(int[] num, int key) &#123; int low, high, mid; low = 0; high = num.length - 1; while (low &lt;= high) &#123; // mid = (low + high) / 2;//二分查找 mid = low + (high - low) * (key - num[low])/ (num[high] - num[low]);//插值查找 if (key &lt; num[mid]) high = mid - 1; else if (key &gt; num[mid]) low = mid + 1; else // 如果等于则直接还回下标值 return mid; &#125; return -1; &#125;&#125; 斐波那契查找​ 斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。 ​ 斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 斐波那契数列 */static int[] f = &#123; 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 &#125;;/** * 斐波那契查找(黄金分割原理) * @param a 待查询数组 * @param key 待查找关键字 * @return 返回关键字在a数组中的下标，返回-1表示数组中不存在此关键字 */public static int fibonaciSearch(int[] a, int key) &#123; int low, mid, high, k; low = 0; high = a.length - 1; // 斐波那契数列下标 k = 0; // 获取斐波那契分割值下标 while (high &gt; f[k] - 1) k++; // 利用Java工具类Arrays构造长度为f[k]的新数组并指向引用a a = Arrays.copyOf(a, f[k]); // 对新数组后面多余的元素赋值最大的元素 for (int i = high + 1; i &lt; f[k]; i++) &#123; a[i] = a[high];//当key是是最大值时候，防止角标越界异常 &#125; while (low &lt;= high) &#123; // 前半部分有f[k-1]个元素，由于下标从0开始 // 减去 1 获取 分割位置元素的下标 mid = low + f[k - 1] - 1; if (key &lt; a[mid]) &#123;//关键字小于分割位置元素，则继续查找前半部分，高位指针移动 high = mid - 1; // (全部元素) = (前半部分)+(后半部分) // f[k] = f[k-1] + f[k-2] // 因为前半部分有f[k-1]个元素， 则继续拆分f[k-1] = f[k-2] + f[k-3]成立 // 即在f[k-1]个元素的前半部分f[k-2]中继续查找，所以k = k - 1, // 则下次循环mid = low + f[k - 1 - 1] - 1; k = k - 1; &#125; else if (key &gt; a[mid])&#123;//关键字大于分割位置元素，则查找后半部分，低位指针移动 low = mid + 1; // (全部元素) = (前半部分)+(后半部分) // f[k] = f[k-1] + f[k-2] // 因为后半部分有f[k-2]个元素， 则继续拆分f[k-2] = f[k-3] + f[k-4]成立 // 即在f[k-2]个元素的前半部分f[k-3]继续查找，所以k = k - 2, // 则下次循环mid = low + f[k - 2 - 1] - 1; k = k - 2; &#125; else &#123; // 当条件成立的时候，则找到元素 if (mid &lt;= high) return mid; else // 出现这种情况是查找到补充的元素 // 而补充的元素与high位置的元素一样 return high; &#125; &#125; return -1;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"E05_2数组B合并到A数组","date":"2018-04-10T14:49:46.000Z","path":"2018/04/10/E05-2数组B合并到A数组/","text":"E05_2有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。题目： 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。 给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。 方法一：直接暴力解法，把B直接添加到A中，然后再排序，快排时间复杂度为nlog(n); 方法二：新建已个数组（这个题可以不需要建立数组），把A和B 的元素都添加到新数组中去，时间复杂度为O（M+N）;空间复杂度增加了O（M）； 方法三：在A的左边和B比较，然后将B插入到A中去，但是移动的次数过多，移动一次时间复杂度为O（M）,那么时间复杂就为O（M*N）; 方法四：先计算A和B的长度，由于数组的后面的元素是空的，所以可以从后面复杂数组元素。时间复杂度为O（M+N），空间复杂度为O（1）； 下列是解法： 把A看成有序的，然后把B中的数据插入到A中，再利用插入排序算法对A进行排序。假设A = {1, 4, 5}，B = ｛2, 3｝初始状态如下：此时A[0 ~ 2]是有序的，利用插入排序向A中插入2，插入后如下图所示A中的 4 和 5 向后移动了，接着向A[0 ~ 3]中插入3后此时4 和 5又向后移动了。再合并的时候，我们是从左向右合并的，结果造成了一些数据的多次移动，导致效率不理想。如果考虑从右向左合并呢？这时我们需要先断定合并后的从长度：k=lenA + lenB-1令i=lenA-1, j=lenB-1比较A[i]和B[j]，如果A[i]&gt;B[j]，A[k–]=A[i–];如果A[i]&lt;B[j]，A[k–]=B[j–];如此循环，直到 i&lt;0 或 j&lt;0最后再判断j是否为0，不为0就继续A[k–]=B[j–]按上面的流程执行，结果如下图所示代码： 123456789101112131415public static void mergeAB(int[] A,int n,int[] B,int m) &#123; int i=n-1 ; int j=m-1 ; int k=m+n-1 ; while(i&gt;=0 &amp;&amp; j &gt;= 0)&#123; if(A[i] &gt;= B[j])&#123; A[k--] = A[i--]; &#125;else&#123; A[k--] = B[j--]; &#125; &#125; while(j &gt;= 0)&#123; A[k--]=B[j--]; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"数组","slug":"数组","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数组/"}]},{"title":"E04二维数组中的查找","date":"2018-04-10T14:44:17.000Z","path":"2018/04/10/E04二维数组中的查找/","text":"题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617181920public boolean Find(int target, int [][] array) &#123; int rows = array.length; int columns = array[0].length; boolean flag = false; int i = 0; int j = columns -1; if(array != null &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0 )&#123; while(i &lt; rows &amp;&amp; j &gt;= 0)&#123; if(array [i][j] == target)&#123; flag = true; break; &#125;else if(array[i][j] &gt; target)&#123; j--; &#125;else &#123; i++; &#125; &#125; &#125; return flag;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"数组","slug":"数组","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数组/"}]},{"title":"E28对称的二叉树","date":"2018-04-09T13:52:17.000Z","path":"2018/04/09/E28对称的二叉树/","text":"题目: 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路： 首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同 左子树的右子树和右子树的左子树相同即可，采用递归 非递归也可，采用栈或队列存取各级子树根节点​ 123456789101112131415public class Solution &#123; boolean isSymmetrical(TreeNode pRoot)&#123; if(pRoot == null)&#123; return true; &#125; return comRoot(pRoot.left, pRoot.right); &#125; private boolean comRoot(TreeNode left, TreeNode right) &#123; if(left == null) return right==null;//此为\"等于\"的判断，不是赋值 if(right == null) return false; if(left.val != right.val) return false; return comRoot(left.right, right.left) &amp;&amp; comRoot(left.left, right.right); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E27二叉树的镜像","date":"2018-04-09T13:32:59.000Z","path":"2018/04/09/E27二叉树的镜像/","text":"题目： 操作给定的二叉树，将其变换为源二叉树的镜像。 思路： 先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像 123456789101112131415161718192021222324252627/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) return; TreeNode pTemp = root.left; root.left = root.right; root.right = pTemp; if(root.left != null) Mirror(root.left); if(root.right != null) Mirror(root.right); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E26树的子结构","date":"2018-04-09T12:41:58.000Z","path":"2018/04/09/E26树的子结构/","text":"题目： 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路： (1)在树A中找到和数B的根节点相同的节点； 可以利用前序遍历A树中的节点，找到和B树的根节点相同的节点。 (2)在树A中找到和树B根节点相同的节点设为R； 再对比节点R在树B中的左孩子和右孩子是否和树B中的节点相同。 如果R节点的值和树B中的节点的值不同，则不是子结构，如果相同，递归去判断他们的各自的左孩子和右孩子是否相同。 递归的出口是到达树A或者树B的叶节点。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public static boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if (root2 != null &amp;&amp; root1 != null) &#123; //如果找到了对应Tree2的根节点的点 if(root1.val == root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result = doesTree1HaveTree2(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125; public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2)&#123; //如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) &#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; //如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right); &#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E08二叉树的下一个结点","date":"2018-04-09T11:32:59.000Z","path":"2018/04/09/E08二叉树的下一个结点/","text":"题目： 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 12345678910111213141516171819202122232425262728/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; TreeLinkNode GetNext(TreeLinkNode node)&#123; if(node==null) return null; if(node.right!=null)&#123; //如果有右子树，则找右子树的最左节点 node = node.right; while(node.left!=null) node = node.left; return node; &#125; while(node.next!=null)&#123;//没右子树，则找第一个当前节点是父节点左孩子的节点 if(node.next.left==node) return node.next; node = node.next; &#125; return null; //退到了根节点仍没找到，则返回null &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"E07重建二叉树","date":"2018-04-09T08:25:27.000Z","path":"2018/04/09/E07重建二叉树/","text":"题目： 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路： 根据先序遍历数组，可以得到树的根节点，根据得到的根节点，去中序数组中找到相应的根节点，因为中序的遍历顺序是左–根–右，可以得到根节点的左子树和右子树的中序遍历数组，这样树的左子树中节点的个数和右子树上节点的个数就确定了。在先序数组中，左子树的先序和左子树的先序也可以确定了。 参数： 先序遍历数组，子树在先序数组中的开始位置，结束位置。 中序遍历数组，子树在中序数组中的开始位置，结束位置。 可以根据先序和中序数组得到子树的先序和中序数组，所以此问题可以用递归解决。 123456789101112131415161718192021222324252627public static TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre == null || in ==null) &#123; return null; &#125; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root;&#125;//前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;private static TreeNode reConstructBinaryTree( int[] pre,int startPre,int endPre,int[] in,int startIn,int endIn) &#123; if(startPre &gt; endPre || startIn &gt; endIn) return null; TreeNode root=new TreeNode(pre[startPre]); for(int i = startIn;i &lt;= endIn;i++)&#123; if(in[i] == pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn, in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre, in,i+1,endIn); break; &#125; &#125; return root;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"二叉树的遍历","date":"2018-04-09T08:05:11.000Z","path":"2018/04/09/二叉树的遍历/","text":"创建一棵树： 1234567891011121314151617181920212223242526272829public class Node &#123; private int data; private Node leftNode; private Node rightNode; public Node(int data, Node leftNode, Node rightNode)&#123; this.data = data; this.leftNode = leftNode; this.rightNode = rightNode; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getLeftNode() &#123; return leftNode; &#125; public void setLeftNode(Node leftNode) &#123; this.leftNode = leftNode; &#125; public Node getRightNode() &#123; return rightNode; &#125; public void setRightNode(Node rightNode) &#123; this.rightNode = rightNode; &#125; &#125; 简版： 1234567891011class TreeNode&#123; int data; TreeNode left; TreeNode right; public TreeNode(int data) &#123; this.data = data; this.left = null; this.right = null; &#125;&#125; 遍历时先判断二叉树是否为空的情况 递归： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class BinaryTree &#123; //二叉树的先序中序后序排序 public Node init() &#123;//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 Node J = new Node(8, null, null); Node H = new Node(4, null, null); Node G = new Node(2, null, null); Node F = new Node(7, null, J); Node E = new Node(5, H, null); Node D = new Node(1, null, G); Node C = new Node(9, F, null); Node B = new Node(3, D, E); Node A = new Node(6, B, C); return A; //返回根节点 &#125; public void printNode(Node node)&#123;//打印 System.out.print(node.getData()); &#125; public void theFirstTraversal(Node root) &#123; //先序遍历 printNode(root); if (root.getLeftNode() != null) &#123; //使用递归进行遍历左孩子 theFirstTraversal(root.getLeftNode()); &#125; if (root.getRightNode() != null) &#123; //递归遍历右孩子 theFirstTraversal(root.getRightNode()); &#125; &#125; public void theInOrderTraversal(Node root) &#123; //中序遍历 if (root.getLeftNode() != null) &#123; theInOrderTraversal(root.getLeftNode()); &#125; printNode(root); if (root.getRightNode() != null) &#123; theInOrderTraversal(root.getRightNode()); &#125; &#125; public void thePostOrderTraversal(Node root) &#123; //后序遍历 if (root.getLeftNode() != null) &#123; thePostOrderTraversal(root.getLeftNode()); &#125; if(root.getRightNode() != null) &#123; thePostOrderTraversal(root.getRightNode()); &#125; printNode(root); &#125; public static void main(String[] args) &#123; BinaryTree tree = new BinaryTree(); Node root = tree.init(); System.out.println(\"先序遍历\"); tree.theFirstTraversal(root); System.out.println(\"\"); System.out.println(\"中序遍历\"); tree.theInOrderTraversal(root); System.out.println(\"\"); System.out.println(\"后序遍历\"); tree.thePostOrderTraversal(root); System.out.println(\"\"); &#125; &#125; 非递归： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class BinaryTree1 &#123; public Node init() &#123;//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 Node J = new Node(8, null, null); Node H = new Node(4, null, null); Node G = new Node(2, null, null); Node F = new Node(7, null, J); Node E = new Node(5, H, null); Node D = new Node(1, null, G); Node C = new Node(9, F, null); Node B = new Node(3, D, E); Node A = new Node(6, B, C); return A; //返回根节点 &#125; public void printNode(Node node)&#123; System.out.print(node.getData()); &#125; public void theFirstTraversal_Stack(Node root) &#123; //先序遍历 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node node = root; while (node != null || stack.size() &gt; 0) &#123; //将所有左孩子压栈 if (node != null) &#123; //压栈之前先访问 printNode(node); stack.push(node); node = node.getLeftNode(); &#125; else &#123; node = stack.pop(); node = node.getRightNode(); &#125; &#125; &#125; public void theInOrderTraversal_Stack(Node root) &#123; //中序遍历 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node node = root; while (node != null || stack.size() &gt; 0) &#123; if (node != null) &#123; stack.push(node); //直接压栈 node = node.getLeftNode(); &#125; else &#123; node = stack.pop(); //出栈并访问 printNode(node); node = node.getRightNode(); &#125; &#125; &#125; public void thePostOrderTraversal_Stack(Node root) &#123; //后序遍历 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; output = new Stack&lt;Node&gt;();//构造一个中间栈来存储逆后序遍历的结果 Node node = root; while (node != null || stack.size() &gt; 0) &#123; if (node != null) &#123; output.push(node); stack.push(node); node = node.getRightNode(); &#125; else &#123; node = stack.pop(); node = node.getLeftNode(); &#125; &#125; System.out.println(output.size()); while (output.size() &gt; 0) &#123; printNode(output.pop()); &#125; &#125; public static void main(String[] args) &#123; BinaryTree1 tree = new BinaryTree1(); Node root = tree.init(); System.out.println(\"先序遍历\"); tree.theFirstTraversal_Stack(root); System.out.println(\"\"); System.out.println(\"中序遍历\"); tree.theInOrderTraversal_Stack(root); System.out.println(\"\"); System.out.println(\"后序遍历\"); tree.thePostOrderTraversal_Stack(root); System.out.println(\"\"); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"树","slug":"树","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/树/"}]},{"title":"栈","date":"2018-04-08T12:34:18.000Z","path":"2018/04/08/栈/","text":"定义： 栈是一种只能在一端进行插入或删除操作的线性表。（先进后出表） java中的Stack继承Vector 实例化 1Stack stack = new Stack(); 基本使用 序号 方法描述 1 boolean empty() 测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 示例： 123456789101112131415161718public class StackTest &#123; public static void main(String[] args) &#123; Stack stack=new Stack(); //1.empty()栈是否为空 System.out.println(stack.empty()); //2.peek()栈顶值 //3.进栈push() stack.push(new Integer(1)); stack.push(\"b\"); System.out.println(stack.peek()); //4.pop()出栈 stack.pop(); System.out.println(stack.peek()); System.out.println(stack.empty()); //5.search（）搜索位置 System.out.println(stack.search(1)); &#125;&#125; 运行结果： 12345trueb1false1","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"栈","slug":"栈","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/栈/"}]},{"title":"E52两个链表的第一个公共节点","date":"2018-04-08T11:47:10.000Z","path":"2018/04/08/E52两个链表的第一个公共节点/","text":"思路： 首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。 123456789101112131415161718192021222324252627282930313233public static ListNode findFirstCommonNode(ListNode head1, ListNode head2) &#123; int len1 = getListLength(head1); int len2 = getListLength(head2); ListNode longListNode = head1; ListNode shortListNode = head2; int dif = len1 - len2; if (len2 &gt; len1) &#123; longListNode = head2; shortListNode = head1; dif = len2 - len1; &#125; for (int i = 0; i &lt; dif; i++) &#123; longListNode = longListNode.nextNode; &#125; while (longListNode != null &amp;&amp; shortListNode != null &amp;&amp; longListNode != shortListNode) &#123; longListNode = longListNode.nextNode; shortListNode = shortListNode.nextNode; &#125; return longListNode;&#125;private static int getListLength(ListNode head1) &#123; int result = 0; if (head1 == null) return result; ListNode point = head1; while (point != null) &#123; point = point.nextNode; result++; &#125; return result;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E18_2删除链表中重复的节点","date":"2018-04-08T11:20:15.000Z","path":"2018/04/08/E18-2删除链表中重复的节点/","text":"题目： 在一个排序的链表中，如何删除重复的节点？ 样例输入： 1 2 3 3 4 4 5 样例输出： 1 2 5 解法一： 12345678910111213141516public static ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; // 只有0个或1个结点，则返回 return pHead; &#125; if (pHead.val == pHead.next.val) &#123; // 当前结点是重复结点 ListNode pNode = pHead.next; while (pNode != null &amp;&amp; pNode.val == pHead.val) &#123; // 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点 pNode = pNode.next; &#125; return deleteDuplication(pNode); // 从第一个与当前结点不同的结点开始递归 &#125; else &#123; // 当前结点不是重复结点 pHead.next = deleteDuplication(pHead.next); //保留当前结点，从下一个结点开始递归 return pHead; &#125;&#125; 解法二： 123456789101112131415161718192021public ListNode deleteDuplication(ListNode pHead)&#123; if(pHead == null || pHead.next == null) return pHead; ListNode helper = new ListNode(-1); helper.next = pHead; ListNode prev = helper, curr = pHead, next = pHead.next; while(curr != null &amp;&amp; next != null)&#123; if(next.val != curr.val)&#123; prev = curr; curr = next; next = next.next; &#125;else&#123; while(next != null &amp;&amp; next.val == curr.val) next = next.next; curr = prev.next = next; if(next != null) next = next.next; &#125; &#125; return helper.next;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E18_1删除链表的节点","date":"2018-04-08T09:05:55.000Z","path":"2018/04/08/E18-1删除链表的节点/","text":"题目： 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。 思路： 由于给定的是单向链表，正常删除链表的时间复杂度是查找链表的时间复杂度即O(n),如果要求在O(1)时间复杂度内删除节点，通过遍历链表找到该节点的上一节点和下一节点的方法是行不通了。所以实现的思路是，根据给定的要删除的节点，可以直接找到其后年的节点，把后面的节点的内容复制到当前节点处，同时将当前节点指向其后面节点的后面节点保证链表不断开，再把下一节点删掉就相当于把给定的节点删除了。 需要考虑到的一点是，如果要删除的节点是链表的尾节点的话，那还是需要从头结点按照顺序遍历到尾节点的前一节点，然后删除尾节点，总的平均时间复杂度就是[(n-1)*1+O(n)]/n,结果还是O(1)。 代码实现： BUG：链表只有一个头节点的情况下，该代码无法删除，网上未找到有效代码 123456789101112131415161718public static void deleteNode(ListNode head,ListNode node)&#123; //删除尾节点，采用顺序查找找到尾节点的前一节点 if(node.next==null)&#123; while(head.next!=node)&#123; head=head.next; &#125; head.next=null; &#125; //要删除的节点是头结点 else if(head==node)&#123; head=null; &#125; //要删除的节点是中间普通节点 else&#123; node.data=node.next.data; node.next=node.next.next; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E23链表中环的入口节点(判断链表是否有环)","date":"2018-04-08T07:51:00.000Z","path":"2018/04/08/E23链表中环的入口节点(判断链表是否有环)/","text":"题目一个链表中包含环，请找出该链表的环的入口结点。 思路如果链表中有环，那么先获取环中节点个数n，设置两个指针指向pHead 快指针向前移动n次，然后进行循环，快慢指针同时向后移动，直到指向的节点相同，即环入口节点 获取环中节点个数：设置两个指针：p1和p2。p1一次移动一次，p2一次移动两次 当p2等于p1，说明存在环。返回该节点 通过该节点很容易能获得环中节点个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class 链表中环的入口结点 &#123; //找到一快一慢指针相遇处的节点，相遇的节点一定是在环中 //此方法可用作判断链表是否有环 public static ListNode meetingNode(ListNode head) &#123; if(head == null) return null; ListNode slow = head.next; if(slow == null) return null; ListNode fast = slow.next; while (slow != null &amp;&amp; fast != null) &#123; if(slow == fast)&#123; return fast; &#125; slow=slow.next; fast=fast.next; if(fast!=null)&#123; fast=fast.next; &#125; &#125; return null; &#125; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode meetingNode = meetingNode(pHead); if(meetingNode == null) return null;// 得到环中的节点个数 int nodesInLoop = 1; ListNode p1 = meetingNode; while(p1.next != meetingNode)&#123; p1=p1.next; ++nodesInLoop; &#125;// 移动p1，次数为环中节点数目 p1 = pHead; for(int i = 0;i &lt; nodesInLoop; i++)&#123; p1 = p1.next; &#125;// 再移动p1，p2 ListNode p2 = pHead; while(p1!= p2)&#123; p1 = p1.next; p2 = p2.next; &#125; return p1; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"求链表的中间节点","date":"2018-04-08T07:35:36.000Z","path":"2018/04/08/求链表的中间节点/","text":"题目： 求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数为偶数，返回中间两个结点的任意一个。 思路： 设置两个指针fast和slow，两个指针同时向前走，fast指针每次走两步，slow指针每次走一步，直到fast指针走到最后一个结点时，此时slow指针所指的结点就是中间结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度为O（n）。 1234567891011121314private static ListNode findMid(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head; ListNode fast = head; //每次移动时，让fast结点移动两位，slow结点移动一位 while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; &#125; //直到fast结点移动到null时，此时slow指针指向的位置就是中间结点的位置 return slow;&#125; 注：当n为偶数时，得到的中间结点是第n/2 + 1个结点。比如链表有6个节点时，得到的是第4个节点。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E25合并两个排序的链表","date":"2018-04-08T06:17:53.000Z","path":"2018/04/08/E25合并两个排序的链表/","text":"题目： 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 步骤： Step1.定义一个指向新链表的指针，暂且让它指向NULL； Step2.比较两个链表的头结点，让较小的头结点作为新链表的头结点； Step3.递归比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点； 递归解法： 12345678910111213141516public Node Merge(Node head1, Node head2)&#123; if (head1 == null)&#123; return head2; &#125;else if (head2 == null)&#123; return head1; &#125; Node newHead = null; if (head1.val &lt;= head2.val)&#123; newHead = head1; newHead.next = Merge(head1.next, head2); &#125;else &#123; newHead = head2; newHead.next = Merge(head1, head2.next); &#125; return newHead;&#125; 非递归解法： 12345678910111213141516171819202122232425262728293031323334public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null ) return list1; ListNode tmp1 = list1; ListNode tmp2 = list2; ListNode head = new ListNode(0);//这里不能把返回链表赋值为null，因为下一行马上就要把它赋值给另一链表，得让它在内存里有位置才行 ListNode headptr = head; while(tmp1 != null &amp;&amp; tmp2!=null)&#123; if(tmp1.val &lt;= tmp2.val) &#123; head.next=tmp1; head = head.next; tmp1 = tmp1.next; &#125;else&#123; head.next=tmp2; head = head.next; tmp2=tmp2.next; &#125; &#125; //其中一个链表已经跑到头之后，继续单链表的合并 while(tmp1 != null)&#123; head.next = tmp1; head = head.next; tmp1= tmp1.next; &#125; while(tmp2 != null)&#123; head.next = tmp2; head = head.next; tmp2= tmp2.next; &#125; head = headptr.next; return head;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E24反转链表","date":"2018-04-08T03:39:04.000Z","path":"2018/04/08/E24反转链表/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*定义链表*/class Node &#123; int val; Node next; public Node(int val) &#123; this.val = val; &#125;&#125;public class ReverseList &#123; /* 反转链表*/ public static Node reverseList(Node head) &#123; if (head == null || head.next == null)&#123; return head; &#125; Node reHead = null;// 定义新链表头结点 while (head != null) &#123; Node cur = head.next;// 记录下一个节点 head.next = reHead;// 将rehead节点连接到head节点上 reHead = head;// 让rehead指向head head = cur;// 将head指向下一个节点 &#125; return reHead; &#125; /**递归反转链表 */ public static Node reverseList2(Node head) &#123; if (head == null || head.next == null) return head; Node rehead = reverseList2(head.next); head.next.next = head;// 将头节点置于末端 head.next = null;// 防止链表循环 return rehead; &#125; /**打印链表 */ public static void printList(Node head) &#123; if (head == null) return; while (head != null) &#123; System.out.print(head.val + \" \"); head = head.next; &#125; &#125; public static void main(String[] args) &#123;/*测试*/ Node n1 = new Node(1); Node n2 = new Node(2); Node n3 = new Node(3); Node n4 = new Node(4); Node n5 = new Node(5); n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; // Node rehead = reverseList(n1); Node rehead = reverseList2(n1); printList(rehead); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"从链表中删除重复元素","date":"2018-04-07T15:25:02.000Z","path":"2018/04/07/从链表中删除重复元素/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;public class deleteDuplecate &#123; //法一：优点是时间复杂度低，但是需要额外的存储空间来保存遍历过的值。时间复杂度O(n) public void delete_v1(Node head)&#123; Hashtable&lt;Integer,Integer&gt; table=new Hashtable&lt;Integer,Integer&gt;(); Node temp=head; Node pre=null; //辅助链表的头节点 while(temp!=null)&#123; if(table.containsKey(temp.data)) pre.next=temp.next; else&#123; table.put(temp.data, 1); pre=temp; &#125; temp=temp.next; &#125; &#125; //法二：双重循环遍历链表,优点：不需要额外的存储空间.时间复杂度O(n^2) public void delete_v2(Node head)&#123; Node p=head; while(p!=null)&#123; Node q = p; while(q.next!=null)&#123; if(q.next.data==p.data)&#123; q.next=q.next.next; &#125;else q=q.next; &#125; p=p.next; &#125; &#125; //法三：外循环当前遍历的结点为p，内循环从表头开始遍历至p public void delete_v3(Node head)&#123; Node p=head; while(p!=null)&#123; Node q=head; while(q.next!=p &amp;&amp; q.next!=null)&#123; if(q.next.data==p.data)&#123; q.next=q.next.next; &#125;else q=q.next; &#125; p=p.next; &#125; &#125;&#125;class Node&#123; Node next=null; int data; public Node(int data)&#123; this.data=data; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E22求链表中倒数第k个节点","date":"2018-04-07T15:18:30.000Z","path":"2018/04/07/E22求链表中倒数第k个节点/","text":"为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。 如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。设计如下：依次对链表的每一个结点元素进行这样的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。此种方法将对同一批元素进行反复多次的遍历，对于链表的大部分元素而言，都要遍历k个元素，如果链表长度为n，则该算法时间复杂度为O(kn)级，效率太低。存在另一种更高效的方法。在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置。 12345678910111213141516171819public Node findElem(Node head,int k)&#123; if(k &lt; 1 || head == null)&#123; return null; &#125; Node p1 = head; Node p2 = head; for (int i = 0; i &lt; k - 1; i++) &#123; //前移k-1步 if(p1.next != null)&#123; p1 = p1.next; &#125;else &#123; return null; &#125; &#125; while (p1.next != null) &#123; p1 = p1.next; p2 = p2.next; &#125; return p2;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"链表基本代码实现","date":"2018-04-07T14:40:42.000Z","path":"2018/04/07/链表基本代码实现/","text":"链表节点定义123456789101112public class Node &#123; //为了方便，这两个变量都使用public，而不用private就不需要编写get、set方法了。 //存放数据的变量，简单点，直接为int型 public int data; //存放结点的变量,默认为null public Node next; //构造方法，在构造时就能够给data赋值 public Node(int data)&#123; this.data = data; &#125;&#125; 链表尾部增加节点12345678public void addNode(Node node)&#123; //链表中有结点，遍历到最后一个结点 Node temp = head; //一个移动的指针(把头结点看做一个指向结点的指针) while(temp.next != null)&#123; //遍历单链表，直到遍历到最后一个则跳出循环。 temp = temp.next; //往后移一个结点，指向下一个结点。 &#125; temp.next = node; //temp为最后一个结点或者是头结点，将其next指向新结点&#125; 插入结点到链表的指定位置123456789101112131415161718192021222324252627/** * insertNodeByIndex:在链表的指定位置插入结点。 * 插入操作需要知道1个结点即可，当前位置的前一个结点 * index:插入链表的位置，从1开始 * node:插入的结点 */ public void insertNodeByIndex(int index,Node node)&#123; //首先需要判断指定位置是否合法， if(index&lt;1||index&gt;length()+1)&#123; System.out.println(\"插入位置不合法。\"); return; &#125; int length = 1; //记录我们遍历到第几个结点了，也就是记录位置。 Node temp = head; //可移动的指针 while(temp.next != null)&#123;//遍历单链表 if(index == length++)&#123; //判断是否到达指定位置。 //注意，我们的temp代表的是当前位置的前一个结点。 //前一个结点 当前位置 后一个结点 //temp temp.next temp.next.next //插入操作。 node.next = temp.next; temp.next = node; return; &#125; temp = temp.next; &#125; &#125; 删除指定位置上的结点123456789101112131415161718192021222324/** * 通过index删除指定位置的结点,跟指定位置增加结点是一样的，先找到准确位置。然后进行删除操作。 * 删除操作需要知道1个结点即可：和当前位置的前一个结点。 * @param index：链表中的位置，从1开始 */ public void delNodeByIndex(int index)&#123; //判断index是否合理 if(index&lt;1 || index&gt;length())&#123; System.out.println(\"给定的位置不合理\"); return; &#125; //步骤跟insertNodeByIndex是一样的，只是操作不一样。 int length=1; Node temp = head; while(temp.next != null)&#123; if(index == length++)&#123; //删除操作。 temp.next = temp.next.next; return; &#125; temp = temp.next; &#125; &#125; 单链表进行选择排序12345678910111213141516171819202122232425/** *对链表中的结点进行排序，按照从小到大的顺序，使用选择排序。 *使用双层遍历。第一层遍历，正常遍历链表，第二层遍历，遍历第一层遍历时所用的结点后面所有结点并与之比较 */public void selectSortNode()&#123; //判断链表长度大于2，不然只有一个元素，就不用排序了。 if(length()&lt;2)&#123; System.out.println(\"无需排序\"); return; &#125; //选择排序 Node temp = head; //第一层遍历使用的移动指针，最处指向头结点，第一个结点用temp.next表示 while(temp.next != null)&#123;//第一层遍历链表，从第一个结点开始遍历 Node secondTemp = temp.next; //第二层遍历使用的移动指针，secondTemp指向第一个结点，我们需要用到是第二个结点开始，所以用secondNode.next while(secondTemp.next != null)&#123;//第二层遍历,从第二个结点开始遍历 if( temp.next.data &gt; secondTemp.next.data)&#123;//第二层中的所有结点依次与第一次遍历中选定的结点进行比较 int t = secondTemp.next.data; secondTemp.next.data = temp.next.data; temp.next.data = t; &#125; secondTemp = secondTemp.next; &#125; temp = temp.next; &#125;&#125; 计算单链表的长度12345678910111213/** * 计算单链表的长度，也就是有多少个结点 * @return 结点个数 */ public int length() &#123; int length=0; Node temp = head; while(temp.next != null)&#123; length++; temp = temp.next; &#125; return length; &#125; 遍历单链表，打印data1234567891011/** * 遍历单链表，打印所有data */ public void print()&#123; Node temp = head.next; while(temp != null)&#123; System.out.print(temp.data+\",\"); temp = temp.next; &#125; System.out.println(); &#125;","tags":[{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E06从尾到头打印链表","date":"2018-04-07T14:22:43.000Z","path":"2018/04/07/E06从尾到头打印链表/","text":"很多人第一反应是从头到尾输出将会比较简单，于是自然想到把链表中连接结点的指针反转过来，改变链表的方向即可。但该方法会改变原来链表的结构，是否允许在打印链表的时候修改链表的结构，这点取决于面试官的需求。 通常打印是一个只读操作，我们不希望打印时修改内容。 第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出，这就是典型的“后进先出”！我们用栈来实现这种结构。 既然用栈来实现，而递归本质上就是一个栈的结构，自然也可以用递归来实现。基于递归的代码看起来很简洁，但当链表非常长的时候，就会导致函数调用的层数很深，从而有可能导致函数调用栈溢出。 显然用栈基于循环实现的代码的鲁棒性要好一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Stack;public class PrintListReverse&#123; //非递归的方式，鲁棒性好 public void printListReverse(ListNode headNode)&#123; Stack&lt;ListNode&gt; stack=new Stack&lt;&gt;(); while(headNode!=null) &#123; stack.push(headNode); headNode=headNode.next; &#125; while(!stack.isEmpty()) &#123; System.out.println(stack.pop().val); &#125; &#125; //递归方式，递归在本质上就是一个栈结构 public void printListReverse_recursively(ListNode headNode)&#123; if(headNode!=null) &#123; if(headNode.next!=null) &#123; printListReverse_recursively(headNode.next); &#125; System.out.println(headNode.val); &#125; &#125; public static void main(String[] args) &#123; ListNode node1 = new ListNode(); ListNode node2 = new ListNode(); ListNode node3 = new ListNode(); node1.val=1; node2.val=2; node3.val=3; node1.next = node2; node2.next = node3; PrintListReverse plr = new PrintListReverse(); plr.printListReverse(node1); plr.printListReverse_recursively(node1); &#125;&#125;class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E05-1替换空格","date":"2018-04-07T13:07:41.000Z","path":"2018/04/07/E05-1替换空格/","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解法一：123456789public String replaceSpace(StringBuffer str) &#123; for(int i=0; i &lt; str.length(); i++)&#123; char index = str.charAt(i); if(index == ' ')&#123; str.replace(i, i+1, \"%20\"); &#125; &#125; return str.toString();&#125; 以下是java.lang.StringBuilder.replace()方法的声明 public StringBuilder replace(int start, int end, String str); 参数 start – 这是开始索引(包括)。 end – end 索引(不包括)。 str – 这是字符串，它将取代以前的内容。 解法二：思路：从字符串的后面开始复制和替换，首先准备两个指针，p1和p2，p1指向原始字符串的末尾，p2指向替换后字符串的末尾，接下来，向前移动指针p1，逐个把它指向的字符复制到p2，碰到一个空格之后，把p1向前移动1格，在p2处插入字符串“20%”，由于“20%”长度为3，同时也要把p2向前移动3格。直到p1=p2，表明所有空格都已经替换完毕。 1234567891011121314151617181920212223242526272829303132333435public class ReplaceSpace &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String str=scanner.nextLine(); scanner.close(); char[] charArray = str.toCharArray(); int length=charArray.length; int spaceNumber=0;//获取空格数量 for (char c : charArray) &#123; if(c==' ') &#123; spaceNumber++; &#125; &#125; int newLength=length+spaceNumber*2; char[] tempArray=new char[newLength];//新的数组的长度 //将原来的数组拷贝到新长度的数组中 System.arraycopy(charArray, 0, tempArray, 0, length); int indexofOriginal = length - 1; int indexofNew = newLength - 1; while (indexofOriginal&gt;=0&amp;&amp;indexofOriginal!=indexofNew) &#123; if (tempArray[indexofOriginal]==' ') &#123; tempArray[indexofNew--] = '0'; tempArray[indexofNew--] = '2'; tempArray[indexofNew--] = '%'; &#125;else &#123; tempArray[indexofNew--] = tempArray[indexofOriginal]; &#125; indexofOriginal--; &#125; for (char c : tempArray) &#123; System.out.print(c); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"WSL（Windows下Linux子系统）安装过程","date":"2018-04-06T14:23:52.000Z","path":"2018/04/06/WSL（Windows下Linux子系统）安装过程/","text":"WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，今天初步在自己的笔记本上尝试了一下，也遇到一些问题，现记录如下： 安装步骤如下： 1.控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选适用于Linux的Windows子系统，重启电脑 2.应用商店下搜索wsl，现已支持Ubuntu、openSUSE LEAP 42、SUSE Linux Enterprise、Debian、Kali Linux五个版本，直接安装即可 安装位置为： 1C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc 注：所有系统均只有命令行，没有桌面 3.根据提示设置账户名及密码 4.设置root账户密码 1sudo passwd root 系统安装完成，下面为桌面安装过程 5.在Ubuntu下我们可以通过 apt-get 命令很方便的安装/卸载软件，由于默认的软件包仓库是位于国外的，安装软件的时候就可能遇到各种网络问题或者下载到的一些资源不完整，因此就需要切换数据源为国内的镜像站点来改善 1234# 1.备份原来的数据源配置文件cp /etc/apt/sources.list /etc/apt/sources.list_backup# 2.编辑数据源配置文件vi /etc/apt/sources.list 在这里我使用的是阿里云的数据源： 12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 12# 3.更新配置apt-get update 6.下载软件 可供选择安装的X-Windows有多个：VcXsrv Windows X Server、Xming、Cygwin X Server，本文选择第一个，因为比较容易，而且据说稳定； 软件首页：https://sourceforge.net/projects/vcxsrv/ 下载软件，windows下安装好，启动Launcher，首次启动自动进入界面设置后： 选择：“one large window”，Display number设置成0，其它默认即可： 7.打开Bash，安装ubuntu-desktop, unity, and ccsm（下载桌面及解压花了很久很久） 1sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager 若报错，则改为 1sudo apt-get install ubuntu-desktop unity compiz-core 需要提醒的是，需下载650M，解压后近2.4G ，均安装在C盘 8.配置compiz窗口管理器 启动之前安装的X-Windows，在Bash中执行如下命令： 12export DISPLAY=localhost:0sudo ccsm 9.切换到Ubuntu`Bash窗口，执行以下命令并切换回VcXsrv`窗口查看效果。 1sudo compiz 附加： 安装中文支持并配置profile文件 在桌面环境打开一个终端，执行以下命令安装中文支持 1sudo apt-get -y install language-pack-zh-hans 1sudo vi /etc/profile 将以下环境变量添加到/etc/profile文件 1234export DISPLAY=localhost:0export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN.UTF-8export LC_ALL=zh_CN.UTF-8 重新加载profile 1source /etc/profile 重新生成locale 1locale-gen 卸载子系统 设置&gt;应用&gt;应用和功能，找到Ubuntu卸载即可 安装过程参考自： https://www.jianshu.com/p/bc38ed12da1d https://blog.csdn.net/u011138447/article/details/78262369 https://zhuanlan.zhihu.com/p/34884285/","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"SQL必知必会","date":"2018-04-06T13:24:54.000Z","path":"2018/04/06/SQL必知必会/","text":"一、基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 支持以下三种注释： 12345# 注释SELECT *FROM mytable; -- 注释/* 注释1 注释2 */ 二、创建表123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 三、修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 四、插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容插入到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 五、更新123UPDATE mytableSET col = valWHERE id = 1; 六、删除12DELETE FROM mytableWHERE id = 1; TRUNCATE TABLE 可以清空表，也就是删除所有行。 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 七、查询DISTINCT相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 八、排序 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 九、过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = &lt; &gt; 等于 小于 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为NULL值 应该注意到，NULL 与 0 、空字符串都不同。 AND OR 用于连接多个过滤条件。优先处理 AND，因此当一个过滤表达式涉及到多个 AND 和 OR 时，应当使用 () 来决定优先级。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 十、通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%' -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 十一、计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1*col2 AS aliasFROM mytable CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT CONCAT(TRIM(col1), ' (', TRIM(col2), ')')FROM mytable 十二、函数各个 DBMS 的函数都是不相同的，因此不可移植。 文本处理 函数 说明 LEFT() RIGHT() 左边或者右边的字符 LOWER() UPPER() 转换为小写或者大写 LTRIM() RTIM() 去除左边或者右边的空格 LENGTH() 长度 SUNDEX() 转换为语音值 其中， SOUNDEX() 是将一个字符串转换为描述其语音表示的字母数字模式的算法，它是根据发音而不是字母比较。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 12mysql&gt; SELECT NOW(); -&gt; '2017-06-28 14:01:52' 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 十三、分组分组就是把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能按该字段进行分组，也可以按该字段进行排序，例如按 col 字段排序并分组数据： 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; GROUP BY 是按照分组字段进行排序，ORDER BY 也可以以汇总字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; WHERE 过滤行，HAVING 过滤分组。行过滤应当先与分组过滤； 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING COUNT(*) &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 十四、子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 十五、连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123select a, b, cfrom A inner join Bon A.key = B.key 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123select a, b, cfrom A, Bwhere A.key = B.key 在没有条件语句的情况下返回笛卡尔积。 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456select namefrom employeewhere department = ( select department from employee where name = \"Jim\"); 自连接版本 1234select e2.namefrom employee as e1, employee as e2where e1.department = e2.department and e1.name = \"Jim\"; 连接一般比子查询的效率高。 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12select *from employee natural join department; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123select Customers.cust_id, Orders.order_numfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_id; 如果需要统计顾客的订单数，使用聚集函数。 12345select Customers.cust_id, COUNT(Orders.order_num) as num_ordfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_idgroup by Customers.cust_id; 十六、组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果为 M+N 行。 每个查询必须包含相同的列、表达式或者聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 十七、视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS count_colFROM mytableWHERE col5 = val; 十八、存储过程存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 创建存储过程命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 1234567891011delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 十九、游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 二十、触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。 INSERT 触发器包含一个名为 NEW 的虚拟表。 12CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col; DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 二十一、事务处理基本术语： 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，也就是每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 二十二、字符集基本术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 二十三、权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户1CREATE USER myuser IDENTIFIED BY 'mypassword'; 新创建的账户没有任何权限。 修改账户名1RENAME myuser TO newuser; 删除账户1DROP USER myuser; 查看权限1SHOW GRANTS FOR myuser; 授予权限1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 删除权限1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('newpassword'); 参考资料 BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"Java的序列化","date":"2018-04-06T12:39:33.000Z","path":"2018/04/06/Java的序列化/","text":"定义Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。 为什么需要序列化？第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。 第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。 如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？答：如果父类有默认构造函数的话，即使没有实现Serializable接口也不会有问题，反序列化的时候会调用默认构造函数进行初始化，否则的话反序列化的时候会抛出.InvalidClassException:异常，异常原因为no validconstructor。 实现序列化方法 实现Serializable接口 1.该接口只是一个可序列化的标志，并没有包含实际的属性和方法。 2.如果不在改方法中添加readObject()和writeObject()方法，则采取默认的序列化机制。如果添加了这两个方法之后还想利用Java默认的序列化机制，则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()两个方法。 3.为了保证安全性，可以使用transient关键字进行修饰不必序列化的属性。因为在反序列化时，private修饰的属性也能发查看到。 实现ExternalSerializable方法 自己对要序列化的内容进行控制，控制哪些属性能被序列化，哪些不能被序列化。 反序列化 实现Serializable接口的对象在反序列化时不需要调用对象所在类的构造方法，完全基于字节。 实现externalSerializable接口的方法在反序列化时会调用构造方法。 注意事项 被static修饰的属性不会被序列化 对象的类名、属性都会被序列化，方法不会被序列化 要保证序列化对象所在类的属性也是可以被序列化的 当通过网络、文件进行序列化时，必须按照写入的顺序读取对象。 反序列化时必须有序列化对象时的class文件 最好显示的声明serializableID，因为在不同的JVM之间，默认生成serializableID 可能不同，会造成反序列化失败。 常见的序列化协议有哪些 COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大。 CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。 XML&amp;SOAP XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。 JSON（JavascriptObject Notation） 这种Associativearray格式非常符合工程师对对象的理解。它保持了XML的人眼可读（Human-readable）的优点。相对于XML而言，序列化后的数据更加简洁。它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。 与XML相比，其协议比较简单，解析速度比较快。松散的Associativearray使得其具有良好的可扩展性和兼容性。 Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用 Protobuf具备了优秀的序列化协议的所需的众多典型特征标准的IDL和IDL编译器，这使得其对工程师非常友好。序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。解析速度非常快，比对应的XML快约20-100倍。提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景 Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于ApacheHadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。适合于高性能的序列化服务。 几种协议的对比 XML序列化（Xstream）无论在性能和简洁性上比较差； Thrift与Protobuf相比在时空开销方面都有一定的劣势； Protobuf和Avro在两方面表现都非常优越。 本文转载自：http://www.importnew.com/17964.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"死锁","date":"2018-04-06T10:01:38.000Z","path":"2018/04/06/死锁/","text":"死锁定义是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 活锁活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 产生条件互斥条件：一个资源一次只能被一个进程使用请求保持条件：一个进程因请求资源而阻塞时，对已经获得资源保持不放不可抢占条件：进程已获得的资源在未使用完之前不能强行剥夺循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系 检测方法两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测: 1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来 2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求 如果第二步返回真,表示出现了死锁 如何避免死锁在有些情况下死锁是可以避免的。三种用于避免死锁的技术： 加锁顺序（线程按照一定的顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 死锁检测 那么当检测出死锁时，这些线程该做些什么呢？ 给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。 银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。 死锁的解除一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。 死锁解除的主要方法有： 1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。 死锁检测与死锁恢复死锁检测算法 死锁检测的基本思想是，如果一个进程所请求的资源能够被满足，那么就让它执行，否则释放它拥有的所有资源，然后让其它能满足条件的进程执行。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"线程和进程的区别","date":"2018-04-05T14:27:48.000Z","path":"2018/04/05/线程和进程的区别/","text":"引入进程之前–多道程序设计概述多道程序设计技术是操作系统最早引入的技术，它的设计思想是允多个程序同时进入内存并运行，其目的是为了CPU的利用率，进而提高系统效率。 特点多道程序设计技术引入之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。而多道程序设计技术允许多个程序同时进入内存并运行，那就要每个程序分配程序计数器。如果内存中有四个程序在并发执行，那就需要四个程序计数器。 新技术带来的问题一个技术、一个机制的引入，一方面解决了以前棘手的问题，但同时，往往带来新的问题。多道程序设计技术也是如此。 多道程序设计技术允许多个程序同时进入内存并运行，在这样的并发环境下，如何描述、刻画这样执行的程序呢？因此引入了“进程”。 进程（Process）定义进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。 特点 进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。 进程是是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象。（虚拟技术的支持，将一个CPU变幻为多个虚拟的CPU） 系统资源（如内存、文件）以进程为单位分配。 操作系统为每个进程分配了独立的地址空间 操作系统通过“调度”把控制权交给进程。 为什么引入线程 有了进程这概念之后 应用程序可以并发地去执行了 那么为什么要在进程当中再派生出线程呢？ 为什么引入线程？首先我们引入了进程这个概念，虽然进程有利于资源的管理和保护。然而在实际应用中，进程有这样的问题： 进程切换的代价、开销比较大； 在一个进程内也需要并行执行多个程序，实现不同的功能。 进程有时候性能比较低。 引入线程有以下三个方面的考虑 应用的需要。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。 开销的考虑。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件） 性能的考虑。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。 线程(Thread)定义线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 属性 有标识符ID 有状态及状态转换，所以需要提供一些状态转换操作 不运行时需要保存上下文环境，所以需要程序计数器等寄存器 有自己的栈和栈指针 共享所在进程的地址空间和其它资源 进程与线程区别1.定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程） 2.角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位。 ​ 总线程数&lt;= CPU数量：并行运行 ​ 总线程数&gt; CPU数量：并发运行 3.资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。 4.独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。 5.开销方面。进程切换的开销较大。线程相对较小。（前面也提到过，引入线程也出于了开销的考虑。） 线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 Read moreProcess Vs Thread Difference between Process and Thread what is different between thread and process 理解Android进程创建流程（转） 本文转载整理自： http://blog.csdn.net/zheng548/article/details/54669908 https://blog.csdn.net/robbyo/article/details/8549904","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"Java后端技术","date":"2018-04-05T13:57:36.000Z","path":"2018/04/05/Java后端技术/","text":"后端主要的技术： 服务框架：Dubbo，zookeeper，Rest服务缓存：redis，ehcache消息中间件：ActiveMQ，kafka负责均衡：Nginx分布式文件：FastDFS安全框架：Apache shiro任务调度：quartz持久层框架：mybatis日志：log4j项目基础搭建。spring，springmvc环境搭建：linux下开发工具：eclipse，idea等服务器：tomcat，jetty等 目前系统主流搭建：Nginx+tomcat+mybatis+redis。针对不同的业务需求，我们会引用不同的技术。 这些主要定位于互联网企业架构 框架简介： 企业信息化系统基础功能和高效的代码生成工具，包括: 系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、 平台简介： 是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。 本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。 使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。 以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。 前端集成bootstrap 框架。响应式 目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务） 提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。 内置功能(只列了一部分功能) 1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。 2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。 3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。 4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。 5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。 6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。 7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。 8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。 9.工作流引擎：实现业务工单流转、在线流程设计器。 开发工具 1.Eclipse IDE：采用Maven项目管理，模块化。 2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。 技术选型（只列了一部分技术） 1、后端 服务框架：Dubbo、zookeeper、Rest服务 缓存：Redis、ehcache 消息中间件：ActiveMQ 负载均衡：Nginx 分布式文件：FastDFS 数据库连接池：Alibaba Druid 1.0 核心框架：Spring framework 安全框架：Apache Shiro 1.2 视图框架：Spring MVC 4.0 服务端验证：Hibernate Validator 5.1 布局框架：SiteMesh 2.4 工作流引擎：Activiti 5.15 任务调度：quartz 1.8.5 持久层框架：MyBatis 3.2 日志管理：SLF4J 1.7、Log4j 工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI 2、前端 JS框架：JQuery 1.9。 CSS框架： Bootstrap 4 metronic 客户端验证：JQuery Validation Plugin。 富文本：CKEcitor 文件管理：CKFinder 动态页签：Jerichotab 数据表格：jqGrid 对话框：jQuery jBox 树结构控件：jQuery zTree 其他组件：Bootstrap 4 metronic 3、支持 服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8 数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等 支持开发环境：Eclipse、MyEclipse、Ras、Idea等。 本文转载自网络","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"字符和字节的区别","date":"2018-04-05T13:42:35.000Z","path":"2018/04/05/字符和字节的区别/","text":"“字节”的定义字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。 “字符”的定义字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。 “字节”与“字符”它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同： ①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。 ②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 ③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。 ④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。 ⑤UTF-32编码中，世界上任何字符的存储都需要4个字节 ⑥通常在读取非文本文件时（如图片，声音，可执行文件）需要用字节数组来保存文件的内容，在下载文件时，也是用byte数组作临时的缓冲器接收文件内容。所以说byte在文件操作时是必不可少的。不管是对文件写入还是读取都要用到。byte在java中是一种是数据类型，代表一个字节，一个字节包含8个位，所以，byte类型的取值范围是-128到127。在某些程序中（尤其是和硬件有关的程序）会将某些数据存储到字节类型的变量中，比如00110010,其中每个位都代表一个参数，然后以位运算的方式对参数进行取值和赋值操作。 机器只知道字节，而字符却是语义上的单位，它是有编码的，一个字符可能编码成1个2个甚至3个4个字节。这跟字符集编码有关系，英文字母和数字是单字节，但汉字这些自然语言中的字符是多字节的。一个字节只能表示255个字符，不可能用于全球那么多种自然语言的处理，因此肯定需要多字节的存储方式。而InputStream, OutputStream它们是处理字节流的，就是说假设所有东西都是二进制的字节，而 Reader, Writer 则是字符流，它涉及到字符集的问题；按照ANSI编码标准，标点符号、数字、大小写字母都占一个字节，汉字占2个字节。按照UNICODE标准所有字符都占2个字节。 本文整理转载自网络 ​","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java中基本类型的取值范围","date":"2018-04-05T13:03:09.000Z","path":"2018/04/05/Java中基本类型的取值范围/","text":"类型 占内存大小 取值范围 数值范围 默认值 byte 1个字节 (8bit) -27~27-1 -128~127 0 short 2个字节 (16bit) -215~215-1 -32768~32767 0 int 4个字节 (32bit) -231~231-1 -2147483648~2147483647 0 long 8个字节 (64bit) -263~263-1 -9223372036854774808~9223372036854774807 0 boolean 1个字节 (8bit) ture，false false char 2个字节 (16bit) 0~216-1 ‘\\u0000’ float 4个字节 (32bit) 2-149~2128-1 1.4013E-45~3.4028E+38 0.0F double 8个字节 (64bit) 2-1074~21024-1 4.9E-324~1.7977E+308 0.0D int包装类为：java.lang.Integer。其余类型类似，均为类型大写首字母","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"悲观锁与乐观锁","date":"2018-04-04T13:34:13.000Z","path":"2018/04/04/悲观锁与乐观锁/","text":"定义1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。 2.乐观锁：即很乐观，查询数据的时候总觉得不会有人更改数据，等到更新的时候再判断这个数据有没有被人更改，有人更改了则本次更新失败。 实现过程悲观锁：悲观锁的实现采用的数据库内部的锁机制，一个典型的倚赖数据库的悲观锁调用： 1select * from account where name=\"张三\" for update; 这条sql 语句锁定了account 表中所有符合检索条件（name=”张三”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。也就是我们可以在查询数据的时候先用for update把这条数据锁住，然后更改完这条数据再提交。这样别的线程没法更新这条数据，也就保证了不会丢失更新。 悲观锁带来的性能问题。我们试想一个场景：如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果？所以我们这个时候可以使用乐观锁。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁：乐观锁的实现可以通过在表里面加一个版本号的形式，每个人更新的时候都会判断当前的版本号是否跟我查询出来得到的版本号是否一致，不一致就更新失败，一致就更新这条记录并更改版本号。 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 使用场景像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"synchronized与Lock的区别","date":"2018-04-04T13:07:54.000Z","path":"2018/04/04/synchronized与Lock的区别/","text":"类别 synchronized Lock 存在层次 Java的关键字，在jvm层面上 是一个类 锁的释放 1、已获取锁的线程执行完同步代码会释放锁 2、线程执行发生异常，jvm会让线程释放锁 需在finally中手工释放锁（unlock()方法释放锁），不然容易造成线程死锁 锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，如果尝试获取不到锁，线程可以不用一直等待 锁状态 无法判断是否获取到锁 可以判断是否获取到锁 锁类型 可重入 不可中断 非公平 可重入 可中断 可公平（两者皆可） 性能 适合代码少量的同步问题 适合代码大量的同步问题 synchronized与lock的区别 （用法）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 （用法）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。 （性能）synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。 （机制）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compareand Swap）。 synchronized如何使用 synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 1). 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 2). 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 3). 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 4). 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 两种锁的底层实现方式： synchronized： 我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。 其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。 那有两个monitorexit呀？synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。 Lock： Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。 尽可能去使用synchronized而不要去使用LOCK synchronized与static synchronized的区别 synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized块，同一个类的两个不同实例就没有这种约束了。 那么static synchronized恰好就是要控制类的所有实例的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。 CAS（Compareand Swap）原理：CAS有三个操作数，即内存值v,旧的预期值a,新的操作数b。当我们需要更新v值为b时，首先我们判断v值是否和我们之前的所见值a相同，若相同则将v赋值为b，若不同，则什么都不做。是一种非阻塞算法（non-blocking algorithm）。 非阻塞算法（nonblocking algorithms）:一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"List接口的实现类--ArrayList、LinkedList、Vector之间的区别","date":"2018-04-04T11:54:20.000Z","path":"2018/04/04/List接口的实现类-ArrayList、LinkedList、Vector之间的区别/","text":"概述Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└Set ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长。 ArrayList不是线程安全的，只能用在单线程环境下。 允许元素为null 实现了Serializable接口，因此它支持序列化，能够通过序列化传输； 实现了RandomAccess接口，支持快速随机访问，可以以O(1)的时间复杂度去根据下标访问元素，实际上就是通过下标序号进行快速访问； 实现了Cloneable接口，能被克隆。 因其底层数据结构是数组，它占据了一块连续的内存空间（容量就是数组的length），所以它也有数组的缺点，空间效率不高。 由于数组的内存连续，可以根据下标以O(1)的时间读写(改查)元素，因此时间效率很高。 初始化 首先有三种方式来初始化： 1public ArrayList(); 默认的构造器，将会以默认的大小来初始化内部的数组 1public ArrayList(Collection&lt;? extends E&gt; c) 用一个ICollection对象来构造，并将该集合的元素添加到ArrayList 1public ArrayList(int initialCapacity) ArrayList的扩容机制使用无参构造方法时系统会默认提供默认参数10，而使用有参构造函数时我们会指定大小。在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组（通常为原数组的1.5倍）（当第一次插入元素时分配10个对象空间。假如有20个数据需要添加，那么会分别在第一次的时候，将ArrayList的容量变为10；之后扩容会按照1.5倍增长。也就是当添加第11个数据的时候，Arraylist继续扩容变为10 1.5=15，当添加第16个数据时，继续扩容变为15 1.5 =22个），旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组指向了新的数组。 扩容操作也是ArrayList 的一个性能消耗比较大的地方，所以若我们可以提前预知数据的规模，应该通过public ArrayList(int initialCapacity) {}构造方法，指定集合的大小，去构建ArrayList实例，以减少扩容次数，提高效率。 或者在需要扩容的时候，手动调用public void ensureCapacity(intminCapacity) {}方法扩容。 不过该方法是ArrayList的API，不是List接口里的，所以使用时需要强转: ((ArrayList)list).ensureCapacity(30); ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）1.List是接口类，ArrayList和LinkedList是List的实现类。 2.ArrayList是动态数组（顺序表）的数据结构。顺序表的存储地址是连续的，所以在查找比较快，但是在插入和删除时，由于需要把其它的元素顺序向后移动（或向前移动），所以比较耗时。 3.LinkedList是链表的数据结构。链表的存储地址是不连续的，每个存储地址通过指针指向，在查找时需要进行通过指针遍历元素，所以在查找时比较慢。由于链表插入时不需移动其它元素，所以在插入和删除时比较快。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。 ArrayList和LinkedList的时间复杂度ArrayList 是线性表（数组） get()：直接读取第几个下标，复杂度 O(1) add(E) ：添加元素，直接在后面添加，复杂度O（1） add(index, E) ：添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n） remove（）：删除元素，后面的元素需要逐个移动，复杂度O（n） LinkedList 是链表的操作 get()：获取第几个元素，依次遍历，复杂度O(n) add(E) ：添加到末尾，复杂度O(1) add(index, E) ：添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n) remove（）：删除元素，直接指针指向操作，复杂度O(1) 如何复制某个ArrayList到另一个ArrayList中去？1.使用clone()方法，比如ArrayList newArray = oldArray.clone(); 2.使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject); 3.使用Collections的copy方法。 注意1和2是浅拷贝(shallowcopy)。 ArrayList为什么是线程不安全的？ArrayList在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 用Collections.synchronizedList可以把一个普通ArrayList包装成一个线程安全版本的数组容器，原理同Vector是一样的，就是给所有的方法套上一层synchronized。 ArrayList和Vector的区别？ArrayList和Vector都实现了list接口，都是数组实现； 区别在于Vector在API上都加了synchronized所以它是线程安全的，以及Vector扩容时，是扩容100%，而ArrayList是扩容50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。 stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java代码执行顺序","date":"2018-04-04T08:41:44.000Z","path":"2018/04/04/Java代码执行顺序/","text":"实例： 123456789101112131415161718192021222324252627282930313233343536373839class Person&#123; static &#123; System.out.println(\"执行Person静态代码块\"); &#125; &#123; System.out.println(\"执行Person构造代码块\"); &#125; public Person()&#123; System.out.println(\"执行Person无参构造方法\"); &#125; public Person(String name)&#123; System.out.println(\"执行Person构造方法\"+ name); &#125;&#125;class Student extends Person&#123; static &#123; System.out.println(\"执行Student静态代码块\"); &#125; &#123; System.out.println(\"执行Student构造代码块\"); &#125; public Student(String name)&#123; super(name); System.out.println(\"执行Student构造方法\" + name); &#125; public Student()&#123; super(); System.out.println(\"执行Student无参构造方法\"); &#125;&#125;public class ExtendsStaticConstruct &#123; public static void main(String args[])&#123; Student student1 = new Student(\"ABC\"); System.out.println(\"--------------------\"); Student student2 = new Student(); &#125;&#125; 执行结果： 1234567891011执行Person静态代码块执行Student静态代码块执行Person构造代码块执行Person构造方法ABC执行Student构造代码块执行Student构造方法ABC--------------------执行Person构造代码块执行Person无参构造方法执行Student构造代码块执行Student无参构造方法 说明：一般的类里面包含：1、静态代码块（静态区、静态变量等）2、构造代码块（{ }中间的内容）3、构造方法 其执行顺序也是1、2、3先后执行，这里需要注意的是：考虑继承特性。子类与父类的执行顺序是：1、先执行父类的静态代码块（父1）2、子类的静态代码块（子1）3、父类构造代码块（父2）4、父类构造方法（父3）5、子类构造代码块（子2）6、子类构造方法（子3） 当一个类从被JVM装载开始，各种代码的执行顺序大致如下： 被JVM装载-&gt;执行父类的相关代码-&gt;如果有静态初始化，先执行静态初始化，且只执行一次，以后即使有该类实例化，也不会再执行-&gt;如果有静态代码块，以与静态初始化一样的方式执行-&gt;如果有new语句带来的实例化，先为成员变量分配空间，并绑定参数列表，隐式或显式执行super()，即父类的构造方法-&gt;执行非静态代码块-&gt;执行本类的构造函数-&gt;执行其他代码。 这里的执行顺序同子类构造中有一个默认的父类构造super()无关，不是执行到隐藏的super()才开始初始化父类的，类的初始化是分层初始化，即先初始化父类，再初始化子类，初始化每个类的过程中，进行类的初始化工作，先进性成员变量的初始化，成员变量的初始化顺序是：默认初始化，即int为0这种－&gt;显示初始化，例如给int型显示初始化了值－&gt;构造方法初始化，所以是这里执行到了构造方法。 但是一定要注意，父类初始化选择的构造方法却和子类中super 选择的构造相关。 转载自：https://blog.csdn.net/wuhaiwei002/article/details/55226155","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"HashTable、HashMap和ConCurrentHashMap区别","date":"2018-04-04T08:19:04.000Z","path":"2018/04/04/HashTable、HashMap和ConCurrentHashMap区别/","text":"Map├Hashtable├HashMap└WeakHashMap HashMap和HashTable的对比 1.HashMap是非线程安全的，HashTable是线程安全的。 Hashtable中的线程安全是Synchronize的（sychronized意味着在一次仅有一个线程能够更改Hashtable，就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable）；而HashMap中的方法在缺省情况下是非Synchronize的。所以在单线程环境下Hashtable比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理： Map m =Collections.synchronizedMap(new HashMap(…))。 2.HashMap的键和值都允许有null存在，而HashTable则都不行。 3.因为线程安全、哈希效率的问题，HashMap效率比HashTable的要高。 4.哈希值的使用不同 HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 5.内部实现使用的数组初始化和扩容方式不同 HashMap默认初始化数组的大小为16，要求底层数组的容量一定要为2的整数次幂，HashTable为11。HashMap扩容时乘2，使用位运算取得哈希，效率高于取模。而HashTable为乘2加1，都是素数和奇数，这样取模哈希结果更均匀。 6.继承的父类不同 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 7.两个遍历方式的内部实现上不同 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。 8.是否提供contains方法 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。 Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 HashTable和ConCurrentHashMap的对比ConcurrentHashMap引入了分割(Segment)，把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。 HashMap和ConCurrentHashMap的对比（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。 （2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。 Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？ HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读。get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。 Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"排序算法","date":"2018-04-03T13:18:20.000Z","path":"2018/04/03/排序算法/","text":"综述内排序有可以分为以下几类： (1)、插入排序：直接插入排序、二分法插入排序、希尔排序。(2)、选择排序：简单选择排序、堆排序。(3)、交换排序：冒泡排序、快速排序。(4)、归并排序(5)、基数排序 排序方法 平均情况 最好情况 最坏情况 空间复杂度 稳定性 插入排序 O(n2) O(n) O(n2) O(1) 稳定 shell排序 O(n1.3) O(n) O(n2) O(1) 不稳定 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 基数排序 O(d(r+n)) O(d(r+rd)) O(d(r+n)) O(rd+n) 稳定 注：基数排序 r表示关键字的基数 d代表长度 n代表关键字的个数 - O（n2）排序冒泡排序基本思想：比较数组相邻的两个值，把大的像泡泡一样“冒”到数组后面去，一共要执行N的平方除以2这么多次的比较和交换的操作（N为数组元素），其复杂度为Ο(n²)。 1234567891011public static void bubbleSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123;//外层循环控制排序趟数 for(int j=0;j&lt;arr.length-1-i;j++)&#123;//内层循环控制每一趟排序多少次 if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;&#125; 选择排序123456789101112131415161718public static void selectsort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; for(int i=0;i&lt;arr.length;i++)&#123; int index = i;//初始下标为i for(int j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[index])&#123; index = j; &#125; &#125; if(index != i)&#123; int temp = arr[index]; arr[index] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 插入排序基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 1234567891011public static void insertSort(int[] a) &#123; for(int i = 1; i &lt; a.length; i++) &#123;// 从数组的第二个元素开始循环将数组中的元素插入 int temp = a[i];// 设置数组中的第2个元素为第一次循环要插入的数据 int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; a[j]) &#123; a[j + 1] = a[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动 j--; &#125; a[j + 1] = temp;// 直到要插入的元素不小于第j个元素,将temp插入到数组中 &#125;&#125; shell排序基本思想：本质是插入排序，通过将数组数组的方式来将增加排序的速度，分组的方式第一次将数组的长度/2,第二次/4,当结果等于1的时候，那么将这个数组进行插入排序就完成了排序，当然分组时也是需要排序的。 123456789101112131415public static void shellSort(int[] a) &#123; // 将数组分组 for (int temp = a.length / 2; temp &gt;= 1; temp /= 2) &#123; // 这里的思路和插入排序的思路相同，通过找到前一个的数大于或者小于来进行插入 for(int i = temp; i &lt; a.length; i += temp) &#123; int temp = a[i]; int j = i - temp; while(j &gt;= 0 &amp;&amp; temp &lt; a[j]) &#123; a[j + temp] = a[j]; j -= temp; &#125; a[j + temp] = temp; &#125; &#125; &#125; O（nlog2n）排序快速排序12345678910111213141516171819public static void quickSort(int[] arr,int low,int high)&#123; if(low &gt; high)&#123; return ; &#125; int i = low, j = high,temp = arr[low]; while(i &lt; j)&#123; while( arr[j] &gt;= temp &amp;&amp; i &lt; j)&#123; j--; &#125; arr[i] = arr[j]; while(arr[i] &lt;= temp &amp;&amp; i &lt; j)&#123; i++; &#125; arr[j] = arr[i]; &#125; arr[j] = temp; quickSort(arr,low,j-1); quickSort(arr,j+1,high);&#125; 归并排序（1）稳定性：归并排序是一种稳定的排序。（2）存储结构要求：可用顺序存储结构。也易于在链表上实现。（3）时间复杂度：对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。（4）空间复杂度：需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。 注意：若用单链表做存储结构，很容易给出就地的归并排序 12345678910111213141516171819202122232425262728293031323334353637public static int[] sort(int[] a,int low,int high)&#123; int mid = (low+high)/2; if(low&lt;high)&#123; sort(a,low,mid); sort(a,mid+1,high); //左右归并 merge(a,low,mid,high); &#125; return a; &#125; public static void merge(int[] a, int low, int mid, int high) &#123; int[] temp = new int[high-low+1]; int i= low; int j = mid+1; int k=0; // 把较小的数先移到新数组中 while(i&lt;=mid &amp;&amp; j&lt;=high)&#123; if(a[i]&lt;a[j])&#123; temp[k++] = a[i++]; &#125;else&#123; temp[k++] = a[j++]; &#125; &#125; // 把左边剩余的数移入数组 while(i&lt;=mid)&#123; temp[k++] = a[i++]; &#125; // 把右边边剩余的数移入数组 while(j&lt;=high)&#123; temp[k++] = a[j++]; &#125; // 把新数组中的数覆盖nums数组 for(int x=0;x&lt;temp.length;x++)&#123; a[x+low] = temp[x]; &#125; &#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; int[] a=&#123;49,38,65,97,76,13,27,49,78,34,12,64&#125;; int arrayLength=a.length; //循环建堆 for(int i=0;i&lt;arrayLength-1;i++)&#123; //建堆 buildMaxHeap(a,arrayLength-1-i); //交换堆顶和最后一个元素 swap(a,0,arrayLength-1-i); System.out.println(Arrays.toString(a)); &#125; &#125; //对data数组从0到lastIndex建大顶堆 public static void buildMaxHeap(int[] data, int lastIndex)&#123; //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125; //交换 private static void swap(int[] data, int i, int j) &#123; int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125;&#125; 基数排序123456789101112131415161718192021222324252627282930import java.util.*;public class RadixSort &#123; // 各位装通法 public int[] radixSort(int[] A, int n) &#123; int length = n; int divisor = 1;// 定义每一轮的除数，1,10,100... //定义了10个桶，以防每一位都一样全部放入一个桶中 int[][] bucket = new int[10][length]; int[] count = new int[10];// 统计每个桶中实际存放的元素个数 int digit;// 获取元素中对应位上的数字，即装入那个桶 for (int i = 1; i &lt;= 3; i++) &#123;// 经过4次装通操作，排序完成 for (int temp : A) &#123;// 计算入桶 digit = (temp / divisor) % 10; bucket[digit][count[digit]++] = temp; &#125; int k = 0;// 被排序数组的下标 for (int b = 0; b &lt; 10; b++) &#123;// 从0到9号桶按照顺序取出 if (count[b] == 0)// 如果这个桶中没有元素放入，那么跳过 continue; for (int w = 0; w &lt; count[b]; w++) &#123; A[k++] = bucket[b][w]; &#125; count[b] = 0;// 桶中的元素已经全部取出，计数器归零 &#125; divisor *= 10; &#125; return A; &#125;&#125; 总结1.若n较小(如n≤50)，可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。*2.若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；3.若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。4.快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；5.堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。6.若要求排序稳定，则可选用归并排序。 7.若是身高、年龄，可使用计数排序。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"HashMap的工作原理","date":"2018-04-03T10:28:28.000Z","path":"2018/04/03/HashMap的工作原理/","text":"“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。 “如果两个键的hashcode相同，你如何获取值对象？”面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 “如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 散列表的hash算法是根据移位来进行计算的，只能是进行＊2或者／2。因此，扩容的大小要符合这个标准，否则会造成没必要的浪费甚至错误。扩容的成本并不低，因为需要遍历一个时间复杂度为O(n)的数组，并且为其中的每个enrty进行hash计算。加入到新数组中，所以最好的情况是能够合理的使用HashMap的构造方法创建合适大小的HashMap，使得在不浪费内存的情况下，尽量减少扩容，这个就要根据业务来决定了。 “你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(racecondition)。 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ 热心的读者贡献了更多的关于HashMap的问题： 为什么String,Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。 我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点： hashing的概念 HashMap中解决碰撞的方法 equals()和hashCode()的应用，以及它们在HashMap中的重要性 不可变对象的好处 HashMap多线程的条件竞争 重新调整HashMap的大小 总结1. 什么时候会使用HashMap？它有什么特点？ 是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2.HashMap的工作原理 HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将Key传给get()方法，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap在每个链表节点中储存键值对对象。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？HashMap中解决碰撞的方法 通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法计算index，把节点再放到新的bucket中。 6.当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。 转载自：http://www.importnew.com/10620.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Hello,My Blog","date":"2018-04-02T13:17:30.000Z","path":"2018/04/02/Hello-My-Blog/","text":"纵有疾风起，人生不言弃 花了一天半的时间终于开通了自己的博客。参照网上教程从下载Node.js、Hexo到下载博客模板、调试、配置成自己想要的样子，以及学这个Markdown语法，中间也遇到了一些小小的Bug，有些百度出来了，有的自己解决了，有的还没解决就只能小小的掩盖一下，以后慢慢学习，不断进步，慢慢解决吧。 虽然是借用了Hexo的模板，并挂在Github上的免费博客，但还是希望自己以后能坚持写下去，能将学习过程中的点点滴滴都能记录下来！纵有疾风起，人生不言弃！","tags":[]},{"title":"Hello World","date":"2018-04-01T15:50:22.104Z","path":"2018/04/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]