[{"title":"栈","date":"2018-04-08T12:34:18.000Z","path":"2018/04/08/栈/","text":"定义： 栈是一种只能在一端进行插入或删除操作的线性表。（先进后出表） java中的Stack继承Vector 实例化 1Stack stack = new Stack(); 基本使用 判断是否为空 1stack.empty() 取栈顶值（不出栈） 1stack.peek() 进栈 1stack.push(Object); 出栈 1stack.pop(); 示例： 12345678910111213141516public class StackTest &#123; public static void main(String[] args) &#123; Stack stack=new Stack(); //1.empty()栈是否为空 System.out.println(stack.empty()); //2.peek()栈顶值 //3.进栈push() stack.push(new Integer(1)); stack.push(\"b\"); System.out.println(stack.peek()); //4.pop()出栈 stack.pop(); System.out.println(stack.peek()); System.out.println(stack.empty()); &#125;&#125; 运行结果： 1234trueb1false","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"栈","slug":"栈","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/栈/"}]},{"title":"E52两个链表的第一个公共节点","date":"2018-04-08T11:47:10.000Z","path":"2018/04/08/E52两个链表的第一个公共节点/","text":"思路： 首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。 123456789101112131415161718192021222324252627282930313233public static ListNode findFirstCommonNode(ListNode head1, ListNode head2) &#123; int len1 = getListLength(head1); int len2 = getListLength(head2); ListNode longListNode = head1; ListNode shortListNode = head2; int dif = len1 - len2; if (len2 &gt; len1) &#123; longListNode = head2; shortListNode = head1; dif = len2 - len1; &#125; for (int i = 0; i &lt; dif; i++) &#123; longListNode = longListNode.nextNode; &#125; while (longListNode != null &amp;&amp; shortListNode != null &amp;&amp; longListNode != shortListNode) &#123; longListNode = longListNode.nextNode; shortListNode = shortListNode.nextNode; &#125; return longListNode;&#125;private static int getListLength(ListNode head1) &#123; int result = 0; if (head1 == null) return result; ListNode point = head1; while (point != null) &#123; point = point.nextNode; result++; &#125; return result;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E18_2删除链表中重复的节点","date":"2018-04-08T11:20:15.000Z","path":"2018/04/08/E18-2删除链表中重复的节点/","text":"题目： 在一个排序的链表中，如何删除重复的节点？ 样例输入： 1 2 3 3 4 4 5 样例输出： 1 2 5 解法一： 12345678910111213141516public static ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; // 只有0个或1个结点，则返回 return pHead; &#125; if (pHead.val == pHead.next.val) &#123; // 当前结点是重复结点 ListNode pNode = pHead.next; while (pNode != null &amp;&amp; pNode.val == pHead.val) &#123; // 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点 pNode = pNode.next; &#125; return deleteDuplication(pNode); // 从第一个与当前结点不同的结点开始递归 &#125; else &#123; // 当前结点不是重复结点 pHead.next = deleteDuplication(pHead.next); //保留当前结点，从下一个结点开始递归 return pHead; &#125;&#125; 解法二： 123456789101112131415161718192021public ListNode deleteDuplication(ListNode pHead)&#123; if(pHead == null || pHead.next == null) return pHead; ListNode helper = new ListNode(-1); helper.next = pHead; ListNode prev = helper, curr = pHead, next = pHead.next; while(curr != null &amp;&amp; next != null)&#123; if(next.val != curr.val)&#123; prev = curr; curr = next; next = next.next; &#125;else&#123; while(next != null &amp;&amp; next.val == curr.val) next = next.next; curr = prev.next = next; if(next != null) next = next.next; &#125; &#125; return helper.next;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E18_1删除链表的节点","date":"2018-04-08T09:05:55.000Z","path":"2018/04/08/E18-1删除链表的节点/","text":"题目： 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。 思路： 由于给定的是单向链表，正常删除链表的时间复杂度是查找链表的时间复杂度即O(n),如果要求在O(1)时间复杂度内删除节点，通过遍历链表找到该节点的上一节点和下一节点的方法是行不通了。所以实现的思路是，根据给定的要删除的节点，可以直接找到其后年的节点，把后面的节点的内容复制到当前节点处，同时将当前节点指向其后面节点的后面节点保证链表不断开，再把下一节点删掉就相当于把给定的节点删除了。 需要考虑到的一点是，如果要删除的节点是链表的尾节点的话，那还是需要从头结点按照顺序遍历到尾节点的前一节点，然后删除尾节点，总的平均时间复杂度就是[(n-1)*1+O(n)]/n,结果还是O(1)。 代码实现： BUG：链表只有一个头节点的情况下，该代码无法删除，网上未找到有效代码 123456789101112131415161718public static void deleteNode(ListNode head,ListNode node)&#123; //删除尾节点，采用顺序查找找到尾节点的前一节点 if(node.next==null)&#123; while(head.next!=node)&#123; head=head.next; &#125; head.next=null; &#125; //要删除的节点是头结点 else if(head==node)&#123; head=null; &#125; //要删除的节点是中间普通节点 else&#123; node.data=node.next.data; node.next=node.next.next; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E23链表中环的入口节点(判断链表是否有环)","date":"2018-04-08T07:51:00.000Z","path":"2018/04/08/E23链表中环的入口节点(判断链表是否有环)/","text":"题目一个链表中包含环，请找出该链表的环的入口结点。 思路如果链表中有环，那么先获取环中节点个数n，设置两个指针指向pHead 快指针向前移动n次，然后进行循环，快慢指针同时向后移动，直到指向的节点相同，即环入口节点 获取环中节点个数：设置两个指针：p1和p2。p1一次移动一次，p2一次移动两次 当p2等于p1，说明存在环。返回该节点 通过该节点很容易能获得环中节点个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class 链表中环的入口结点 &#123; //找到一快一慢指针相遇处的节点，相遇的节点一定是在环中 //此方法可用作判断链表是否有环 public static ListNode meetingNode(ListNode head) &#123; if(head == null) return null; ListNode slow = head.next; if(slow == null) return null; ListNode fast = slow.next; while (slow != null &amp;&amp; fast != null) &#123; if(slow == fast)&#123; return fast; &#125; slow=slow.next; fast=fast.next; if(fast!=null)&#123; fast=fast.next; &#125; &#125; return null; &#125; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode meetingNode = meetingNode(pHead); if(meetingNode == null) return null;// 得到环中的节点个数 int nodesInLoop = 1; ListNode p1 = meetingNode; while(p1.next != meetingNode)&#123; p1=p1.next; ++nodesInLoop; &#125;// 移动p1，次数为环中节点数目 p1 = pHead; for(int i = 0;i &lt; nodesInLoop; i++)&#123; p1 = p1.next; &#125;// 再移动p1，p2 ListNode p2 = pHead; while(p1!= p2)&#123; p1 = p1.next; p2 = p2.next; &#125; return p1; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"求链表的中间节点","date":"2018-04-08T07:35:36.000Z","path":"2018/04/08/求链表的中间节点/","text":"题目： 求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数为偶数，返回中间两个结点的任意一个。 思路： 设置两个指针fast和slow，两个指针同时向前走，fast指针每次走两步，slow指针每次走一步，直到fast指针走到最后一个结点时，此时slow指针所指的结点就是中间结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度为O（n）。 1234567891011121314private static ListNode findMid(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head; ListNode fast = head; //每次移动时，让fast结点移动两位，slow结点移动一位 while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; &#125; //直到fast结点移动到null时，此时slow指针指向的位置就是中间结点的位置 return slow;&#125; 注：当n为偶数时，得到的中间结点是第n/2 + 1个结点。比如链表有6个节点时，得到的是第4个节点。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E25合并两个排序的链表","date":"2018-04-08T06:17:53.000Z","path":"2018/04/08/E25合并两个排序的链表/","text":"题目： 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 步骤： Step1.定义一个指向新链表的指针，暂且让它指向NULL； Step2.比较两个链表的头结点，让较小的头结点作为新链表的头结点； Step3.递归比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点； 递归解法： 12345678910111213141516public Node Merge(Node head1, Node head2)&#123; if (head1 == null)&#123; return head2; &#125;else if (head2 == null)&#123; return head1; &#125; Node newHead = null; if (head1.val &lt;= head2.val)&#123; newHead = head1; newHead.next = Merge(head1.next, head2); &#125;else &#123; newHead = head2; newHead.next = Merge(head1, head2.next); &#125; return newHead;&#125; 非递归解法： 12345678910111213141516171819202122232425262728293031323334public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null ) return list1; ListNode tmp1 = list1; ListNode tmp2 = list2; ListNode head = new ListNode(0);//这里不能把返回链表赋值为null，因为下一行马上就要把它赋值给另一链表，得让它在内存里有位置才行 ListNode headptr = head; while(tmp1 != null &amp;&amp; tmp2!=null)&#123; if(tmp1.val &lt;= tmp2.val) &#123; head.next=tmp1; head = head.next; tmp1 = tmp1.next; &#125;else&#123; head.next=tmp2; head = head.next; tmp2=tmp2.next; &#125; &#125; //其中一个链表已经跑到头之后，继续单链表的合并 while(tmp1 != null)&#123; head.next = tmp1; head = head.next; tmp1= tmp1.next; &#125; while(tmp2 != null)&#123; head.next = tmp2; head = head.next; tmp2= tmp2.next; &#125; head = headptr.next; return head;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E24反转链表","date":"2018-04-08T03:39:04.000Z","path":"2018/04/08/E24反转链表/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*定义链表*/class Node &#123; int val; Node next; public Node(int val) &#123; this.val = val; &#125;&#125;public class ReverseList &#123; /* 反转链表*/ public static Node reverseList(Node head) &#123; if (head == null || head.next == null)&#123; return head; &#125; Node reHead = null;// 定义新链表头结点 while (head != null) &#123; Node cur = head.next;// 记录下一个节点 head.next = reHead;// 将rehead节点连接到head节点上 reHead = head;// 让rehead指向head head = cur;// 将head指向下一个节点 &#125; return reHead; &#125; /**递归反转链表 */ public static Node reverseList2(Node head) &#123; if (head == null || head.next == null) return head; Node rehead = reverseList2(head.next); head.next.next = head;// 将头节点置于末端 head.next = null;// 防止链表循环 return rehead; &#125; /**打印链表 */ public static void printList(Node head) &#123; if (head == null) return; while (head != null) &#123; System.out.print(head.val + \" \"); head = head.next; &#125; &#125; public static void main(String[] args) &#123;/*测试*/ Node n1 = new Node(1); Node n2 = new Node(2); Node n3 = new Node(3); Node n4 = new Node(4); Node n5 = new Node(5); n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; // Node rehead = reverseList(n1); Node rehead = reverseList2(n1); printList(rehead); &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"从链表中删除重复元素","date":"2018-04-07T15:25:02.000Z","path":"2018/04/07/从链表中删除重复元素/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;public class deleteDuplecate &#123; //法一：优点是时间复杂度低，但是需要额外的存储空间来保存遍历过的值。时间复杂度O(n) public void delete_v1(Node head)&#123; Hashtable&lt;Integer,Integer&gt; table=new Hashtable&lt;Integer,Integer&gt;(); Node temp=head; Node pre=null; //辅助链表的头节点 while(temp!=null)&#123; if(table.containsKey(temp.data)) pre.next=temp.next; else&#123; table.put(temp.data, 1); pre=temp; &#125; temp=temp.next; &#125; &#125; //法二：双重循环遍历链表,优点：不需要额外的存储空间.时间复杂度O(n^2) public void delete_v2(Node head)&#123; Node p=head; while(p!=null)&#123; Node q = p; while(q.next!=null)&#123; if(q.next.data==p.data)&#123; q.next=q.next.next; &#125;else q=q.next; &#125; p=p.next; &#125; &#125; //法三：外循环当前遍历的结点为p，内循环从表头开始遍历至p public void delete_v3(Node head)&#123; Node p=head; while(p!=null)&#123; Node q=head; while(q.next!=p &amp;&amp; q.next!=null)&#123; if(q.next.data==p.data)&#123; q.next=q.next.next; &#125;else q=q.next; &#125; p=p.next; &#125; &#125;&#125;class Node&#123; Node next=null; int data; public Node(int data)&#123; this.data=data; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E22求链表中倒数第k个节点","date":"2018-04-07T15:18:30.000Z","path":"2018/04/07/E22求链表中倒数第k个节点/","text":"为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。 如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。设计如下：依次对链表的每一个结点元素进行这样的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。此种方法将对同一批元素进行反复多次的遍历，对于链表的大部分元素而言，都要遍历k个元素，如果链表长度为n，则该算法时间复杂度为O(kn)级，效率太低。存在另一种更高效的方法。在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置。 12345678910111213141516171819public Node findElem(Node head,int k)&#123; if(k &lt; 1 || head == null)&#123; return null; &#125; Node p1 = head; Node p2 = head; for (int i = 0; i &lt; k - 1; i++) &#123; //前移k-1步 if(p1.next != null)&#123; p1 = p1.next; &#125;else &#123; return null; &#125; &#125; while (p1.next != null) &#123; p1 = p1.next; p2 = p2.next; &#125; return p2;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"链表基本代码实现","date":"2018-04-07T14:40:42.000Z","path":"2018/04/07/链表基本代码实现/","text":"链表节点定义123456789101112public class Node &#123; //为了方便，这两个变量都使用public，而不用private就不需要编写get、set方法了。 //存放数据的变量，简单点，直接为int型 public int data; //存放结点的变量,默认为null public Node next; //构造方法，在构造时就能够给data赋值 public Node(int data)&#123; this.data = data; &#125;&#125; 链表尾部增加节点12345678public void addNode(Node node)&#123; //链表中有结点，遍历到最后一个结点 Node temp = head; //一个移动的指针(把头结点看做一个指向结点的指针) while(temp.next != null)&#123; //遍历单链表，直到遍历到最后一个则跳出循环。 temp = temp.next; //往后移一个结点，指向下一个结点。 &#125; temp.next = node; //temp为最后一个结点或者是头结点，将其next指向新结点&#125; 插入结点到链表的指定位置123456789101112131415161718192021222324252627/** * insertNodeByIndex:在链表的指定位置插入结点。 * 插入操作需要知道1个结点即可，当前位置的前一个结点 * index:插入链表的位置，从1开始 * node:插入的结点 */ public void insertNodeByIndex(int index,Node node)&#123; //首先需要判断指定位置是否合法， if(index&lt;1||index&gt;length()+1)&#123; System.out.println(\"插入位置不合法。\"); return; &#125; int length = 1; //记录我们遍历到第几个结点了，也就是记录位置。 Node temp = head; //可移动的指针 while(temp.next != null)&#123;//遍历单链表 if(index == length++)&#123; //判断是否到达指定位置。 //注意，我们的temp代表的是当前位置的前一个结点。 //前一个结点 当前位置 后一个结点 //temp temp.next temp.next.next //插入操作。 node.next = temp.next; temp.next = node; return; &#125; temp = temp.next; &#125; &#125; 删除指定位置上的结点123456789101112131415161718192021222324/** * 通过index删除指定位置的结点,跟指定位置增加结点是一样的，先找到准确位置。然后进行删除操作。 * 删除操作需要知道1个结点即可：和当前位置的前一个结点。 * @param index：链表中的位置，从1开始 */ public void delNodeByIndex(int index)&#123; //判断index是否合理 if(index&lt;1 || index&gt;length())&#123; System.out.println(\"给定的位置不合理\"); return; &#125; //步骤跟insertNodeByIndex是一样的，只是操作不一样。 int length=1; Node temp = head; while(temp.next != null)&#123; if(index == length++)&#123; //删除操作。 temp.next = temp.next.next; return; &#125; temp = temp.next; &#125; &#125; 单链表进行选择排序12345678910111213141516171819202122232425/** *对链表中的结点进行排序，按照从小到大的顺序，使用选择排序。 *使用双层遍历。第一层遍历，正常遍历链表，第二层遍历，遍历第一层遍历时所用的结点后面所有结点并与之比较 */public void selectSortNode()&#123; //判断链表长度大于2，不然只有一个元素，就不用排序了。 if(length()&lt;2)&#123; System.out.println(\"无需排序\"); return; &#125; //选择排序 Node temp = head; //第一层遍历使用的移动指针，最处指向头结点，第一个结点用temp.next表示 while(temp.next != null)&#123;//第一层遍历链表，从第一个结点开始遍历 Node secondTemp = temp.next; //第二层遍历使用的移动指针，secondTemp指向第一个结点，我们需要用到是第二个结点开始，所以用secondNode.next while(secondTemp.next != null)&#123;//第二层遍历,从第二个结点开始遍历 if( temp.next.data &gt; secondTemp.next.data)&#123;//第二层中的所有结点依次与第一次遍历中选定的结点进行比较 int t = secondTemp.next.data; secondTemp.next.data = temp.next.data; temp.next.data = t; &#125; secondTemp = secondTemp.next; &#125; temp = temp.next; &#125;&#125; 计算单链表的长度12345678910111213/** * 计算单链表的长度，也就是有多少个结点 * @return 结点个数 */ public int length() &#123; int length=0; Node temp = head; while(temp.next != null)&#123; length++; temp = temp.next; &#125; return length; &#125; 遍历单链表，打印data1234567891011/** * 遍历单链表，打印所有data */ public void print()&#123; Node temp = head.next; while(temp != null)&#123; System.out.print(temp.data+\",\"); temp = temp.next; &#125; System.out.println(); &#125;","tags":[{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E06从尾到头打印链表","date":"2018-04-07T14:22:43.000Z","path":"2018/04/07/E06从尾到头打印链表/","text":"很多人第一反应是从头到尾输出将会比较简单，于是自然想到把链表中连接结点的指针反转过来，改变链表的方向即可。但该方法会改变原来链表的结构，是否允许在打印链表的时候修改链表的结构，这点取决于面试官的需求。 通常打印是一个只读操作，我们不希望打印时修改内容。 第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出，这就是典型的“后进先出”！我们用栈来实现这种结构。 既然用栈来实现，而递归本质上就是一个栈的结构，自然也可以用递归来实现。基于递归的代码看起来很简洁，但当链表非常长的时候，就会导致函数调用的层数很深，从而有可能导致函数调用栈溢出。 显然用栈基于循环实现的代码的鲁棒性要好一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Stack;public class PrintListReverse&#123; //非递归的方式，鲁棒性好 public void printListReverse(ListNode headNode)&#123; Stack&lt;ListNode&gt; stack=new Stack&lt;&gt;(); while(headNode!=null) &#123; stack.push(headNode); headNode=headNode.next; &#125; while(!stack.isEmpty()) &#123; System.out.println(stack.pop().val); &#125; &#125; //递归方式，递归在本质上就是一个栈结构 public void printListReverse_recursively(ListNode headNode)&#123; if(headNode!=null) &#123; if(headNode.next!=null) &#123; printListReverse_recursively(headNode.next); &#125; System.out.println(headNode.val); &#125; &#125; public static void main(String[] args) &#123; ListNode node1 = new ListNode(); ListNode node2 = new ListNode(); ListNode node3 = new ListNode(); node1.val=1; node2.val=2; node3.val=3; node1.next = node2; node2.next = node3; PrintListReverse plr = new PrintListReverse(); plr.printListReverse(node1); plr.printListReverse_recursively(node1); &#125;&#125;class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/链表/"}]},{"title":"E05替换空格","date":"2018-04-07T13:07:41.000Z","path":"2018/04/07/E05替换空格/","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解法一：123456789public String replaceSpace(StringBuffer str) &#123; for(int k=0; k&lt;str.length(); k++)&#123; char index = str.charAt(k); if(index == ' ')&#123; str.replace(k, k+1, \"%20\"); &#125; &#125; return str.toString();&#125; 以下是java.lang.StringBuilder.replace()方法的声明 public StringBuilder replace(int start, int end, String str); 参数 start – 这是开始索引(包括)。 end – end 索引(不包括)。 str – 这是字符串，它将取代以前的内容。 解法二：思路：从字符串的后面开始复制和替换，首先准备两个指针，p1和p2，p1指向原始字符串的末尾，p2指向替换后字符串的末尾，接下来，向前移动指针p1，逐个把它指向的字符复制到p2，碰到一个空格之后，把p1向前移动1格，在p2处插入字符串“20%”，由于“20%”长度为3，同时也要把p2向前移动3格。直到p1=p2，表明所有空格都已经替换完毕。 1234567891011121314151617181920212223242526272829303132333435public class ReplaceSpace &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String str=scanner.nextLine(); scanner.close(); char[] charArray = str.toCharArray(); int length=charArray.length; int spaceNumber=0;//获取空格数量 for (char c : charArray) &#123; if(c==' ') &#123; spaceNumber++; &#125; &#125; int newLength=length+spaceNumber*2; char[] tempArray=new char[newLength];//新的数组的长度 //将原来的数组拷贝到新长度的数组中 System.arraycopy(charArray, 0, tempArray, 0, length); int indexofOriginal = length - 1; int indexofNew = newLength - 1; while (indexofOriginal&gt;=0&amp;&amp;indexofOriginal!=indexofNew) &#123; if (tempArray[indexofOriginal]==' ') &#123; tempArray[indexofNew--] = '0'; tempArray[indexofNew--] = '2'; tempArray[indexofNew--] = '%'; &#125;else &#123; tempArray[indexofNew--] = tempArray[indexofOriginal]; &#125; indexofOriginal--; &#125; for (char c : tempArray) &#123; System.out.print(c); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"WSL（Windows下Linux子系统）安装过程","date":"2018-04-06T14:23:52.000Z","path":"2018/04/06/WSL（Windows下Linux子系统）安装过程/","text":"WSL(Windows Subsystem for Linux) 适用于Linux的Windows子系统，今天初步在自己的笔记本上尝试了一下，也遇到一些问题，现记录如下： 安装步骤如下： 1.控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选适用于Linux的Windows子系统，重启电脑 2.应用商店下搜索wsl，现已支持Ubuntu、openSUSE LEAP 42、SUSE Linux Enterprise、Debian、Kali Linux五个版本，直接安装即可 安装位置为： 1C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc 注：所有系统均只有命令行，没有桌面 3.根据提示设置账户名及密码 4.设置root账户密码 1sudo passwd root 系统安装完成，下面为桌面安装过程 5.在Ubuntu下我们可以通过 apt-get 命令很方便的安装/卸载软件，由于默认的软件包仓库是位于国外的，安装软件的时候就可能遇到各种网络问题或者下载到的一些资源不完整，因此就需要切换数据源为国内的镜像站点来改善 1234# 1.备份原来的数据源配置文件cp /etc/apt/sources.list /etc/apt/sources.list_backup# 2.编辑数据源配置文件vi /etc/apt/sources.list 在这里我使用的是阿里云的数据源： 12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 12# 3.更新配置apt-get update 6.下载软件 可供选择安装的X-Windows有多个：VcXsrv Windows X Server、Xming、Cygwin X Server，本文选择第一个，因为比较容易，而且据说稳定； 软件首页：https://sourceforge.net/projects/vcxsrv/ 下载软件，windows下安装好，启动Launcher，首次启动自动进入界面设置后： 选择：“one large window”，Display number设置成0，其它默认即可： 7.打开Bash，安装ubuntu-desktop, unity, and ccsm（下载桌面及解压花了很久很久） 1sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager 若报错，则改为 1sudo apt-get install ubuntu-desktop unity compiz-core 需要提醒的是，需下载650M，解压后近2.4G ，均安装在C盘 8.配置compiz窗口管理器 启动之前安装的X-Windows，在Bash中执行如下命令： 12export DISPLAY=localhost:0sudo ccsm 9.切换到Ubuntu`Bash窗口，执行以下命令并切换回VcXsrv`窗口查看效果。 1sudo compiz 附加： 安装中文支持并配置profile文件 在桌面环境打开一个终端，执行以下命令安装中文支持 1sudo apt-get -y install language-pack-zh-hans 1sudo vi /etc/profile 将以下环境变量添加到/etc/profile文件 1234export DISPLAY=localhost:0export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN.UTF-8export LC_ALL=zh_CN.UTF-8 重新加载profile 1source /etc/profile 重新生成locale 1locale-gen 卸载子系统 设置&gt;应用&gt;应用和功能，找到Ubuntu卸载即可 安装过程参考自： https://www.jianshu.com/p/bc38ed12da1d https://blog.csdn.net/u011138447/article/details/78262369 https://zhuanlan.zhihu.com/p/34884285/","tags":[{"name":"Linux","slug":"Linux","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Linux/"},{"name":"项目问题","slug":"项目问题","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/项目问题/"}]},{"title":"SQL必知必会","date":"2018-04-06T13:24:54.000Z","path":"2018/04/06/SQL必知必会/","text":"一、基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 支持以下三种注释： 12345# 注释SELECT *FROM mytable; -- 注释/* 注释1 注释2 */ 二、创建表123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 三、修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 四、插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容插入到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 五、更新123UPDATE mytableSET col = valWHERE id = 1; 六、删除12DELETE FROM mytableWHERE id = 1; TRUNCATE TABLE 可以清空表，也就是删除所有行。 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 七、查询DISTINCT相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 八、排序 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 九、过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = &lt; &gt; 等于 小于 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为NULL值 应该注意到，NULL 与 0 、空字符串都不同。 AND OR 用于连接多个过滤条件。优先处理 AND，因此当一个过滤表达式涉及到多个 AND 和 OR 时，应当使用 () 来决定优先级。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 十、通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%' -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 十一、计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1*col2 AS aliasFROM mytable CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT CONCAT(TRIM(col1), ' (', TRIM(col2), ')')FROM mytable 十二、函数各个 DBMS 的函数都是不相同的，因此不可移植。 文本处理 函数 说明 LEFT() RIGHT() 左边或者右边的字符 LOWER() UPPER() 转换为小写或者大写 LTRIM() RTIM() 去除左边或者右边的空格 LENGTH() 长度 SUNDEX() 转换为语音值 其中， SOUNDEX() 是将一个字符串转换为描述其语音表示的字母数字模式的算法，它是根据发音而不是字母比较。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 12mysql&gt; SELECT NOW(); -&gt; '2017-06-28 14:01:52' 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 十三、分组分组就是把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能按该字段进行分组，也可以按该字段进行排序，例如按 col 字段排序并分组数据： 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; GROUP BY 是按照分组字段进行排序，ORDER BY 也可以以汇总字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; WHERE 过滤行，HAVING 过滤分组。行过滤应当先与分组过滤； 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING COUNT(*) &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 十四、子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 十五、连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123select a, b, cfrom A inner join Bon A.key = B.key 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123select a, b, cfrom A, Bwhere A.key = B.key 在没有条件语句的情况下返回笛卡尔积。 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456select namefrom employeewhere department = ( select department from employee where name = \"Jim\"); 自连接版本 1234select e2.namefrom employee as e1, employee as e2where e1.department = e2.department and e1.name = \"Jim\"; 连接一般比子查询的效率高。 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12select *from employee natural join department; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123select Customers.cust_id, Orders.order_numfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_id; 如果需要统计顾客的订单数，使用聚集函数。 12345select Customers.cust_id, COUNT(Orders.order_num) as num_ordfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_idgroup by Customers.cust_id; 十六、组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果为 M+N 行。 每个查询必须包含相同的列、表达式或者聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 十七、视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS count_colFROM mytableWHERE col5 = val; 十八、存储过程存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 创建存储过程命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 1234567891011delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 十九、游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 二十、触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。 INSERT 触发器包含一个名为 NEW 的虚拟表。 12CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col; DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 二十一、事务处理基本术语： 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，也就是每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 二十二、字符集基本术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 二十三、权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户1CREATE USER myuser IDENTIFIED BY 'mypassword'; 新创建的账户没有任何权限。 修改账户名1RENAME myuser TO newuser; 删除账户1DROP USER myuser; 查看权限1SHOW GRANTS FOR myuser; 授予权限1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 删除权限1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('newpassword'); 参考资料 BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"Java的序列化","date":"2018-04-06T12:39:33.000Z","path":"2018/04/06/Java的序列化/","text":"对于Java的序列化，一直只知道只需要实现Serializbale这个接口就可以了，具体内部实现一直不是很了解，正好这次在重复造RPC的轮子的时候涉及到序列化问题，就抽时间看了下 Java序列化的底层实现，这篇文章算是这次的学习小结吧。 Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。 为什么需要序列化？第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。 第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。 有一个需要注意的问题就是，如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？答：如果父类有默认构造函数的话，即使没有实现Serializable接口也不会有问题，反序列化的时候会调用默认构造函数进行初始化，否则的话反序列化的时候会抛出.InvalidClassException:异常，异常原因为no validconstructor。 本文转载自：http://www.importnew.com/17964.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"死锁","date":"2018-04-06T10:01:38.000Z","path":"2018/04/06/死锁/","text":"死锁定义是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 活锁活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 产生条件互斥条件：一个资源一次只能被一个进程使用请求保持条件：一个进程因请求资源而阻塞时，对已经获得资源保持不放不可抢占条件：进程已获得的资源在未使用完之前不能强行剥夺循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系 检测方法两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测: 1)检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来 2)遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求 如果第二步返回真,表示出现了死锁 如何避免死锁在有些情况下死锁是可以避免的。三种用于避免死锁的技术： 加锁顺序（线程按照一定的顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 死锁检测 那么当检测出死锁时，这些线程该做些什么呢？ 给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。 银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。 死锁的解除一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。 死锁解除的主要方法有： 1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。 死锁检测与死锁恢复死锁检测算法 死锁检测的基本思想是，如果一个进程所请求的资源能够被满足，那么就让它执行，否则释放它拥有的所有资源，然后让其它能满足条件的进程执行。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"线程和进程的区别","date":"2018-04-05T14:27:48.000Z","path":"2018/04/05/线程和进程的区别/","text":"引入进程之前–多道程序设计概述多道程序设计技术是操作系统最早引入的技术，它的设计思想是允多个程序同时进入内存并运行，其目的是为了CPU的利用率，进而提高系统效率。 特点多道程序设计技术引入之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。而多道程序设计技术允许多个程序同时进入内存并运行，那就要每个程序分配程序计数器。如果内存中有四个程序在并发执行，那就需要四个程序计数器。 新技术带来的问题一个技术、一个机制的引入，一方面解决了以前棘手的问题，但同时，往往带来新的问题。多道程序设计技术也是如此。 多道程序设计技术允许多个程序同时进入内存并运行，在这样的并发环境下，如何描述、刻画这样执行的程序呢？因此引入了“进程”。 进程（Process）定义进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。 特点 进程是程序的一次执行过程。若程序执行两次甚至多次，则需要两个甚至多个进程。 进程是是正在运行程序的抽象。它代表运行的CPU，也称进程是对CPU的抽象。（虚拟技术的支持，将一个CPU变幻为多个虚拟的CPU） 系统资源（如内存、文件）以进程为单位分配。 操作系统为每个进程分配了独立的地址空间 操作系统通过“调度”把控制权交给进程。 为什么引入线程 有了进程这概念之后 应用程序可以并发地去执行了 那么为什么要在进程当中再派生出线程呢？ 为什么引入线程？首先我们引入了进程这个概念，虽然进程有利于资源的管理和保护。然而在实际应用中，进程有这样的问题： 进程切换的代价、开销比较大； 在一个进程内也需要并行执行多个程序，实现不同的功能。 进程有时候性能比较低。 引入线程有以下三个方面的考虑 应用的需要。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。 开销的考虑。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件） 性能的考虑。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。 线程(Thread)定义线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 属性 有标识符ID 有状态及状态转换，所以需要提供一些状态转换操作 不运行时需要保存上下文环境，所以需要程序计数器等寄存器 有自己的栈和栈指针 共享所在进程的地址空间和其它资源 进程与线程区别1.定义方面：进程是程序在某个数据集合上的一次运行活动；线程是进程中的一个执行路径。（进程可以创建多个线程） 2.角色方面：在支持线程机制的系统中，进程是系统资源分配的单位，线程是CPU调度的单位。 ​ 总线程数&lt;= CPU数量：并行运行 ​ 总线程数&gt; CPU数量：并发运行 3.资源共享方面：进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。 4.独立性方面：进程有自己独立的地址空间，而线程没有，线程必须依赖于进程而存在。 5.开销方面。进程切换的开销较大。线程相对较小。（前面也提到过，引入线程也出于了开销的考虑。） 线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 Read moreProcess Vs Thread Difference between Process and Thread what is different between thread and process 理解Android进程创建流程（转） 本文转载整理自： http://blog.csdn.net/zheng548/article/details/54669908 https://blog.csdn.net/robbyo/article/details/8549904","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/操作系统/"}]},{"title":"Java后端技术","date":"2018-04-05T13:57:36.000Z","path":"2018/04/05/Java后端技术/","text":"后端主要的技术： 服务框架：Dubbo，zookeeper，Rest服务缓存：redis，ehcache消息中间件：ActiveMQ，kafka负责均衡：Nginx分布式文件：FastDFS安全框架：Apache shiro任务调度：quartz持久层框架：mybatis日志：log4j项目基础搭建。spring，springmvc环境搭建：linux下开发工具：eclipse，idea等服务器：tomcat，jetty等 目前系统主流搭建：Nginx+tomcat+mybatis+redis。针对不同的业务需求，我们会引用不同的技术。 这些主要定位于互联网企业架构 框架简介： 企业信息化系统基础功能和高效的代码生成工具，包括: 系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、 平台简介： 是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。 本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。 使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。 以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。 前端集成bootstrap 框架。响应式 目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务） 提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。 内置功能(只列了一部分功能) 1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。 2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。 3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。 4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。 5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。 6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。 7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。 8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。 9.工作流引擎：实现业务工单流转、在线流程设计器。 开发工具 1.Eclipse IDE：采用Maven项目管理，模块化。 2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。 技术选型（只列了一部分技术） 1、后端 服务框架：Dubbo、zookeeper、Rest服务 缓存：Redis、ehcache 消息中间件：ActiveMQ 负载均衡：Nginx 分布式文件：FastDFS 数据库连接池：Alibaba Druid 1.0 核心框架：Spring framework 安全框架：Apache Shiro 1.2 视图框架：Spring MVC 4.0 服务端验证：Hibernate Validator 5.1 布局框架：SiteMesh 2.4 工作流引擎：Activiti 5.15 任务调度：quartz 1.8.5 持久层框架：MyBatis 3.2 日志管理：SLF4J 1.7、Log4j 工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI 2、前端 JS框架：JQuery 1.9。 CSS框架： Bootstrap 4 metronic 客户端验证：JQuery Validation Plugin。 富文本：CKEcitor 文件管理：CKFinder 动态页签：Jerichotab 数据表格：jqGrid 对话框：jQuery jBox 树结构控件：jQuery zTree 其他组件：Bootstrap 4 metronic 3、支持 服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8 数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等 支持开发环境：Eclipse、MyEclipse、Ras、Idea等。 本文转载自网络","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"字符和字节的区别","date":"2018-04-05T13:42:35.000Z","path":"2018/04/05/字符和字节的区别/","text":"“字节”的定义字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。 “字符”的定义字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。 “字节”与“字符”它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同： ①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。 ②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 ③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。 ④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。 ⑤UTF-32编码中，世界上任何字符的存储都需要4个字节 ⑥通常在读取非文本文件时（如图片，声音，可执行文件）需要用字节数组来保存文件的内容，在下载文件时，也是用byte数组作临时的缓冲器接收文件内容。所以说byte在文件操作时是必不可少的。不管是对文件写入还是读取都要用到。byte在java中是一种是数据类型，代表一个字节，一个字节包含8个位，所以，byte类型的取值范围是-128到127。在某些程序中（尤其是和硬件有关的程序）会将某些数据存储到字节类型的变量中，比如00110010,其中每个位都代表一个参数，然后以位运算的方式对参数进行取值和赋值操作。 机器只知道字节，而字符却是语义上的单位，它是有编码的，一个字符可能编码成1个2个甚至3个4个字节。这跟字符集编码有关系，英文字母和数字是单字节，但汉字这些自然语言中的字符是多字节的。一个字节只能表示255个字符，不可能用于全球那么多种自然语言的处理，因此肯定需要多字节的存储方式。而InputStream, OutputStream它们是处理字节流的，就是说假设所有东西都是二进制的字节，而 Reader, Writer 则是字符流，它涉及到字符集的问题；按照ANSI编码标准，标点符号、数字、大小写字母都占一个字节，汉字占2个字节。按照UNICODE标准所有字符都占2个字节。 本文整理转载自网络 ​","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java中基本类型的取值范围","date":"2018-04-05T13:03:09.000Z","path":"2018/04/05/Java中基本类型的取值范围/","text":"类型 占内存大小 取值范围 数值范围 默认值 byte 1个字节 (8bit) -27~27-1 -128~127 0 short 2个字节 (16bit) -215~215-1 -32768~32767 0 int 4个字节 (32bit) -231~231-1 -2147483648~2147483647 0 long 8个字节 (64bit) -263~263-1 -9223372036854774808~9223372036854774807 0 boolean 1个字节 (8bit) ture，false false char 2个字节 (16bit) 0~216-1 ‘\\u0000’ float 4个字节 (32bit) 2-149~2128-1 1.4013E-45~3.4028E+38 0.0F double 8个字节 (64bit) 2-1074~21024-1 4.9E-324~1.7977E+308 0.0D int包装类为：java.lang.Integer。其余类型类似，均为类型大写首字母","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"悲观锁与乐观锁","date":"2018-04-04T13:34:13.000Z","path":"2018/04/04/悲观锁与乐观锁/","text":"定义1.悲观锁：即很悲观，每次拿数据的时候都觉得数据会被人更改，所以拿数据的时候就把这条记录锁掉，这样别人就没法改这条数据了，一直到你的锁释放。 2.乐观锁：即很乐观，查询数据的时候总觉得不会有人更改数据，等到更新的时候再判断这个数据有没有被人更改，有人更改了则本次更新失败。 实现过程悲观锁：悲观锁的实现采用的数据库内部的锁机制，一个典型的倚赖数据库的悲观锁调用： 1select * from account where name=\"张三\" for update; 这条sql 语句锁定了account 表中所有符合检索条件（name=”张三”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。也就是我们可以在查询数据的时候先用for update把这条数据锁住，然后更改完这条数据再提交。这样别的线程没法更新这条数据，也就保证了不会丢失更新。 悲观锁带来的性能问题。我们试想一个场景：如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果？所以我们这个时候可以使用乐观锁。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁：乐观锁的实现可以通过在表里面加一个版本号的形式，每个人更新的时候都会判断当前的版本号是否跟我查询出来得到的版本号是否一致，不一致就更新失败，一致就更新这条记录并更改版本号。 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 使用场景像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据库/"}]},{"title":"synchronized与Lock的区别","date":"2018-04-04T13:07:54.000Z","path":"2018/04/04/synchronized与Lock的区别/","text":"类别 synchronized Lock 存在层次 Java的关键字，在jvm层面上 是一个类 锁的释放 1、已获取锁的线程执行完同步代码会释放锁 2、线程执行发生异常，jvm会让线程释放锁 需在finally中手工释放锁（unlock()方法释放锁），不然容易造成线程死锁 锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，如果尝试获取不到锁，线程可以不用一直等待 锁状态 无法判断是否获取到锁 可以判断是否获取到锁 锁类型 可重入 不可中断 非公平 可重入 可判断 可公平（两者皆可） 性能 适合代码少量的同步问题 适合代码大量的同步问题 两种锁的底层实现方式： synchronized： 我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。 其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。 那有两个monitorexit呀？synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。 Lock： Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。底层主要靠volatile和CAS操作实现的。 尽可能去使用synchronized而不要去使用LOCK 转载自：https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"List接口的实现类--ArrayList、LinkedList、Vector之间的区别","date":"2018-04-04T11:54:20.000Z","path":"2018/04/04/List接口的实现类-ArrayList、LinkedList、Vector之间的区别/","text":"概述Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└Set ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长。 ArrayList不是线程安全的，只能用在单线程环境下。 允许元素为null 实现了Serializable接口，因此它支持序列化，能够通过序列化传输； 实现了RandomAccess接口，支持快速随机访问，可以以O(1)的时间复杂度去根据下标访问元素，实际上就是通过下标序号进行快速访问； 实现了Cloneable接口，能被克隆。 因其底层数据结构是数组，它占据了一块连续的内存空间（容量就是数组的length），所以它也有数组的缺点，空间效率不高。 由于数组的内存连续，可以根据下标以O(1)的时间读写(改查)元素，因此时间效率很高。 初始化 首先有三种方式来初始化： 1public ArrayList(); 默认的构造器，将会以默认的大小来初始化内部的数组 1public ArrayList(Collection&lt;? extends E&gt; c) 用一个ICollection对象来构造，并将该集合的元素添加到ArrayList 1public ArrayList(int initialCapacity) ArrayList的扩容机制使用无参构造方法时系统会默认提供默认参数10，而使用有参构造函数时我们会指定大小。在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组（通常为原数组的1.5倍）（当第一次插入元素时分配10个对象空间。假如有20个数据需要添加，那么会分别在第一次的时候，将ArrayList的容量变为10；之后扩容会按照1.5倍增长。也就是当添加第11个数据的时候，Arraylist继续扩容变为10 1.5=15，当添加第16个数据时，继续扩容变为15 1.5 =22个），旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组指向了新的数组。 扩容操作也是ArrayList 的一个性能消耗比较大的地方，所以若我们可以提前预知数据的规模，应该通过public ArrayList(int initialCapacity) {}构造方法，指定集合的大小，去构建ArrayList实例，以减少扩容次数，提高效率。 或者在需要扩容的时候，手动调用public void ensureCapacity(intminCapacity) {}方法扩容。 不过该方法是ArrayList的API，不是List接口里的，所以使用时需要强转: ((ArrayList)list).ensureCapacity(30); ArrayList、LinkedList与List的不同（什么情况下你会使用ArrayList？什么时候你会选择LinkedList？）1.List是接口类，ArrayList和LinkedList是List的实现类。 2.ArrayList是动态数组（顺序表）的数据结构。顺序表的存储地址是连续的，所以在查找比较快，但是在插入和删除时，由于需要把其它的元素顺序向后移动（或向前移动），所以比较耗时。 3.LinkedList是链表的数据结构。链表的存储地址是不连续的，每个存储地址通过指针指向，在查找时需要进行通过指针遍历元素，所以在查找时比较慢。由于链表插入时不需移动其它元素，所以在插入和删除时比较快。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。 ArrayList和LinkedList的时间复杂度ArrayList 是线性表（数组） get()：直接读取第几个下标，复杂度 O(1) add(E) ：添加元素，直接在后面添加，复杂度O（1） add(index, E) ：添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n） remove（）：删除元素，后面的元素需要逐个移动，复杂度O（n） LinkedList 是链表的操作 get()：获取第几个元素，依次遍历，复杂度O(n) add(E) ：添加到末尾，复杂度O(1) add(index, E) ：添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n) remove（）：删除元素，直接指针指向操作，复杂度O(1) 如何复制某个ArrayList到另一个ArrayList中去？1.使用clone()方法，比如ArrayList newArray = oldArray.clone(); 2.使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject); 3.使用Collections的copy方法。 注意1和2是浅拷贝(shallowcopy)。 ArrayList为什么是线程不安全的？ArrayList在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 用Collections.synchronizedList可以把一个普通ArrayList包装成一个线程安全版本的数组容器，原理同Vector是一样的，就是给所有的方法套上一层synchronized。 ArrayList和Vector的区别？ArrayList和Vector都实现了list接口，都是数组实现； 区别在于Vector在API上都加了synchronized所以它是线程安全的，以及Vector扩容时，是扩容100%，而ArrayList是扩容50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。 stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Java代码执行顺序","date":"2018-04-04T08:41:44.000Z","path":"2018/04/04/Java代码执行顺序/","text":"实例： 123456789101112131415161718192021222324252627282930313233343536373839class Person&#123; static &#123; System.out.println(\"执行Person静态代码块\"); &#125; &#123; System.out.println(\"执行Person构造代码块\"); &#125; public Person()&#123; System.out.println(\"执行Person无参构造方法\"); &#125; public Person(String name)&#123; System.out.println(\"执行Person构造方法\"+ name); &#125;&#125;class Student extends Person&#123; static &#123; System.out.println(\"执行Student静态代码块\"); &#125; &#123; System.out.println(\"执行Student构造代码块\"); &#125; public Student(String name)&#123; super(name); System.out.println(\"执行Student构造方法\" + name); &#125; public Student()&#123; super(); System.out.println(\"执行Student无参构造方法\"); &#125;&#125;public class ExtendsStaticConstruct &#123; public static void main(String args[])&#123; Student student1 = new Student(\"ABC\"); System.out.println(\"--------------------\"); Student student2 = new Student(); &#125;&#125; 执行结果： 1234567891011执行Person静态代码块执行Student静态代码块执行Person构造代码块执行Person构造方法ABC执行Student构造代码块执行Student构造方法ABC--------------------执行Person构造代码块执行Person无参构造方法执行Student构造代码块执行Student无参构造方法 说明：一般的类里面包含：1、静态代码块（静态区、静态变量等）2、构造代码块（{ }中间的内容）3、构造方法 其执行顺序也是1、2、3先后执行，这里需要注意的是：考虑继承特性。子类与父类的执行顺序是：1、先执行父类的静态代码块（父1）2、子类的静态代码块（子1）3、父类构造代码块（父2）4、父类构造方法（父3）5、子类构造代码块（子2）6、子类构造方法（子3） 当一个类从被JVM装载开始，各种代码的执行顺序大致如下： 被JVM装载-&gt;执行父类的相关代码-&gt;如果有静态初始化，先执行静态初始化，且只执行一次，以后即使有该类实例化，也不会再执行-&gt;如果有静态代码块，以与静态初始化一样的方式执行-&gt;如果有new语句带来的实例化，先为成员变量分配空间，并绑定参数列表，隐式或显式执行super()，即父类的构造方法-&gt;执行非静态代码块-&gt;执行本类的构造函数-&gt;执行其他代码。 这里的执行顺序同子类构造中有一个默认的父类构造super()无关，不是执行到隐藏的super()才开始初始化父类的，类的初始化是分层初始化，即先初始化父类，再初始化子类，初始化每个类的过程中，进行类的初始化工作，先进性成员变量的初始化，成员变量的初始化顺序是：默认初始化，即int为0这种－&gt;显示初始化，例如给int型显示初始化了值－&gt;构造方法初始化，所以是这里执行到了构造方法。 但是一定要注意，父类初始化选择的构造方法却和子类中super 选择的构造相关。 转载自：https://blog.csdn.net/wuhaiwei002/article/details/55226155","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"HashTable、HashMap和ConCurrentHashMap区别","date":"2018-04-04T08:19:04.000Z","path":"2018/04/04/HashTable、HashMap和ConCurrentHashMap区别/","text":"Map├Hashtable├HashMap└WeakHashMap HashMap和HashTable的对比 1.HashMap是非线程安全的，HashTable是线程安全的。 Hashtable中的线程安全是Synchronize的（sychronized意味着在一次仅有一个线程能够更改Hashtable，就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable）；而HashMap中的方法在缺省情况下是非Synchronize的。所以在单线程环境下Hashtable比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理： Map m =Collections.synchronizedMap(new HashMap(…))。 2.HashMap的键和值都允许有null存在，而HashTable则都不行。 3.因为线程安全、哈希效率的问题，HashMap效率比HashTable的要高。 4.哈希值的使用不同 HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 5.内部实现使用的数组初始化和扩容方式不同 HashMap默认初始化数组的大小为16，要求底层数组的容量一定要为2的整数次幂，HashTable为11。HashMap扩容时乘2，使用位运算取得哈希，效率高于取模。而HashTable为乘2加1，都是素数和奇数，这样取模哈希结果更均匀。 6.继承的父类不同 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 7.两个遍历方式的内部实现上不同 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。 8.是否提供contains方法 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。 Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 HashTable和ConCurrentHashMap的对比ConcurrentHashMap引入了分割(Segment)，把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。 HashMap和ConCurrentHashMap的对比（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。 （2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"排序算法","date":"2018-04-03T13:18:20.000Z","path":"2018/04/03/排序算法/","text":"综述内排序有可以分为以下几类： (1)、插入排序：直接插入排序、二分法插入排序、希尔排序。(2)、选择排序：简单选择排序、堆排序。(3)、交换排序：冒泡排序、快速排序。(4)、归并排序(5)、基数排序 排序方法 平均情况 最好情况 最坏情况 空间复杂度 稳定性 插入排序 O(n2) O(n) O(n2) O(1) 稳定 shell排序 O(n1.3) O(n) O(n2) O(1) 不稳定 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 稳定 基数排序 O(d(r+n)) O(d(r+rd)) O(d(r+n)) O(rd+n) 稳定 注：基数排序 r表示关键字的基数 d代表长度 n代表关键字的个数 - O（n2）排序冒泡排序基本思想：比较数组相邻的两个值，把大的像泡泡一样“冒”到数组后面去，一共要执行N的平方除以2这么多次的比较和交换的操作（N为数组元素），其复杂度为Ο(n²)。 1234567891011public static void bubbleSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123;//外层循环控制排序趟数 for(int j=0;j&lt;arr.length-1-i;j++)&#123;//内层循环控制每一趟排序多少次 if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;&#125; 选择排序123456789101112131415161718public static void selectsort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; for(int i=0;i&lt;arr.length;i++)&#123; int index = i;//初始下标为i for(int j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[index])&#123; index = j; &#125; &#125; if(index != i)&#123; int temp = arr[index]; arr[index] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 插入排序基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 1234567891011public static void insertSort(int[] a) &#123; for(int i = 1; i &lt; a.length; i++) &#123;// 从数组的第二个元素开始循环将数组中的元素插入 int temp = a[i];// 设置数组中的第2个元素为第一次循环要插入的数据 int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; a[j]) &#123; a[j + 1] = a[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动 j--; &#125; a[j + 1] = temp;// 直到要插入的元素不小于第j个元素,将temp插入到数组中 &#125;&#125; shell排序基本思想：本质是插入排序，通过将数组数组的方式来将增加排序的速度，分组的方式第一次将数组的长度/2,第二次/4,当结果等于1的时候，那么将这个数组进行插入排序就完成了排序，当然分组时也是需要排序的。 123456789101112131415public static void shellSort(int[] a) &#123; // 将数组分组 for (int temp = a.length / 2; temp &gt;= 1; temp /= 2) &#123; // 这里的思路和插入排序的思路相同，通过找到前一个的数大于或者小于来进行插入 for(int i = temp; i &lt; a.length; i += temp) &#123; int temp = a[i]; int j = i - temp; while(j &gt;= 0 &amp;&amp; temp &lt; a[j]) &#123; a[j + temp] = a[j]; j -= temp; &#125; a[j + temp] = temp; &#125; &#125; &#125; O（nlog2n）排序快速排序12345678910111213141516171819public static void quickSort(int[] arr,int low,int high)&#123; if(low &gt; high)&#123; return ; &#125; int i = low, j = high,temp = arr[low]; while(i &lt; j)&#123; while( arr[j] &gt;= temp &amp;&amp; i &lt; j)&#123; j--; &#125; arr[i] = arr[j]; while(arr[i] &lt;= temp &amp;&amp; i &lt; j)&#123; i++; &#125; arr[j] = arr[i]; &#125; arr[j] = temp; quickSort(arr,low,j-1); quickSort(arr,j+1,high);&#125; 归并排序（1）稳定性：归并排序是一种稳定的排序。（2）存储结构要求：可用顺序存储结构。也易于在链表上实现。（3）时间复杂度：对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。（4）空间复杂度：需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。 注意：若用单链表做存储结构，很容易给出就地的归并排序 12345678910111213141516171819202122232425262728293031323334353637public static int[] sort(int[] a,int low,int high)&#123; int mid = (low+high)/2; if(low&lt;high)&#123; sort(a,low,mid); sort(a,mid+1,high); //左右归并 merge(a,low,mid,high); &#125; return a; &#125; public static void merge(int[] a, int low, int mid, int high) &#123; int[] temp = new int[high-low+1]; int i= low; int j = mid+1; int k=0; // 把较小的数先移到新数组中 while(i&lt;=mid &amp;&amp; j&lt;=high)&#123; if(a[i]&lt;a[j])&#123; temp[k++] = a[i++]; &#125;else&#123; temp[k++] = a[j++]; &#125; &#125; // 把左边剩余的数移入数组 while(i&lt;=mid)&#123; temp[k++] = a[i++]; &#125; // 把右边边剩余的数移入数组 while(j&lt;=high)&#123; temp[k++] = a[j++]; &#125; // 把新数组中的数覆盖nums数组 for(int x=0;x&lt;temp.length;x++)&#123; a[x+low] = temp[x]; &#125; &#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; int[] a=&#123;49,38,65,97,76,13,27,49,78,34,12,64&#125;; int arrayLength=a.length; //循环建堆 for(int i=0;i&lt;arrayLength-1;i++)&#123; //建堆 buildMaxHeap(a,arrayLength-1-i); //交换堆顶和最后一个元素 swap(a,0,arrayLength-1-i); System.out.println(Arrays.toString(a)); &#125; &#125; //对data数组从0到lastIndex建大顶堆 public static void buildMaxHeap(int[] data, int lastIndex)&#123; //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125; //交换 private static void swap(int[] data, int i, int j) &#123; int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125;&#125; 基数排序123456789101112131415161718192021222324252627282930import java.util.*;public class RadixSort &#123; // 各位装通法 public int[] radixSort(int[] A, int n) &#123; int length = n; int divisor = 1;// 定义每一轮的除数，1,10,100... //定义了10个桶，以防每一位都一样全部放入一个桶中 int[][] bucket = new int[10][length]; int[] count = new int[10];// 统计每个桶中实际存放的元素个数 int digit;// 获取元素中对应位上的数字，即装入那个桶 for (int i = 1; i &lt;= 3; i++) &#123;// 经过4次装通操作，排序完成 for (int temp : A) &#123;// 计算入桶 digit = (temp / divisor) % 10; bucket[digit][count[digit]++] = temp; &#125; int k = 0;// 被排序数组的下标 for (int b = 0; b &lt; 10; b++) &#123;// 从0到9号桶按照顺序取出 if (count[b] == 0)// 如果这个桶中没有元素放入，那么跳过 continue; for (int w = 0; w &lt; count[b]; w++) &#123; A[k++] = bucket[b][w]; &#125; count[b] = 0;// 桶中的元素已经全部取出，计数器归零 &#125; divisor *= 10; &#125; return A; &#125;&#125; 总结1.若n较小(如n≤50)，可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。2.若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；3.若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。4.快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；5.堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。6.若要求排序稳定，则可选用归并排序。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/数据结构与算法/"}]},{"title":"HashMap的工作原理","date":"2018-04-03T10:28:28.000Z","path":"2018/04/03/HashMap的工作原理/","text":"“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。 “如果两个键的hashcode相同，你如何获取值对象？”面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 “如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 散列表的hash算法是根据移位来进行计算的，只能是进行＊2或者／2。因此，扩容的大小要符合这个标准，否则会造成没必要的浪费甚至错误。扩容的成本并不低，因为需要遍历一个时间复杂度为O(n)的数组，并且为其中的每个enrty进行hash计算。加入到新数组中，所以最好的情况是能够合理的使用HashMap的构造方法创建合适大小的HashMap，使得在不浪费内存的情况下，尽量减少扩容，这个就要根据业务来决定了。 “你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(racecondition)。 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ 热心的读者贡献了更多的关于HashMap的问题： 为什么String,Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。 我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点： hashing的概念 HashMap中解决碰撞的方法 equals()和hashCode()的应用，以及它们在HashMap中的重要性 不可变对象的好处 HashMap多线程的条件竞争 重新调整HashMap的大小 总结1. 什么时候会使用HashMap？它有什么特点？ 是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2.HashMap的工作原理 HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将Key传给get()方法，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap在每个链表节点中储存键值对对象。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？HashMap中解决碰撞的方法 通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法计算index，把节点再放到新的bucket中。 6.当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。 转载自：http://www.importnew.com/10620.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://bameirilyo.github.io/BameirilyoBlog/tags/Java基础/"}]},{"title":"Hello,My Blog","date":"2018-04-02T13:17:30.000Z","path":"2018/04/02/Hello-My-Blog/","text":"纵有疾风起，人生不言弃 花了一天半的时间终于开通了自己的博客。参照网上教程从下载Node.js、Hexo到下载博客模板、调试、配置成自己想要的样子，以及学这个Markdown语法，中间也遇到了一些小小的Bug，有些百度出来了，有的自己解决了，有的还没解决就只能小小的掩盖一下，以后慢慢学习，不断进步，慢慢解决吧。 虽然是借用了Hexo的模板，并挂在Github上的免费博客，但还是希望自己以后能坚持写下去，能将学习过程中的点点滴滴都能记录下来！纵有疾风起，人生不言弃！","tags":[]},{"title":"Hello World","date":"2018-04-01T15:50:22.104Z","path":"2018/04/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]